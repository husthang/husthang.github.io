<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Quartz详解及源码探究2-quartz调度器scheduler]]></title>
      <url>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B62-quartz%E8%B0%83%E5%BA%A6%E5%99%A8scheduler.html</url>
      <content type="html"><![CDATA[<h1 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>客户端会同两种类型的 Scheduler 交互，如图,它们都实现了 org.quartz.Scheduler 接口</li>
<li><p>Scheduler代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）<br><img src="../images/QuartzFigure4.2.JPG" alt=""></p>
</li>
<li><p>Scheduler 的 API 可以分组成以下三个类别：</p>
<ul>
<li>管理 Scheduler</li>
<li>管理 Job</li>
<li>管理 Trigger 和 Calendar</li>
</ul>
</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="../images/quartz类结构.png" alt=""></p>
<ol>
<li>StdSchedule只是QuartzSchedule的一个包装类，方法更清晰。</li>
<li>QuartzScheduler是整个定时任务框架工作的核心类，上面的类图仅仅展现了QuartzScheduler中几个核心成员。</li>
<li>QuartzSchedulerResources可以认为是存放一切配置以及通过配置初始化出来的一些资源的容器，其中包括了存储job定义的jobStore</li>
<li>QuartzSchedulerThread多线程启动</li>
</ol>
<h1 id="Quartz-SchedulerFactory"><a href="#Quartz-SchedulerFactory" class="headerlink" title="Quartz SchedulerFactory"></a>Quartz SchedulerFactory</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>用工厂方法构造scheuler实例，并使之正确的得到初始化。 所有的 Scheduler 实例应该由 SchedulerFactory 来创建。</li>
<li>　Quartz 框架为这一目的提供了 org.quartz.SchedulerFactory 接口。角色 SchedulerFactory 就是用来产生 Scheduler 实例的。当 Scheduler 实例被创建之后，就会存到一个仓库中(org.quartz.impl.SchedulerRepository)，这个仓库还提供了通过一个 class loader 查询实例的机制。<br><img src="../images/QuartzFigure4.3.JPG" alt=""><ul>
<li>DirectSchedulerFactory 是为那些想绝对控制 Scheduler 实例是如何生产出的人所设计的</li>
<li>与 DirectSchedulerFactory 形成鲜明对比的是，org.quartz.impl.StdSchedulerFactory 依赖于一系列的属性来决定如何生产出 Scheduler 实例</li>
</ul>
</li>
</ul>
<h2 id="StdSchedulerFactory源码分析"><a href="#StdSchedulerFactory源码分析" class="headerlink" title="StdSchedulerFactory源码分析"></a>StdSchedulerFactory源码分析</h2><ol>
<li><p>无参的initialize()方法，StdSchedulerFactory 会执行以下几个步骤去尝试为工厂加载属性：</p>
<ol>
<li>检查 System.getProperty(“org.quartz.properties”) 中是否设置了别的文件名</li>
<li>否则，使用 quartz.properties 作为要加载的文件名</li>
<li>试图从当前工作目录中加载这个文件</li>
<li>试图从系统 classpath 下加载这个文件<br><img src="../images/stdchedulerFactory-initialize.png" alt=""></li>
</ol>
</li>
<li><p>StdSchedulerFactory.getScheduler()源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public Scheduler getScheduler() throws SchedulerException &#123;</div><div class="line">        // 读取quartz配置文件，未指定则顺序遍历各个path下的quartz.properties文件</div><div class="line">        // 解析出quartz配置内容和环境变量，存入PropertiesParser对象</div><div class="line">        // PropertiesParser组合了Properties（继承Hashtable），定义了一系列对Properties的操作方法，比如getPropertyGroup()批量获取相同前缀的配置。配置内容和环境变量存放在Properties成员变量中</div><div class="line">        if (cfg == null) &#123;</div><div class="line">            initialize();</div><div class="line">        &#125;</div><div class="line">        // 获取调度器池，采用了单例模式</div><div class="line">        // 其实，调度器池的核心变量就是一个hashmap，每个元素key是scheduler名，value是scheduler实例</div><div class="line">        // getInstance()用synchronized防止并发创建</div><div class="line">        SchedulerRepository schedRep = SchedulerRepository.getInstance();</div><div class="line"></div><div class="line">        // 从调度器池中取出当前配置所用的调度器</div><div class="line">        Scheduler sched = schedRep.lookup(getSchedulerName());</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">        // 如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：（见实例化源码分析）</div><div class="line">        sched = instantiate();</div><div class="line"></div><div class="line">        return sched;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>instantiate()实例化，源码分析<br>如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：</p>
<ul>
<li>1）初始化threadPool(线程池)：开发者可以通过org.quartz.threadPool.class配置指定使用哪个线程池类，比如SimpleThreadPool。先class load线程池类，接着动态生成线程池实例bean，然后通过反射，使用setXXX()方法将以org.quartz.threadPool开头的配置内容赋值给bean成员变量；</li>
<li>2）初始化jobStore(任务存储方式)：开发者可以通过org.quartz.jobStore.class配置指定使用哪个任务存储类，比如RAMJobStore。先class load任务存储类，接着动态生成实例bean，然后通过反射，使用setXXX()方法将以org.quartz.jobStore开头的配置内容赋值给bean成员变量；</li>
<li>3）初始化dataSource(数据源)：开发者可以通过org.quartz.dataSource配置指定数据源详情，比如哪个数据库、账号、密码等。jobStore要指定为JDBCJobStore，dataSource才会有效；</li>
<li>4）初始化其他配置：包括SchedulerPlugins、JobListeners、TriggerListeners等；</li>
<li>5）初始化threadExecutor(线程执行器)：默认为DefaultThreadExecutor；</li>
<li>6）创建工作线程：根据配置创建N个工作thread，执行start()启动thread，并将N个thread顺序add进threadPool实例的空闲线程列表availWorkers中；</li>
<li>7）创建调度器线程：创建QuartzSchedulerThread实例，并通过threadExecutor.execute(实例)启动调度器线程；</li>
<li>8）创建调度器：创建StdScheduler实例，将上面所有配置和引用组合进实例中，并将实例存入调度器池中</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Quartz详解及源码探究1-quartz入门及核心概念]]></title>
      <url>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B61-quartz%E5%85%A5%E9%97%A8%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html</url>
      <content type="html"><![CDATA[<h1 id="Quartz核心概念"><a href="#Quartz核心概念" class="headerlink" title="Quartz核心概念"></a>Quartz核心概念</h1><h2 id="Quartz使用入门"><a href="#Quartz使用入门" class="headerlink" title="Quartz使用入门"></a>Quartz使用入门</h2><ul>
<li>首先看一个Quartz入门demo，由此入门demo深入剖析Quartz原理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package quartz;</div><div class="line"></div><div class="line">import org.quartz.*;</div><div class="line">import org.quartz.impl.StdSchedulerFactory;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by liuhang on 2017/8/1.</div><div class="line"> */</div><div class="line">public class QuartzTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            </div><div class="line">            //工程方法模式构造scheduler</div><div class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</div><div class="line"></div><div class="line">            //这里用到Builder模式</div><div class="line">            JobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(&quot;myJob&quot;, &quot;myJobGroup&quot;).build();</div><div class="line"></div><div class="line">            Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;myTrigger&quot;, &quot;myTriggerGroup&quot;).startNow().withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever()).build();</div><div class="line"></div><div class="line">            scheduler.scheduleJob(jobDetail, trigger);</div><div class="line"></div><div class="line">            scheduler.start();</div><div class="line"></div><div class="line"></div><div class="line">        &#125; catch (SchedulerException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package quartz;</div><div class="line"></div><div class="line">import org.quartz.Job;</div><div class="line">import org.quartz.JobExecutionContext;</div><div class="line">import org.quartz.JobExecutionException;</div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by liuhang on 2017/8/1.</div><div class="line"> */</div><div class="line">public class JobImpl implements Job &#123;</div><div class="line">    private static Logger logger = LoggerFactory.getLogger(JobImpl.class);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</div><div class="line">        logger.info(&quot;Hello World! - &quot; + new Date());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>由demo可以看出，quartz的几个核心概念：Job，Trigger，Scheduler，Calendar； 如下图所示<br><img src="../images/quartz核心概念.png" alt=""></p>
<ul>
<li>Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）</li>
<li>Job：是一个接口，只有一个方法void execute(JobExecutionContext context)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中；</li>
<li>JobDetail：Quartz在每次执行Job时，都重新创建一个Job实例，所以它不直接接受一个Job的实例，相反它接收一个Job实现类，以便运行时通过newInstance()的反射机制实例化Job。因此需要通过一个类来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息，JobDetail承担了这一角色。</li>
<li>Trigger：是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当仅需触发一次或者以固定时间间隔周期执行，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如每早晨9:00执行，周一、周三、周五下午5:00执行等；</li>
<li>Calendar：org.quartz.Calendar和java.util.Calendar不同，它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。</li>
</ul>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html" target="_blank" rel="external">官方文档</a></p>
</li>
<li><p><a href="http://www.quartz-scheduler.org/api/2.2.1/index.html" target="_blank" rel="external">官方api</a></p>
</li>
<li><p><a href="https://unmi.cc/category/quartz/" target="_blank" rel="external">quartz详解博客-文档</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/bab8e4e32952" target="_blank" rel="external">quartz原理揭秘和源码解读
</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大数据-Hadoop学习1]]></title>
      <url>http://liuhang.net.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop%E5%AD%A6%E4%B9%A01.html</url>
      <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ol>
<li>Hadoop提供了一个稳定的共享存储和分析系统。存储由HDFS实现，分析由MapReduce实现</li>
</ol>
<h1 id="Mac下Hadoop2-7-x配置伪分布环境-wordcount运行"><a href="#Mac下Hadoop2-7-x配置伪分布环境-wordcount运行" class="headerlink" title="Mac下Hadoop2.7.x配置伪分布环境(wordcount运行)"></a>Mac下Hadoop2.7.x配置伪分布环境(wordcount运行)</h1><h2 id="ssh环境配置"><a href="#ssh环境配置" class="headerlink" title="ssh环境配置"></a>ssh环境配置</h2><ol>
<li><code>ssh localhost</code>验证是否能无密码登录<ul>
<li>出现<code>ssh: connect to host localhost port 22: Connection refused</code>，在”系统偏好设置-共享”中打开远程登录选项</li>
</ul>
</li>
<li><code>ssh-keygen -t rsa -f ~/.ssh/id_rsa</code><br> <code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></li>
</ol>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><ol>
<li><code>export HADOOP_INSTALL=/Users/home/liuhang/Java/hadoop/hadoop-2.8.1</code><br> <code>export PATH=$PATH:$HADOOP_INSTALL/bin</code> ；export设置只对当前的bash登陆session有效.</li>
<li>要使得环境变量一直生效，可修改<code>vim ~/.bash_profile</code>,把命令加载进入bash启动脚本中</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://kiritor.github.io/2016/04/24/Hadoop-install/" target="_blank" rel="external">Mac下Hadoop2.7.x配置伪分布环境(wordcount运行)</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[随笔-校招记录]]></title>
      <url>http://liuhang.net.cn/%E9%9A%8F%E7%AC%94-%E6%A0%A1%E6%8B%9B%E8%AE%B0%E5%BD%95.html</url>
      <content type="html"><![CDATA[<h1 id="练手的"><a href="#练手的" class="headerlink" title="练手的"></a>练手的</h1><h2 id="拼多多-已投"><a href="#拼多多-已投" class="headerlink" title="拼多多(已投)"></a>拼多多(已投)</h2><ol>
<li>8.1号晚上，牛客</li>
</ol>
<h2 id="苏宁（已投）"><a href="#苏宁（已投）" class="headerlink" title="苏宁（已投）"></a>苏宁（已投）</h2><ol>
<li>筛选中</li>
</ol>
<h2 id="科大飞讯-已投"><a href="#科大飞讯-已投" class="headerlink" title="科大飞讯(已投)"></a>科大飞讯(已投)</h2><ol>
<li>筛选中</li>
</ol>
<h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><ol>
<li>内推</li>
<li>面试8.10-8.20左右</li>
</ol>
<h2 id="4399（已投）"><a href="#4399（已投）" class="headerlink" title="4399（已投）"></a>4399（已投）</h2><ol>
<li>时间</li>
</ol>
<h2 id="顺丰（已投）"><a href="#顺丰（已投）" class="headerlink" title="顺丰（已投）"></a>顺丰（已投）</h2><h2 id="亚马逊"><a href="#亚马逊" class="headerlink" title="亚马逊"></a>亚马逊</h2><h2 id="Thoughtworks-已投"><a href="#Thoughtworks-已投" class="headerlink" title="Thoughtworks(已投)"></a>Thoughtworks(已投)</h2><h2 id="搜狐（已投）"><a href="#搜狐（已投）" class="headerlink" title="搜狐（已投）"></a>搜狐（已投）</h2><h2 id="搜狗（已投）"><a href="#搜狗（已投）" class="headerlink" title="搜狗（已投）"></a>搜狗（已投）</h2><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><h2 id="京东（已投）"><a href="#京东（已投）" class="headerlink" title="京东（已投）"></a>京东（已投）</h2><ol>
<li>管培生，在线笔试：<strong>8月25日</strong></li>
<li>Java开发，在线笔试：<strong>9月8日</strong></li>
</ol>
<h2 id="百度（已投）"><a href="#百度（已投）" class="headerlink" title="百度（已投）"></a>百度（已投）</h2><ol>
<li>在线笔试：<strong>9月11日</strong>；</li>
</ol>
<h2 id="滴滴（已投）"><a href="#滴滴（已投）" class="headerlink" title="滴滴（已投）"></a>滴滴（已投）</h2><ol>
<li>笔试时间 <strong>8.26日</strong></li>
</ol>
<h2 id="今日头条（已投）"><a href="#今日头条（已投）" class="headerlink" title="今日头条（已投）"></a>今日头条（已投）</h2><ol>
<li>笔试时间未定</li>
</ol>
<h2 id="美团点评"><a href="#美团点评" class="headerlink" title="美团点评"></a>美团点评</h2><ol>
<li>内推 （已投） 笔试时间：<em>**8月31日</em></li>
<li>秋招</li>
</ol>
<h2 id="网易（已投）"><a href="#网易（已投）" class="headerlink" title="网易（已投）"></a>网易（已投）</h2><ol>
<li>笔试时间<strong>9月9日</strong></li>
</ol>
<h2 id="腾讯（已投）"><a href="#腾讯（已投）" class="headerlink" title="腾讯（已投）"></a>腾讯（已投）</h2><ol>
<li>笔试时间<strong>9月13日</strong></li>
</ol>
<h2 id="去哪儿-已投"><a href="#去哪儿-已投" class="headerlink" title="去哪儿(已投)"></a>去哪儿(已投)</h2><ol>
<li><h2 id="58同城"><a href="#58同城" class="headerlink" title="58同城"></a>58同城</h2></li>
<li><strong>8月23日</strong>，内推提前批笔试</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试-设计模式]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试-JVM相关]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-JVM%E7%9B%B8%E5%85%B3.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程11-Fork/Join框架]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11-Fork-Join%E6%A1%86%E6%9E%B6.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程0-Java多线程面试总结]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B0-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.importnew.com/12773.html" target="_blank" rel="external">面试问题收集</a></li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li><p>什么是线程</p>
<ul>
<li>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位</li>
</ul>
</li>
<li><p>进程和线程有什么区别</p>
<ul>
<li>进程是资源分配的基本单位，一个进程可以包含多个线程，进程间切换开销大；</li>
<li>引入线程的好处：创建进程开销小，易于调度，提高并发性</li>
</ul>
</li>
<li><p>Java实现多线程的方法</p>
<ul>
<li>继承Thread类，重写其run方法</li>
<li>实现Runnable接口（查看源码，发现Thread类也实现了Runnable接口）</li>
<li>实现Callable接口,Future,线程池框架</li>
</ul>
</li>
<li><p>用Runnable还是Thread</p>
<ul>
<li>Java不支持多继承，允许实现多个接口，如果要继承其他类，用Runable更好</li>
</ul>
</li>
<li><p>Java中Runnable和Callable有什么不同？</p>
<ul>
<li>主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象</li>
</ul>
</li>
<li><p>Volatile变量</p>
<ul>
<li><strong>可见性</strong>：每次使用v之前，从主内存刷新最新的值(read,load,use操作连在一起)； 每次修改V之后，立马同步回主内存(assign,store,write操作连在一起)；</li>
<li><strong>防止指令重排</strong>：保证代码执行顺序，与程序顺序相同;下一个读取操作会在前一个写操作之后发生。volatile写之前的所有操作都不会被重排序到volatile之后;保volatile读之后的所有操作都不会被重排序到volatile之前;第一个操作是volatile写操作时,第二个操作是volatile读操作,不能进行重排序.</li>
</ul>
</li>
<li><p>Java内存模型</p>
<ul>
<li>规定Java程序在不同硬件平台下，达到一致的内存访问效果。屏蔽掉硬件和操作系统的差异</li>
</ul>
</li>
<li><p>什么是竞态条件。</p>
<ul>
<li>当多个线程竞争同一资源时，程序的结果依赖于线程执行的顺序。由于不恰当的执行顺序，而出现不正确的结果，即出现”竞态条件“</li>
<li>举例： 单例模式，延迟加载。</li>
</ul>
</li>
<li><p>线程池，为什么要用线程池</p>
<ul>
<li>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理</li>
<li>好处：<ul>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadLocal变量</p>
<ul>
<li>线程局部变量</li>
<li>用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。采用的是空间换时间的策略</li>
<li>底层原理：ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本</li>
<li>与同步机制的比较：synchronized同步机制，仅提供一份变量，让不同的线程排队访问，后者为每个线程都提供了一份变量，互相不影响的访问。</li>
<li>应用：Spirng中，有状态的Bean，用ThreadLocal封装，可以申明为Singleton作用域，变成无状态的</li>
</ul>
</li>
<li><p>Java中interrupted 和 isInterruptedd方法的区别</p>
<ul>
<li>interrupted方法，静态方法，Thread.interrupted，测试当前线程是否中断；调用之后，中断状态会被清除为false</li>
<li>isInterrupted，非静态方法，查询这个线程是否中断</li>
</ul>
</li>
<li><p>读写锁</p>
<ul>
<li>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞；</li>
<li>读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升；</li>
<li>应用场景：读多于写的情况</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li>产生死锁的四个必要条件<ul>
<li>互斥（ Mutual exclusion ）条件：一个资源一次只能被一个进程所使用，即是排它性使用。</li>
<li>不可抢占（ No preemption ）条件：一个资源仅能被占有它的进程所释放，而不能被别的进程强占。</li>
<li>请求和保持（ Hold-and-wait ）条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放。</li>
<li>环路等待（ Circular wait ）条件：当每类资源只有一个时，在发生死锁时，必然存在一个进程-资源的环形链。如一系统状态的资源分配图所示，P1正在等待一个P2 占用的资源R2，P2正在等待一个P1占用的资源R1。</li>
</ul>
</li>
<li>死锁的预防： 破坏四个条件之一</li>
<li>死锁的避免：在资源分配之前，计算分配是否安全。 如：银行家算法</li>
</ul>
</li>
<li><p>阻塞队列</p>
<ul>
<li>阻塞队列（BlockingQueue），支持阻塞的插入和移除方法<ul>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空</li>
</ul>
</li>
<li>Java里的阻塞队列(Java里的阻塞队列)<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
</ul>
</li>
</ul>
</li>
<li><p>Fork/join框架</p>
<ul>
<li>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干<br>个小任务，最终汇总每个小任务结果后得到大任务结果的框架</li>
<li>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行</li>
<li>ForkJoinTask：分隔任务；RecursiveTask：用于有返回结果的任务。RecursiveAction：用于没有返回结果的任务。</li>
<li>ForkJoinPool：执行任务</li>
</ul>
</li>
<li><p>重入锁，公平锁</p>
<ul>
<li>重入锁：同一个线程再次进入同步代码的时候.可以再次获取自己已经获取到的锁。</li>
<li>公平锁：多个线程再等待同一个锁时，必须按照申请锁的实际顺序来依次获得锁</li>
</ul>
</li>
<li><p>CountDownLatch计数门闩与同步屏障CyclicBarrier</p>
<ul>
<li>CountDownLatch允许一个或多个线程等待其他线程完成操作（跟join类似）</li>
<li>CyclicBarrier让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</li>
<li>区别：CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置</li>
</ul>
</li>
<li><p>控制并发线程数的Semaphore</p>
<ul>
<li>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</li>
</ul>
</li>
<li><p>线程池原理</p>
<ul>
<li>为什么使用线程池，线程池好处<ul>
<li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，<br>还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>
</ul>
</li>
</ul>
</li>
<li><p>ConcurrentHashMap</p>
<ul>
<li>使用了锁分段技术技术来保证线程安全的，锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</li>
<li>put和get操作是原子操作，是线程安全</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程10-定时器Timer]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B10-%E5%AE%9A%E6%97%B6%E5%99%A8Timer.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring-源码研究2-AOP实现]]></title>
      <url>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B62-AOP%E5%AE%9E%E7%8E%B0.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring-源码研究3-SpringMVC实现]]></title>
      <url>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B63-SpringMVC%E5%AE%9E%E7%8E%B0.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试准备]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E4%BB%96.html</url>
      <content type="html"><![CDATA[<h1 id="关于你的缺点"><a href="#关于你的缺点" class="headerlink" title="关于你的缺点"></a>关于你的缺点</h1><ol>
<li>不懂得如何拒绝别人，导致影响自己的工作进度。比如，在实验室做的项目，经常是同学碰到一个问题不会，让我帮忙，我就去帮他搞定，导致自己的东西没做完，或者做到很晚。 改进方向是，首先告诉他，自己在什么时候可以给予帮助，而不是立马放下手头的事情去帮忙，让他决定是否继续求助。 其次，在帮助他解决问题的时候，不是一手包办，而是指明一个方向，告诉他查找什么资料可以解决，或者大体是什么思路，让他尽量自己解决。</li>
<li>喜欢刨根问底的钻一些细节，导致做的一些事情不能按期完成。比如说，使用一些开源框架，就想去看看到底咋回事，导致太发散，没有聚焦点。通过时间管理，改变工作方式。</li>
</ol>
<h1 id="项目1：华中科技大学电子工程系官网"><a href="#项目1：华中科技大学电子工程系官网" class="headerlink" title="项目1：华中科技大学电子工程系官网"></a>项目1：华中科技大学电子工程系官网</h1><h2 id="项目中遇到的问题"><a href="#项目中遇到的问题" class="headerlink" title="项目中遇到的问题"></a>项目中遇到的问题</h2><ol>
<li>国际化问题：学院有留学生，院系与外国学校有合作交流，官网的国际化问题是个大问题。前期设计时，没有考虑到国际化。用了一个比较挫的解办法，相当于重新做了一个，部署了两个来切换。  解决办法是，设计阶段考虑国际化问题，目前正在重构。Spring MessageSource.</li>
<li></li>
</ol>
<h1 id="登录、注册、浏览"><a href="#登录、注册、浏览" class="headerlink" title="登录、注册、浏览"></a>登录、注册、浏览</h1><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><ol>
<li>用户名合法性检测（长度，敏感词（比如它不能叫管理员之类的），重复）</li>
<li>密码长度要求</li>
</ol>
<h1 id="敏感词检查"><a href="#敏感词检查" class="headerlink" title="敏感词检查"></a>敏感词检查</h1><ul>
<li>字典树-数据结构</li>
</ul>
<h1 id="redis实现缓存，点赞等"><a href="#redis实现缓存，点赞等" class="headerlink" title="redis实现缓存，点赞等"></a>redis实现缓存，点赞等</h1><h1 id="异步事件Redis实现"><a href="#异步事件Redis实现" class="headerlink" title="异步事件Redis实现"></a>异步事件Redis实现</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring-源码研究1-ioc容器实现]]></title>
      <url>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B61-ioc%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring-面试问题总结]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Spring-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="Spring是什么，简单说下Spring"><a href="#Spring是什么，简单说下Spring" class="headerlink" title="Spring是什么，简单说下Spring"></a>Spring是什么，简单说下Spring</h1><ol>
<li>Spring是分层的Java EE/SE一站式开源框架，它以IoC控制反转和AOP（面向切面编程）为核心。</li>
</ol>
<h1 id="Spring优点"><a href="#Spring优点" class="headerlink" title="Spring优点"></a>Spring优点</h1><ul>
<li>IoC支持方便解耦，简化开发</li>
<li>AOP编程的支持</li>
<li>声明式事务的支持</li>
<li>方便程序的测试</li>
<li>方便集成各种优秀框架</li>
<li>降低JavaEE API的使用难度</li>
</ul>
<h1 id="控制反转IoC和依赖注入DI"><a href="#控制反转IoC和依赖注入DI" class="headerlink" title="控制反转IoC和依赖注入DI"></a>控制反转IoC和依赖注入DI</h1><ul>
<li>控制反转：借助第三方（即容器），把新建对象的控制权，交给了容器，由容器负责对象新建装配</li>
<li>依赖注入：实现控制反转的方式有依赖注入和依赖查找</li>
<li>Spring中依赖注入DI的类型：构造函数注入，属性注入；</li>
</ul>
<h1 id="Spring中装配Bean的几种方式"><a href="#Spring中装配Bean的几种方式" class="headerlink" title="Spring中装配Bean的几种方式"></a>Spring中装配Bean的几种方式</h1><ul>
<li>现在有四种方式<ul>
<li>基于XML配置</li>
<li>基于注解配置</li>
<li>基于Java配置</li>
<li>基于Groovy 动态语言配置</li>
</ul>
</li>
</ul>
<h1 id="Spring中用到了哪些设计模式"><a href="#Spring中用到了哪些设计模式" class="headerlink" title="Spring中用到了哪些设计模式"></a>Spring中用到了哪些设计模式</h1><ol>
<li>代理模式,</li>
<li>工厂模式</li>
<li>单例模式</li>
<li>模板方法模式：用来解决代码重复的问题</li>
<li>策略模式：Resource与ResourceLoader</li>
</ol>
<h1 id="描述一下-Spring-Bean的生命周期"><a href="#描述一下-Spring-Bean的生命周期" class="headerlink" title="描述一下 Spring Bean的生命周期"></a>描述一下 Spring Bean的生命周期</h1><p>关键节点</p>
<ol>
<li>实例化，前后InstantiationAwareBeanPostProcessor接口的方法；</li>
<li>设置属性值， 后 BeanNameAware和BeanFactoryAware，感知BeanName和BeanFactory</li>
<li>初始化方法（init-method） 前后 BeanPostProcessor接口方法，对Bean进行处理，前nitializingBean处理</li>
<li>销毁方法(destory-method)，前DisposeBean处理</li>
</ol>
<p>三类方法调用</p>
<ol>
<li>Bean自身的方法调用，构造函数来实例化Bean,Setter方法设置Bean的属性，init_method和destory_method方法</li>
<li>Bean级生命周期接口方法（Bean自己实现的接口），BeanNameAware和BeanFactoryAware,InitializingBean和DisposeBean</li>
<li>容器及生命周期接口方法，InstantiationAwareBeanPostProcessor和BeanPostProcessor接口，分别在实例化和初始化前后，对Bean进行处理</li>
</ol>
<h1 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h1><ol>
<li>BeanFactory是Spring最核心的接口，它是工厂模式的实现，来负责实例化Bean并建立Bean之间的依赖关系，控制Bean的生命周期；</li>
<li>ApplicationContext应用上下文，它是建立在BeanFactory基础上（ApplicationContext接口继承ListableBeanFactory接口，ListableBeanFactory继承BeanFactory接口）；BeanFactory更加底层，它面对Spring本身；而ApplicationContext面向使用Spring的开发者；它的主要实现者有ClassPathXmlApplicationContext，FileSystemXmlApplicationContext等</li>
<li>ApplicationContext提供了更多面向实际应用的功能<ul>
<li>国际化消息访问功能</li>
<li>统一的资源读取方式</li>
<li>能够发布事件，并允许注册相应的事件监听器；</li>
</ul>
</li>
</ol>
<h1 id="FactoryBean和BeanFactory"><a href="#FactoryBean和BeanFactory" class="headerlink" title="FactoryBean和BeanFactory"></a>FactoryBean和BeanFactory</h1><ol>
<li>FactoryBean，顾名思义，工厂Bean（像工厂一样的Bean）,是一个能产生或者修饰对象的Bean，可以在ioc容器中被管理,用户通过实现FacatoryBean接口定制实例化Bean的逻辑,使用“&amp;”前缀，获取FactoryBean产生的对象（getObject方法）；</li>
<li>BeanFactory，ioc容器，对Bean进行管理；</li>
</ol>
<h1 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h1><ol>
<li>singleton 仅存在一个Bean实例</li>
<li>prototype 每次调用Bean时，都返回一个新实例</li>
<li>request 每次http请求，创建一个新的Bean</li>
<li>session 同一个Http Session，共享一个Bean</li>
<li>globalSession global-session和Portlet应用相关；</li>
</ol>
<h1 id="Spring内部Bean"><a href="#Spring内部Bean" class="headerlink" title="Spring内部Bean"></a>Spring内部Bean</h1><ol>
<li>内部bean和Java匿名内部类相似，仅仅被某一个bean调用</li>
</ol>
<h1 id="基于注解配置，说说所知道的注解"><a href="#基于注解配置，说说所知道的注解" class="headerlink" title="基于注解配置，说说所知道的注解"></a>基于注解配置，说说所知道的注解</h1><ol>
<li>@Component注解，定义Bean； 对应的在分层结构中，DAO层，@Repository；Service层：@Service； Web层：@Controller</li>
<li>@Autowired注解，自动装配（required= false），@Lazy注解，延迟注入</li>
<li>@Configuration注解，基于Java类配置；@Bean注解； </li>
<li>Spring MVC注解，@RequestMapping</li>
<li>Spring Cache, @Cacheable注解</li>
</ol>
<h1 id="Spring的单例Bean是线程安全的吗"><a href="#Spring的单例Bean是线程安全的吗" class="headerlink" title="Spring的单例Bean是线程安全的吗"></a>Spring的单例Bean是线程安全的吗</h1><ol>
<li>并没有对单例bean进行任何多线程的封装处理；自行去保证线程安全</li>
</ol>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="Spring-MVC过程"><a href="#Spring-MVC过程" class="headerlink" title="Spring MVC过程"></a>Spring MVC过程</h2><ol>
<li>DispatcherServlet接收请求</li>
<li>HanddlerMappig来寻找对应的处理器(Controller)</li>
<li>DispatcherServlet根据查找到的处理器，通过HandlerAdapter处理器适配器，调用处理器的方法，</li>
<li>处理器完成业务逻辑后，返回ModelAndView</li>
<li>DispatcherServlet调用试图解析器解析视图，视图渲染，得到最后的页面</li>
<li>返回。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式7-策略模式]]></title>
      <url>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h1 id="策略模式在Spring中的使用"><a href="#策略模式在Spring中的使用" class="headerlink" title="策略模式在Spring中的使用"></a>策略模式在Spring中的使用</h1><ul>
<li>Resource与ResourceLoader配合使用,来访问资源，读取配置文件信息等。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程7-Future与Callable,FutureTask]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B7-Future%E4%B8%8ECallable-FutureTask.html</url>
      <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.csdn.net/ghsau/article/details/7451464" target="_blank" rel="external">Java线程(七)：Callable和Future|csdn博客</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程7-线程池]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B9-%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
      <content type="html"><![CDATA[<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p><img src="../images/threadpool.png" alt=""></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><ul>
<li>线程池核心代码<br><img src="../images/线程池源码.png" alt=""></li>
</ul>
<ul>
<li>工作线程<ul>
<li>工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，<strong>还会循环获取工作队列里的任务来执行</strong><br><img src="../images/多线程worker.png" alt=""></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程8-信号量]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8-%E4%BF%A1%E5%8F%B7%E9%87%8F.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程6-阻塞队列]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html</url>
      <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.importnew.com/6695.html" target="_blank" rel="external">阻塞队列实现生产者消费者模式</a></li>
<li><a href="http://www.cnblogs.com/yzlpersonal/p/5231649.html" target="_blank" rel="external">生产者-消费者 用非阻塞队列、Object.wait()、Object.notify()实现</a></li>
<li><a href="http://www.chongchonggou.com/g_645129056.html" target="_blank" rel="external">高并发:阻塞队列 实现生产者-消费者模式</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程5-设计线程安全的类]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B5-%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程4-ThreadLocal]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-ThreadLocal.html</url>
      <content type="html"><![CDATA[<h1 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h1><ol>
<li>线程局部变量</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="http://blog.zhangjikai.com/2017/03/29/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-ThreadLocal/" target="_blank" rel="external">ThreadLocal详解</a></p>
</li>
<li><p>ThreadLocal(线程变量副本)</p>
<ul>
<li>Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。</li>
<li>采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。</li>
<li>ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。</li>
<li>ThreadLocal在spring中发挥着巨大的作用，在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影。</li>
<li>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程1-线程安全概述]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.html</url>
      <content type="html"><![CDATA[<h1 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h1><h2 id="线程安全类："><a href="#线程安全类：" class="headerlink" title="线程安全类："></a>线程安全类：</h2><ul>
<li>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么久称这个类是线程安全的</li>
<li>在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程3-Java内存模型]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</url>
      <content type="html"><![CDATA[<h1 id="Java内存模型参考"><a href="#Java内存模型参考" class="headerlink" title="Java内存模型参考"></a>Java内存模型参考</h1><ol>
<li><a href="http://ifeve.com/java-memory-model-6/" target="_blank" rel="external">Java内存模型|讲的非常详细</a></li>
</ol>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="两个关键方面"><a href="#两个关键方面" class="headerlink" title="两个关键方面"></a>两个关键方面</h2><ol>
<li>可见性 Memory Visibility</li>
<li>竞态条件（Race Condition）</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ol>
<li>可见性： assign store </li>
<li>防止指令重排</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人计划至8.5]]></title>
      <url>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B37%E6%9C%88%E5%BA%95.html</url>
      <content type="html"><![CDATA[<h1 id="总体：Spring-JVM，多线程"><a href="#总体：Spring-JVM，多线程" class="headerlink" title="总体：Spring,JVM，多线程"></a>总体：Spring,JVM，多线程</h1><h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><ol>
<li>《深入理解Java虚拟机》</li>
<li>《Java并发编程实战》</li>
<li>《精通Spring4.x 企业应用开发实战》</li>
<li>《Java多线程编程核心技术》</li>
</ol>
<h2 id="核心提升"><a href="#核心提升" class="headerlink" title="核心提升"></a>核心提升</h2><ol>
<li>Java并发编程学习 </li>
<li>Quartz</li>
<li>消息中间件知识，KafKa复习</li>
</ol>
<h1 id="每日计划"><a href="#每日计划" class="headerlink" title="每日计划"></a>每日计划</h1><pre><code>- 阶段1到阶段6（8.3号），每日一个编程真题（公司笔试真题）
- 阶段7开始，每日刷公司真题和编程题，自由复习阶段，查漏补缺
</code></pre><h2 id="阶段一：Spring复习巩固，完成小项目一个7天"><a href="#阶段一：Spring复习巩固，完成小项目一个7天" class="headerlink" title="阶段一：Spring复习巩固，完成小项目一个7天"></a>阶段一：Spring复习巩固，完成小项目一个7天</h2><ol>
<li><p>7.14看书</p>
<ul>
<li>《Spring4.x》7.8.9三章看完（Spring aop内容），结合18论坛项目的代码</li>
</ul>
</li>
<li><p>7.15总结</p>
<ul>
<li>总结Spirng ioc、aop、事物</li>
<li>自己实现简单ioc与aop，研究ioc与aop的源码(结合深入解析那本书)</li>
</ul>
</li>
<li><p>7.16看书</p>
<ul>
<li>《Spring4.x》10.11.12.13.14 Spring数据篇</li>
</ul>
</li>
<li><p>7.17看书</p>
<ul>
<li>《Spring4.x》15 Spring缓存，memchched与redis复习</li>
</ul>
</li>
<li><p>7.18总结</p>
<ul>
<li>总结Spirng数据库操作，Hibernate与Mybatis相关，缓存相关，数据库常见问题</li>
</ul>
</li>
<li><p>7.19看书</p>
<ul>
<li>《Spring4.x》17 SpringMvc复习总结完毕，结合18论坛代码，写完跑通</li>
</ul>
</li>
<li><p>7.20总结</p>
<ul>
<li>Spring mvc总结</li>
<li><strong>Spring面经总结，项目中的Spring遇到的问题及解决方法：包括Spirng ioc,aop,事物，数据库，spring mvc,spring boot</strong></li>
</ul>
</li>
</ol>
<h2 id="阶段二：多线程复习巩固5天"><a href="#阶段二：多线程复习巩固5天" class="headerlink" title="阶段二：多线程复习巩固5天"></a>阶段二：多线程复习巩固5天</h2><ol>
<li><p>7.21看书</p>
<ul>
<li>《Java多线程编程核心技术》1-3章</li>
</ul>
</li>
<li><p>7.22看书</p>
<ul>
<li>《Java多线程编程核心技术》4-6章</li>
</ul>
</li>
<li><p>7.23看书</p>
<ul>
<li>《Spring4.x》16 Spirng任务调度，exectue框架  Quatrz复习</li>
</ul>
</li>
<li><p>7.24看书</p>
<ul>
<li>Quatrz学习总结</li>
</ul>
</li>
<li><p>7.25 </p>
<ul>
<li><strong>多线程面试总结</strong></li>
<li><strong>整理项目中遇到的多线程问题，及解决方法</strong></li>
</ul>
</li>
</ol>
<h2 id="阶段三-消息中间件突击复习，kafka学习4天"><a href="#阶段三-消息中间件突击复习，kafka学习4天" class="headerlink" title="阶段三: 消息中间件突击复习，kafka学习4天"></a>阶段三: 消息中间件突击复习，kafka学习4天</h2><ol>
<li>7.26</li>
<li>7.27</li>
<li>7.28</li>
<li>7.29</li>
</ol>
<h2 id="阶段四：JVM复习总结3天"><a href="#阶段四：JVM复习总结3天" class="headerlink" title="阶段四：JVM复习总结3天"></a>阶段四：JVM复习总结3天</h2><ol>
<li><p>7.30看书</p>
<ul>
<li>JVM书</li>
</ul>
</li>
<li><p>7.31看书</p>
<ul>
<li>JVM书</li>
</ul>
</li>
<li><p>8.1总结<br>-JVM面经总结</p>
<ul>
<li><strong>项目中遇到的JVM调优问题及解决方法</strong></li>
</ul>
</li>
</ol>
<h2 id="阶段五：-设计模式总结1天"><a href="#阶段五：-设计模式总结1天" class="headerlink" title="阶段五： 设计模式总结1天"></a>阶段五： 设计模式总结1天</h2><ol>
<li>8.2号<ul>
<li><strong>设计模式常见面试问题总结</strong></li>
<li>手写单例模式准备（多线程情况）</li>
</ul>
</li>
</ol>
<h2 id="阶段六：-Sql基础复习1天"><a href="#阶段六：-Sql基础复习1天" class="headerlink" title="阶段六： Sql基础复习1天"></a>阶段六： Sql基础复习1天</h2><ol>
<li>8.3号<ul>
<li>mysql必知必会</li>
<li>刷Sql题目6+</li>
</ul>
</li>
</ol>
<h2 id="阶段七：刷公司真题，剑指offer及查漏补缺复习"><a href="#阶段七：刷公司真题，剑指offer及查漏补缺复习" class="headerlink" title="阶段七：刷公司真题，剑指offer及查漏补缺复习"></a>阶段七：刷公司真题，剑指offer及查漏补缺复习</h2><ol>
<li><p>8.4号</p>
<ul>
<li>排序算法复习巩固（手写排序算法）</li>
<li>排序的选择题巩固</li>
</ul>
</li>
<li><p>8.5号</p>
<ul>
<li>公司真题之阿里</li>
</ul>
</li>
<li><p>8.</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程2-Java多线程基础]]></title>
      <url>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</url>
      <content type="html"><![CDATA[<h1 id="多线程与并发参考资料"><a href="#多线程与并发参考资料" class="headerlink" title="多线程与并发参考资料"></a>多线程与并发参考资料</h1><ol>
<li><a href="http://ifeve.com/java-concurrency-thread-directory/" target="_blank" rel="external">Java并发性和多线程</a></li>
</ol>
<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="管理线程的几种方法"><a href="#管理线程的几种方法" class="headerlink" title="管理线程的几种方法"></a>管理线程的几种方法</h2><p><img src="../images/管理线程的几种方法.png" alt=""></p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ol>
<li>实现Runnable接口</li>
<li>继承Thread类</li>
<li>都通过start方法，启动线程。优先runnable接口，可实现多个接口</li>
</ol>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ol>
<li>每一个对象都隐含着一个锁对象，这个锁对象就是用来解决并发问题的互斥量（mutex）。要调用一个对象的synchronized方法的线程，必须持有这个对象的锁对象，在执行完毕之后，必须释放这个锁对象，以让别的线程得到这个锁对象。</li>
<li><a href="http://ifeve.com/synchronized-blocks/" target="_blank" rel="external">同步</a></li>
</ol>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ul>
<li>以下三个方法，仅在synchronized方法中可以调用</li>
<li>wait,告知被调用的线程，放弃锁，直到其他线程进入并调用notify唤醒</li>
<li>notify</li>
<li>notifyAll</li>
<li><a href="http://ifeve.com/thread-signaling/#wait_notify" target="_blank" rel="external">notify|wait详解</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM-程序编译与代码优化]]></title>
      <url>http://liuhang.net.cn/JVM-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html</url>
      <content type="html"><![CDATA[<h1 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h1><h2 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h2><h2 id="自动拆箱与装箱"><a href="#自动拆箱与装箱" class="headerlink" title="自动拆箱与装箱"></a>自动拆箱与装箱</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM-Java内存区域与内存溢出异常]]></title>
      <url>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html</url>
      <content type="html"><![CDATA[<h1 id="内存空间（运行时数据区）"><a href="#内存空间（运行时数据区）" class="headerlink" title="内存空间（运行时数据区）"></a>内存空间（运行时数据区）</h1><p><img src="../images/jvmneicun.png" alt=""> </p>
<ol>
<li>程序计数器： 线程私有；看作当前线程所执行的字节码的行号指示器</li>
<li>虚拟机栈： 线程私有；（即常说的堆内存和栈内存中的栈），栈帧结构，存储局部变量表，操作数等</li>
<li>本地方法栈： 虚拟机使用到的native方法</li>
<li>Java堆，<strong>线程共享</strong>，所有的对象实例和数组在堆上分配内存。垃圾回收的主要区域。</li>
<li>方法区： 各<strong>线程共享</strong>，存储已经被虚拟机加载的类信息、常量、静态变量等。运行时常量池是方法区的一部分。</li>
</ol>
<h1 id="虚拟机参数"><a href="#虚拟机参数" class="headerlink" title="虚拟机参数"></a>虚拟机参数</h1><ol>
<li>JVM启动参数分为三类：<ul>
<li>标准参数(-):所有的JVM实现都必须实现这些参数的功能，而且向后兼容; 命令行 java -? 查看参数</li>
<li>非标准参数(-X):默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容；命令行 java -X 查看参数</li>
<li>非稳定参数(-XX):此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用；</li>
</ul>
</li>
<li>常用参数设置<ul>
<li>最大堆和初始堆<code>-Xms</code>初始堆内存大小，<code>-Xmx</code>最大堆内存大小</li>
<li>新生代配置<code>-Xmn</code>新生代内存大小，<code>-XX:SurvivorRatio</code>设置新生代eden空间和from/to空间比例；<code>-XX:NewRatio</code>老年代和新生代比例</li>
<li>系统参数查看：<code>-XX:+PrintVMOptions</code>打印虚拟机接收到的显示参数</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM-线程安全与锁优化]]></title>
      <url>http://liuhang.net.cn/JVM-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM-Java内存模型与线程]]></title>
      <url>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb基础-Session与Cookie]]></title>
      <url>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-Session%E4%B8%8ECookie.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb基础-JDBC]]></title>
      <url>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-JDBC.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb基础-servlet]]></title>
      <url>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-servlet.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础增强-Lambda 表达式]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="external">深入浅出 Java 8 Lambda 表达式</a></li>
</ol>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="语法糖的概念"><a href="#语法糖的概念" class="headerlink" title="语法糖的概念"></a>语法糖的概念</h2><ul>
<li>指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础算法-迪杰斯特拉算法]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h1 id="Dijkstra算法详细介绍"><a href="#Dijkstra算法详细介绍" class="headerlink" title="Dijkstra算法详细介绍"></a>Dijkstra算法详细介绍</h1><ol>
<li>参考：<a href="http://www.it165.net/pro/html/201407/16957.html" target="_blank" rel="external">图算法单源最短路径Dijkstra算法</a></li>
</ol>
<h1 id="Dijkstra算法优化"><a href="#Dijkstra算法优化" class="headerlink" title="Dijkstra算法优化"></a>Dijkstra算法优化</h1><ol>
<li>参考：<a href="http://blog.leanote.com/post/coolboy/duiyouhu" target="_blank" rel="external">带堆优化的Dijkstra</a></li>
</ol>
<h1 id="Dijkstra实现（java）"><a href="#Dijkstra实现（java）" class="headerlink" title="Dijkstra实现（java）"></a>Dijkstra实现（java）</h1><ol>
<li><a href="https://github.com/husthang/zte2017/blob/master/tsp/code/src/main/java/route/Dijkstra.java" target="_blank" rel="external">我的实现|java|邻接表</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2017中兴捧月杯-初赛总结]]></title>
      <url>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%88%9D%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="赛题描述"><a href="#赛题描述" class="headerlink" title="赛题描述"></a>赛题描述</h1><ol>
<li>赛题链接：<a href="http://challenge.zte.net/index.php" target="_blank" rel="external">迪杰斯特拉派赛题</a></li>
<li>赛题抽象，给定一个无向图G，已知起点s、终点e、必经点集R、必经边集B、禁忌边集F和访问节点数限制k，要求寻找一条从起点s到终点e的最短路径，同时满足以下几个限制条件：（1）不能经过禁忌边集F中的任意边（2）必须经过必经点R集中的所有顶点（3）必须经过必经边集B中的所有边（4）路径访问的节点数量不超过k。</li>
<li>赛题说明文档</li>
</ol>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><a href="http://liuhang.net.cn/paper.pdf">paper|版权归中兴公司所有</a></li>
<li><a href="https://github.com/husthang/zte2017" target="_blank" rel="external">代码|版权归中兴公司所有</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2017中兴捧月杯-决赛总结]]></title>
      <url>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%86%B3%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="向量装箱问题"><a href="#向量装箱问题" class="headerlink" title="向量装箱问题"></a>向量装箱问题</h1><h2 id="装箱问题介绍"><a href="#装箱问题介绍" class="headerlink" title="装箱问题介绍"></a>装箱问题介绍</h2><ol>
<li><a href="https://people.math.gatech.edu/~tetali/PUBLIS/CKPT.pdf" target="_blank" rel="external">对装箱问题的详细介绍|Multidimensional Bin Packing and Other Related Problems: A Survey ∗</a></li>
<li><a href="http://www.or.deis.unibo.it/knapsack.html" target="_blank" rel="external">背包问题及装箱问题|各种算法及详细介绍</a></li>
<li><a href="http://vpsolver.dcc.fc.up.pt/" target="_blank" rel="external">向量装箱问题求解器</a>，这个是针对多维向量装箱问题的求解器，功能非常强大。</li>
</ol>
<h2 id="二维向量装箱问题"><a href="#二维向量装箱问题" class="headerlink" title="二维向量装箱问题"></a>二维向量装箱问题</h2><ol>
<li>参考一：A BRANCH-AND-BOUND ALGORITHM FOR THE TWO-DIMENSIONAL VECTOR PACKING PROBLEM</li>
<li>参考二：<a href="http://www.or.deis.unibo.it/kp/Chapter8.pdf" target="_blank" rel="external">Knapsack Problems|Chapter8,bin packing problems</a></li>
<li><a href="https://github.com/husthang/zte2017" target="_blank" rel="external">二维向量装箱问题代码|包含基本的FFD|包含分支定界精确求解方法</a></li>
</ol>
<h1 id="网络优化问题"><a href="#网络优化问题" class="headerlink" title="网络优化问题"></a>网络优化问题</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础算法-贪心法]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h1 id="贪心思想概念"><a href="#贪心思想概念" class="headerlink" title="贪心思想概念"></a>贪心思想概念</h1><ol>
<li>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</li>
</ol>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="../images/贪心法.png" alt=""></p>
<ol>
<li>落单的数<ul>
<li><a href="http://www.lintcode.com/zh-cn/problem/single-number/" target="_blank" rel="external">落单的数</a></li>
<li>思路：按位或运算</li>
</ul>
</li>
<li>主元素</li>
<li><p>加油站</p>
<ul>
<li><a href="http://www.lintcode.com/zh-cn/problem/gas-station/#" target="_blank" rel="external">加油站</a></li>
<li>思路： 只要汽油量大于等于总的消耗，那么肯定有解。排除汽油量小于消耗量的点即可。</li>
</ul>
</li>
<li><p>下一个排列（难）</p>
<ul>
<li><a href="http://www.lintcode.com/zh-cn/problem/next-permutation/#" target="_blank" rel="external">下一个排列|lintcode</a></li>
<li><p>思路： 从后往前，先找到按字典排序，将要交换位置的点；再找该位置下一个排列应该是什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextPermutation(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> len = nums.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;<span class="number">0</span>; i--)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>])&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len-<span class="number">1</span>; j&gt;=i;j--)&#123;</div><div class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i-<span class="number">1</span>])&#123;</div><div class="line">                    <span class="keyword">int</span> temp = nums[j];</div><div class="line">                    nums[j] = nums[i-<span class="number">1</span>];</div><div class="line">                    nums[i-<span class="number">1</span>]=temp;</div><div class="line">                    Arrays.sort(nums,i,len);</div><div class="line">                    <span class="keyword">return</span> nums;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">     Arrays.sort(nums);</div><div class="line">     <span class="keyword">return</span> nums;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础算法-数学和位操作]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E5%92%8C%E4%BD%8D%E6%93%8D%E4%BD%9C.html</url>
      <content type="html"><![CDATA[<h2 id="最大公约数-最小公倍数"><a href="#最大公约数-最小公倍数" class="headerlink" title="最大公约数/最小公倍数"></a>最大公约数/最小公倍数</h2><ul>
<li>最大公约数:greatest common divisor</li>
<li>欧几里得法(辗转相除法):设<code>a&gt;b</code>,<code>a=b*p+q</code>,b与q的最大公约也就是a与b的最大公约数,直到q为0,直接返回;</li>
<li>最小公倍数:lowest common multiple; <code>lcm(a,b)*gcd(a,b)=a*b</code>;</li>
<li>求两个数或n个数的最小公倍数或最大公约数:<br><img src="../images/gcd.png" alt=""></li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><ul>
<li>素数: 只有1和本身两个约数;判断是否为素数,只需要对前根号n个数进行判断<br><img src="../images/prime.png" alt=""></li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位操作有按位与、或、非、左移n位和右移n位等操作。</p>
<ol>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1): 可以把最右边的一个1变成0;</li>
<li>常见位操作：获取，设置，清除及更新位操作<br><img src="../images/位-获取.png" alt=""><br><img src="../images/位-更新.png" alt=""><br><img src="../images/位-清零.png" alt=""></li>
</ol>
<h3 id="二进制中的1的个数"><a href="#二进制中的1的个数" class="headerlink" title="二进制中的1的个数"></a>二进制中的1的个数</h3><ul>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1)</li>
</ul>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><ul>
<li>卡特兰数递推关系:<img src="../images/卡特兰.png" alt=""></li>
<li>卡特兰数通项式:<img src="../images/catalan.png" alt=""><img src="../images/catalan1.png" alt=""></li>
<li>前几项为1，1，2，5，14，42…</li>
<li>应用:<ul>
<li>栈的出栈序列:1到n的序列,依次进栈,有多少种不同的出栈序列；根据乘法原理和加法原理，设最后一个出栈的元素为k，则该情况为f(k-1)f(n-k)，所以递推关系满足；<code>f(n) = f(n-1)f(0) + f(n-2)f(1) + f(n-3)f(2) + ... + f(1)f(n-2) + f(0)f(n-1)</code></li>
<li>不同的二叉查找树： <a href="http://www.lintcode.com/zh-cn/problem/unique-binary-search-trees/" target="_blank" rel="external">lintcode|不同二叉查找树</a>；<code>f(n) = f(n-1)f(0) + f(n-2)f(1) + f(n-3)f(2) + ... + f(1)f(n-2) + f(0)f(n-1)</code></li>
</ul>
</li>
</ul>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><h2 id="全排列和全组合"><a href="#全排列和全组合" class="headerlink" title="全排列和全组合"></a>全排列和全组合</h2><ul>
<li>思路: 从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理；</li>
<li>参考:<a href="https://segmentfault.com/a/1190000002710424" target="_blank" rel="external">全排列/全组合</a></li>
</ul>
<h2 id="lintCode阶梯训练"><a href="#lintCode阶梯训练" class="headerlink" title="lintCode阶梯训练"></a>lintCode阶梯训练</h2><ul>
<li><a href="http://www.lintcode.com/zh-cn/ladder/" target="_blank" rel="external">lintcode阶梯训练|数学与二进制运算</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统总结]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><ol>
<li>基本概念：管理计算机硬件和软件资源，方便用户使用计算机的程序集合；</li>
<li>操作系统提供的服务和功能：<ul>
<li>提供用户的<ul>
<li>用户界面</li>
<li>程序执行</li>
<li>I/O操作</li>
<li>文件系统操作</li>
<li>通信</li>
<li>错误检测</li>
</ul>
</li>
</ul>
</li>
<li>计算机系统<br><img src="../images/计算机要素.png" alt=""></li>
</ol>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><ol>
<li>进程的概念： 进程是具有一定独立功能的程序关于某个数据集合的一次运行活动。进程是程序的执行，动态概念，一次运行过程，有生命过程。</li>
<li>进程控制块（process control block, PCB）:记录进程的属性信息，进程标识信息，处理器状态信息，进程控制信息</li>
<li>进程间通信的两种基本模式： 1）共享内存， 2）消息传递<br><img src="../images/进程通信模型.png" alt="进程通信模型"></li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ol>
<li>多处理器系统带来的物理并行称为<strong>并行性</strong>，用编程技术达到的虚拟并行性，称为并发性</li>
<li>线程是CPU调度的基本单元，由线程ID,程序计数器，寄存器集合，栈组成。</li>
</ol>
<h1 id="互斥和同步"><a href="#互斥和同步" class="headerlink" title="互斥和同步"></a>互斥和同步</h1><ol>
<li>互斥（对资源的独用），同步（进程/线程之间的通信）</li>
<li>生产者和消费者问题：有限缓冲问题，用于多线程同步；多生产者消费者算法：用二元信号量保证互斥<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">semaphore mutex = 1;//二元信号量</div><div class="line">semaphore fillCount = 0;// 满缓存信号量</div><div class="line">semaphore emptyCount = BUFFER_SIZE;//空缓存信号量</div><div class="line"></div><div class="line"></div><div class="line">procedure producer() &#123;</div><div class="line">    while (true) &#123;</div><div class="line">        item = produceItem();//生产者生产数据</div><div class="line">        down(emptyCount);</div><div class="line">            down(mutex);//互斥，申请使用权</div><div class="line">                putItemIntoBuffer(item);//将数据放入缓存区</div><div class="line">            up(mutex);//释放使用权</div><div class="line">        up(fillCount);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">procedure consumer() &#123;</div><div class="line">    while (true) &#123;</div><div class="line">        down(fillCount);</div><div class="line">            down(mutex);</div><div class="line">                item = removeItemFromBuffer();//从缓存区中读取数据</div><div class="line">            up(mutex);</div><div class="line">        up(emptyCount);</div><div class="line">        consumeItem(item);//消费者使用数据</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="external">参考</a></li>
</ul>
<h1 id="进程调用"><a href="#进程调用" class="headerlink" title="进程调用"></a>进程调用</h1><h1 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h1><ol>
<li>先进先出调度算法（不可抢占）：按进入顺序执行</li>
<li>最短进程优先调度（事先知道要运行的时间）<ul>
<li>非抢占式</li>
<li>抢占式（最短剩余时间优先调度）</li>
</ul>
</li>
<li>时间片轮转法：每个进程轮流使用一段时间</li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul>
<li>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进</li>
</ul>
<ol>
<li><p>产生死锁的原因 </p>
<ul>
<li><strong>竞争资源引起死锁</strong><ul>
<li>在多道程序系统，多个进程共享系统的资源。系统资源分为二类:<br>一类是不可抢占的资源，如打印机、磁带机等。当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自动释放。<br>另一类是可抢占的资源，如CPU、内存等。由于系统拥有的不可抢占的资源有限，多个进程共享竞争不可抢占的资源就可能引起死锁。</li>
</ul>
</li>
<li><strong>进程推进顺序不当引起死锁</strong><ul>
<li>在多道程序系统中，并发执行的进程推进序列不可予测，有些推进顺序，进程可以顺利完成，这些推进顺序是合法的；而有的推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成了死锁。</li>
</ul>
</li>
</ul>
</li>
<li><p>产生死锁的必要条件</p>
<ul>
<li>互斥（ Mutual exclusion ）条件：一个资源一次只能被一个进程所使用，即是排它性使用。</li>
<li>不可抢占（ No preemption ）条件：一个资源仅能被占有它的进程所释放，而不能被别的进程强占。</li>
<li>请求和保持（ Hold-and-wait ）条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放。</li>
<li>环路等待（ Circular wait ）条件：当每类资源只有一个时，在发生死锁时，必然存在一个进程-资源的环形链。如一系统状态的资源分配图所示，P1正在等待一个P2 占用的资源R2，P2正在等待一个P1占用的资源R1。</li>
</ul>
</li>
<li><p>死锁的预防</p>
<ul>
<li><strong>预防死锁的方法是破坏四个产生死锁的必要条件之一</strong>。</li>
</ul>
<ol>
<li>破坏互斥条件: 互斥使用是资源本身特征所决定的。使用硬软件结合可改变资源本身特性，例如采用SPOOLing技术可将“独享” 打印机改变为“共享”的打印机。</li>
<li>破坏不可抢占条件:如果一个进程的申请没有实现，它要释放所有占有的资源</li>
<li>破坏请求和保持条件（也叫部分分配条件）: 采用<strong>资源预先静态分配法</strong>，运行前，一次性分配所需要的全部资源</li>
<li>破坏循环等待条件： <strong>有序资源使用法</strong>，对资源编号，进程只能按照编号递增的顺序申请资源。</li>
</ol>
</li>
<li><p>死锁的避免</p>
<ol>
<li>概念： 死锁的预防是严格破坏四个必要条件之一，死锁避免是方法允许进程动态地申请资源，系统在进行资源分配之前，先计算资源分配的安全性。若安全，则分配。避免死锁：确保系统永远不会进入死锁状态</li>
<li><strong>银行家算法</strong>避免死锁，不足：进程难以预先知道它的最大资源需求</li>
</ol>
</li>
<li><p>死锁的检测和恢复</p>
</li>
</ol>
<h1 id="主存储器管理"><a href="#主存储器管理" class="headerlink" title="主存储器管理"></a>主存储器管理</h1><ol>
<li>页式存储管理</li>
<li>段式存储管理</li>
<li>页的置换算法<ul>
<li>最佳置换算法</li>
<li>最佳未使用置换算法(NUR)</li>
<li>先进先出</li>
<li>最近最少使用置换算法（LRU）</li>
</ul>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://jpkc.scezju.com/czxtyl/redir.php?catalog_id=109249" target="_blank" rel="external">操作系统ppt</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络总结]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层模型与TCP-IP四层模型"><a href="#OSI七层模型与TCP-IP四层模型" class="headerlink" title="OSI七层模型与TCP/IP四层模型"></a>OSI七层模型与TCP/IP四层模型</h2><p><img src="../images/osi七层模型.gif" alt=""></p>
<ul>
<li>实际应用的tcp/ip四层: 连接层,网络层,传输层,应用层</li>
<li>各层的作用<ol>
<li>物理层：通过媒介传输比特,确定机械及电气规范</li>
<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ol>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="../images/ip.png" alt=""><br><img src="../images/ip1.png" alt=""></p>
<ul>
<li>A类地址,<ul>
<li>可指派的网络号126个(2^7-2),见2的原因是: 网络号全0为保留地址,表示本网络;网络号127(0111 1111)保留为回环测试(如127.0.0.1)</li>
<li>可指派的主机号: 2^24-2; 减去全0的主机号,减去全1主机号</li>
</ul>
</li>
<li>B类地址<ul>
<li>可指派网络号2^14-1:128.0不指派,最小可指派的网络号是128.1</li>
<li>主机号减2,2^16-2;</li>
</ul>
</li>
<li>C类地址<ul>
<li>可指派网络号2^21-1:192.0.0不指派,最小可指派的网络号192.0.1</li>
<li>主机号减2: 2^8-2;</li>
</ul>
</li>
</ul>
<h2 id="TCP-UDP协议"><a href="#TCP-UDP协议" class="headerlink" title="TCP/UDP协议"></a>TCP/UDP协议</h2><ul>
<li>运输层协议和网络层协议的主要区别<br><img src="../images/运输层网络层.png" alt=""></li>
<li><p>运输层的协议端口号</p>
<ul>
<li>协议端口号(protocol port number),简称端口;使不同的操作系统中的进程可以相互通信,用统一的方法对TCP/IP体系中的应用进程进行标识;16位的端口号(65535个)</li>
<li>通信的终点是应用进程,但我们只需把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成</li>
</ul>
</li>
<li><p>tcp字段含义<br><img src="../images/tcp字段.png" alt=""></p>
</li>
<li><p>传输层定义两种传输协议：TCP（传输控制协议）和 UDP（或用户数据报协议）<br><img src="../images/tcp-udp.png" alt=""></p>
</li>
<li>TCP协议和UDP协议特性区别总结：<ol>
<li>TCP协议在传送数据段的时候要给段标号；UDP协议不</li>
<li>TCP协议可靠；UDP协议不可靠</li>
<li>TCP协议是面向连接；UDP协议采用无连接</li>
<li>TCP协议负载较高，采用虚电路；UDP采用无连接</li>
<li>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</li>
<li>TCP协议采用窗口技术和流控制</li>
</ol>
</li>
</ul>
<h2 id="TCP三次握手与四次分手"><a href="#TCP三次握手与四次分手" class="headerlink" title="TCP三次握手与四次分手"></a>TCP三次握手与四次分手</h2><p><img src="../images/tcp.jpg" alt=""></p>
<ol>
<li>三次握手和四次分手的过程</li>
<li>为什么要三次握手和四次分手</li>
<li>参考:<a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>http状态码<br><img src="../images/http状态码.png" alt=""><ul>
<li>404  未找到，服务器找不到所请求的网页。</li>
<li>302  临时移动，服务器从不同位置的网页响应请求，请求者应继续使用原有位置进行以后的请求。</li>
<li>500  （服务器内部错误），服务器遇到错误，无法完成请求。</li>
<li>403  （禁止）服务器拒绝请求</li>
</ul>
</li>
<li>http与https区别<ul>
<li>http协议</li>
<li>简单理解: https是安全版的http,</li>
<li>HTTP的端口号是80，https的端口号是443</li>
</ul>
</li>
</ul>
<h2 id="SNMP简单网络管理协议"><a href="#SNMP简单网络管理协议" class="headerlink" title="SNMP简单网络管理协议"></a>SNMP简单网络管理协议</h2><ul>
<li>simple network management protocol 简单网络管理协议</li>
<li>是一个网络管理员用来管理的工具相当于  一个app 所以是<strong>应用层</strong></li>
</ul>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul>
<li>Internet Control Message Protocol 互联网控制消息协议</li>
<li>网络层协议</li>
<li>用ping命令,检查一台主机的网络层是否连通;</li>
</ul>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ul>
<li>IEEE 802.3—CSMA/CD网络，定义CSMA/CD总线网的MAC子层和物理层的规范,人们习惯将<strong>IEEE 802.3称为”以太网</strong>;</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础数据结构-字符串和数组]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84.html</url>
      <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>重难点是: <strong>模式匹配(kmp算法)</strong>和<strong>正则表达式匹配</strong>; 在选择题中,可能会出现问next数组的题目</p>
<h2 id="Java字符串API"><a href="#Java字符串API" class="headerlink" title="Java字符串API"></a>Java字符串API</h2><ul>
<li>toCharArray();</li>
<li><strong>StringBuilder</strong>常用,线程不安全,效率高; StringBuffer  线程安全,效率低;</li>
<li>matches()字符串是否匹配给定的正则表达式。</li>
<li>indexOf()返回指定子字符串在此字符串中第一次出现处的索引。(模式匹配api)</li>
<li>trim()返回字符串的副本，忽略前导空白和尾部空白。</li>
<li>valueOf()返回…字符串形式</li>
<li>split()按给定的正则表达式拆分字符串</li>
<li>replace/replaceAll/replaceFirst 替换字符串</li>
<li>reverse() 逆序</li>
</ul>
<h2 id="String对象经典问题"><a href="#String对象经典问题" class="headerlink" title="String对象经典问题"></a>String对象经典问题</h2><ul>
<li><a href="http://sarin.iteye.com/blog/603684" target="_blank" rel="external">参考</a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"abc"</span>;</div><div class="line">String str1 = <span class="string">"abc"</span>;</div><div class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</div><div class="line">System.out.println(str == str1);<span class="comment">//true</span></div><div class="line">System.out.println(str1 == <span class="string">"abc"</span>);<span class="comment">//true</span></div><div class="line">System.out.println(str2 == <span class="string">"abc"</span>);<span class="comment">//false</span></div><div class="line">System.out.println(str1 == str2);<span class="comment">//fasle</span></div><div class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></div><div class="line">System.out.println(str1 == str2.intern());<span class="comment">//true</span></div><div class="line">System.out.println(str2 == str2.intern());<span class="comment">//false</span></div><div class="line">System.out.println(str1.hashCode() == str2.hashCode());<span class="comment">//true equals相同,hashcode必然相同</span></div><div class="line">System.out.println(str + <span class="string">"d"</span> == str1 + <span class="string">"d"</span>);<span class="comment">//false 用+连接是在堆内存上进行, 得到两个新对象</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul>
<li>定义:s和t为给定的两个字符串,在主串s中查找子串t的过程称为模式匹配,返回t在s中第一次出现的位置</li>
<li>OJ题目:<a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">LeetCode|字符串匹配,子串第一次出现的位置</a></li>
<li>三种方法:<ol>
<li>java api: indexOf;</li>
<li>暴力搜</li>
<li>KMP算法</li>
</ol>
</li>
<li>kmp算法选择题:next数组<ul>
<li><a href="https://www.nowcoder.com/questionTerminal/57bdf294407c4477969fc7b4d56c7be7" target="_blank" rel="external">next数组</a></li>
</ul>
</li>
<li>求next数组的方法（递归法）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String source, String pattern)</span></span>&#123;</div><div class="line">       <span class="keyword">char</span>[] src = source.toCharArray();</div><div class="line">       <span class="keyword">char</span>[] pat = pattern.toCharArray();</div><div class="line">       <span class="keyword">int</span>[] next = getNext(pat);</div><div class="line">       <span class="keyword">int</span> sLen = src.length;</div><div class="line">       <span class="keyword">int</span> pLen = pat.length;</div><div class="line">       <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</div><div class="line">           <span class="keyword">if</span>(j== -<span class="number">1</span> || src[i] == pat[j])&#123;</div><div class="line">               i++;</div><div class="line">               j++;</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               j = next[j];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span>(j == pLen)&#123;</div><div class="line">           <span class="keyword">return</span> i - pLen;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] p)&#123;</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 求next数组的方法</div><div class="line">        * 已知next[j]=k,求next[j+1];</div><div class="line">        * 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1;</div><div class="line">        * 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1,</div><div class="line">        *    如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止</div><div class="line">        */</div><div class="line">       <span class="keyword">int</span> pLen = p.length;</div><div class="line">       <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</div><div class="line">       next[<span class="number">0</span>] = -<span class="number">1</span>;</div><div class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> k = -<span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span>(j &lt; pLen-<span class="number">1</span>)&#123;</div><div class="line">           <span class="keyword">if</span>(k == -<span class="number">1</span> || p[k] == p[j])&#123;</div><div class="line">               j++;</div><div class="line">               k++;</div><div class="line">               next[j] = k;</div><div class="line">           &#125;<span class="keyword">else</span> &#123;</div><div class="line">               k = next[k];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><ul>
<li>OJ题目:剑指offer第52题,Solution52;</li>
<li><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer|正则表达式匹配</a> ;<a href="https://leetcode.com/problems/regular-expression-matching/#/description" target="_blank" rel="external">LeetCode|正则表达式匹配</a></li>
<li>解题思路<ul>
<li>字符串 正则表达式匹配<ol>
<li>模式中,当前字符的下一个字符不是<code>*</code><ul>
<li>如果当前字符匹配,则字符串和模式串都下移一位</li>
<li>如果当前字符不匹配,则直接返回false</li>
</ul>
</li>
<li>模式中,当前字符的下一个字符是<code>*</code><ul>
<li>如果当前字符不匹配,则<code>*</code>匹配0个前位字符,模式串后移两位(前位字符,<code>*</code>前面的那个字符)</li>
<li>如果当前字符匹配,分两组<ul>
<li><code>*</code>匹配0个前位字符,模式串后移两位</li>
<li><code>*</code>匹配一个或者多个前位字符,字符串后移以为,模式串不变</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="字符串平移-String-shift"><a href="#字符串平移-String-shift" class="headerlink" title="字符串平移(String shift)"></a>字符串平移(String shift)</h2><ul>
<li>题目描述<ul>
<li>我们规定对一个字符串的shift操作如下： shift(“ABCD”, 0) = “ABCD” shift(“ABCD”, 1) = “BCDA” shift(“ABCD”, 2) = “CDAB” 换言之, 我们把最左侧的N个字符剪切下来, 按序附加到了右侧。给定一个长度为n的字符串，我们规定最多可以进行n次向左的循环shift操作。如果shift(string, x) = string (0＜= x ＜n), 我们称其为一次匹配(match)。求在shift过程中出现匹配的次数。</li>
</ul>
</li>
<li>解决： 字符串必为周期字符串，计算出最短周期（用kmp算法中的next数组计算）</li>
</ul>
<h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-substring/" target="_blank" rel="external">最长公共子串</a></li>
<li>思路: 暴力法和<strong>动态规划法</strong>.</li>
</ol>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-subsequence/" target="_blank" rel="external">最长公共子序列</a></li>
<li><p>解决： 用动态规划的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lenA+<span class="number">1</span>][lenB+<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++)&#123;</div><div class="line">                dp[i][j] = (A.charAt(i-<span class="number">1</span>) == B.charAt(j-<span class="number">1</span>))?dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>:Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[lenA][lenB];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>应用（变形），求一个字符串删除几个字符可以变成最长的回文字符串，求原字符串与逆串的最长公共子序列。</p>
</li>
</ol>
<h2 id="字符串与整数-数组的互相转换"><a href="#字符串与整数-数组的互相转换" class="headerlink" title="字符串与整数,数组的互相转换"></a>字符串与整数,数组的互相转换</h2><p>1.</p>
<h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><ul>
<li>StringBuilder.reverse方法;</li>
<li><a href="https://leetcode.com/problems/reverse-words-in-a-string/#/description" target="_blank" rel="external">leetcode|字符串反转</a></li>
</ul>
<h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/adc291e7e79f452c8b59243a5ce68d3a?orderByHotValue=1&amp;page=1&amp;onlyReference=false" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/adc291e7e79f452c8b59243a5ce68d3a?orderByHotValue=1&amp;page=1&amp;onlyReference=false</a><br>来源：牛客网</p>
<p>n = int(raw_input())<br>nums = map(int, raw_input().split())<br>index = sorted(range(len(nums)), key = lambda i: nums[i])<br>count = 1<br>for i in range(1, len(index)):<br>    if index[i] &gt; index[i-1]:<br>        count += 1<br>    else:<br>        break<br>print len(index) - count</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础数据结构-字典树]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91.html</url>
      <content type="html"><![CDATA[<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="external">trie|字典树</a></li>
</ol>
<h1 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h1><ol>
<li>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。（来自今日头条笔试题）</li>
<li>解答<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/5/17.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> n = in.nextInt();</div><div class="line">        <span class="keyword">int</span> m = in.nextInt();</div><div class="line">        TrieNode root = <span class="keyword">new</span> TrieNode(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            array[i] = in.nextInt();</div><div class="line">            insert(root, array[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</div><div class="line">            result += query(root, i, m);</div><div class="line">        &#125;</div><div class="line">        System.out.println(result / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据二进制位，构建字典数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode trieNode, <span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">        TrieNode pre = trieNode;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> digit = (number &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (pre.next[digit] == <span class="keyword">null</span>) &#123;</div><div class="line">                pre.next[digit] = <span class="keyword">new</span> TrieNode(digit);</div><div class="line">            &#125;</div><div class="line">            pre = pre.next[digit];</div><div class="line">            pre.count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(TrieNode root, <span class="keyword">int</span> a, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        TrieNode pre = root;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (mDigit == <span class="number">1</span>) &#123;</div><div class="line">                pre = pre.next[aDigit ^ <span class="number">1</span>];<span class="comment">//此处技巧！ 与aDigit不同 aDigit ^ 1;</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (pre.next[aDigit ^ <span class="number">1</span>] != <span class="keyword">null</span>) &#123;</div><div class="line">                    result += pre.next[aDigit ^ <span class="number">1</span>].count;</div><div class="line">                &#125;</div><div class="line">                pre = pre.next[aDigit];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span>) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    TrieNode[] next = <span class="keyword">new</span> TrieNode[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.digit = digit;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>参考<a href="http://youjq.cn/2017/04/09/2017jin-ri-tou-tiao-bi-shi-ti-yi-huo/" target="_blank" rel="external">2017今日头条笔试题：异或</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySQL/数据库总结]]></title>
      <url>http://liuhang.net.cn/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="MySQL必知必会笔记"><a href="#MySQL必知必会笔记" class="headerlink" title="MySQL必知必会笔记"></a>MySQL必知必会笔记</h1><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><ul>
<li>理解笛卡尔乘积</li>
</ul>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul>
<li>提供对select语句的一层封装</li>
</ul>
<h1 id="经典题目练习"><a href="#经典题目练习" class="headerlink" title="经典题目练习"></a>经典题目练习</h1><h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h2><ol>
<li><a href="https://leetcode.com/problems/duplicate-emails/#/description" target="_blank" rel="external">找出重复的记录|leetcode|重点</a></li>
<li><a href="https://leetcode.com/problems/combine-two-tables/#/description" target="_blank" rel="external">两个表联结查询|leetcode</a></li>
<li><a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/#/description" target="_blank" rel="external">表自联结|leetcode</a></li>
<li><a href="https://leetcode.com/problems/customers-who-never-order/#/description" target="_blank" rel="external">leetcode练习1</a></li>
<li><a href="https://leetcode.com/problems/rising-temperature/#/description" target="_blank" rel="external">leetcode练习2</a></li>
<li><a href="https://leetcode.com/problems/delete-duplicate-emails/#/description" target="_blank" rel="external">删除重复记录，只保留一个）|leetcode|重点</a></li>
<li><a href="https://leetcode.com/problems/second-highest-salary/#/description" target="_blank" rel="external">选择排名第二大的|limit使用|leetcode|重点</a></li>
<li><a href="https://leetcode.com/problems/big-countries/#/description" target="_blank" rel="external">单间检索数据|leetcode</a></li>
</ol>
<h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><ol>
<li><a href="https://leetcode.com/problems/rank-scores/#/description" target="_blank" rel="external">对分数进行排名，并显示名次|leetcode|难</a></li>
<li><a href="https://leetcode.com/problems/consecutive-numbers/#/description" target="_blank" rel="external">选址连续出现的|leetcode</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础算法-日历计算]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%97%A5%E5%8E%86%E8%AE%A1%E7%AE%97.html</url>
      <content type="html"><![CDATA[<h1 id="公历计算"><a href="#公历计算" class="headerlink" title="公历计算"></a>公历计算</h1><h2 id="使用java类库GregorianCalendar"><a href="#使用java类库GregorianCalendar" class="headerlink" title="使用java类库GregorianCalendar"></a>使用java类库GregorianCalendar</h2><h2 id="不使用java类库"><a href="#不使用java类库" class="headerlink" title="不使用java类库"></a>不使用java类库</h2><ol>
<li>参考:<a href="https://github.com/hotoo/nong/wiki/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%81%E4%B8%83%EF%BC%9A%E6%97%A5%E5%8E%86%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95-%E4%B8%AD%E5%9B%BD%E5%85%AC%E5%8E%86%EF%BC%88%E6%A0%BC%E9%87%8C%E5%8E%86%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89" target="_blank" rel="external">日历生成算法</a></li>
<li>公元元年（1年）1.1号星期一，据此计算y年<ul>
<li><code>w=(L*366+N*365+D)%7</code>,前y-1年闰年和平年的年数,D为y年的第几天</li>
<li><code>w=(365(y-1)+L+D)%7</code>,<code>L=(y-1)/4-(y-1)/100+(y-1)/400</code></li>
<li>计算星期几的公式：<code>w=((y-1)+(y-1)/4-(y-1)/100+(y-1)/400+D)%7</code></li>
</ul>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.DateFormatSymbols;</div><div class="line"><span class="keyword">import</span> java.util.Calendar;</div><div class="line"><span class="keyword">import</span> java.util.Locale;</div><div class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 打印指定月份的日历</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//        printCalendar(2017, 5);</span></div><div class="line">        printCalendar1(<span class="number">2017</span>, <span class="number">6</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//使用java类库</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCalendar</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month)</span> </span>&#123;</div><div class="line">        GregorianCalendar d = <span class="keyword">new</span> GregorianCalendar();</div><div class="line">        Locale.setDefault(Locale.US);</div><div class="line">        <span class="keyword">int</span> today = d.get(Calendar.DAY_OF_MONTH);</div><div class="line">        d.set(Calendar.YEAR, year);</div><div class="line">        d.set(Calendar.MONTH, month - <span class="number">1</span>);</div><div class="line">        d.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">int</span> weekday = d.get(Calendar.DAY_OF_WEEK);</div><div class="line">        <span class="keyword">int</span> firstDayOfWeek = d.getFirstDayOfWeek();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> indent = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (weekday != firstDayOfWeek) &#123;</div><div class="line">            indent++;</div><div class="line">            d.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</div><div class="line">            weekday = d.get(Calendar.DAY_OF_WEEK);</div><div class="line">        &#125;</div><div class="line">        String[] weekdaysName = <span class="keyword">new</span> DateFormatSymbols().getShortWeekdays();</div><div class="line">        do &#123;</div><div class="line">            System.out.printf(<span class="string">"%4s"</span>, weekdaysName[weekday]);</div><div class="line">            d.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">            weekday = d.get(Calendar.DAY_OF_WEEK);</div><div class="line">        &#125; <span class="keyword">while</span> (weekday != firstDayOfWeek);</div><div class="line">        System.out.println();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indent; i++) &#123;</div><div class="line">            System.out.print(<span class="string">"    "</span>);</div><div class="line">        &#125;</div><div class="line">        d.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">        <span class="keyword">while</span> (d.get(Calendar.MONTH) == month - <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> day = d.get(Calendar.DAY_OF_MONTH);</div><div class="line">            System.out.printf(<span class="string">"%3d"</span>, day);</div><div class="line">            <span class="keyword">if</span> (day == today) &#123;</div><div class="line">                System.out.print(<span class="string">"*"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.print(<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            d.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (d.get(Calendar.DAY_OF_WEEK) == firstDayOfWeek) &#123;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//不适用java类库</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCalendar1</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">" Sun Mon Tue Wed Thu Fri Sat "</span>);</div><div class="line">        <span class="keyword">int</span> today = <span class="number">16</span>;</div><div class="line">        <span class="keyword">int</span> weekday = day(year, month, <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weekday; i++) &#123;</div><div class="line">            System.out.print(<span class="string">"    "</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= month(year, month); i++) &#123;</div><div class="line">            System.out.printf(<span class="string">"%3d"</span>, i);</div><div class="line">            <span class="keyword">if</span> (i == today) &#123;</div><div class="line">                System.out.print(<span class="string">"*"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.print(<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (day(year, month, i) == <span class="number">6</span>) &#123;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//判断闰年</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">year</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> y % <span class="number">400</span> == <span class="number">0</span> || (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>);<span class="comment">//闰年规则，4的倍数，如果年份整百，必须为400的倍数</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//计算y年 m月有多少天</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">month</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (m == <span class="number">1</span> || m == <span class="number">3</span> || m == <span class="number">5</span> || m == <span class="number">7</span> || m == <span class="number">8</span> || m == <span class="number">10</span> || m == <span class="number">12</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">31</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">4</span> || m == <span class="number">6</span> || m == <span class="number">9</span> || m == <span class="number">11</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">30</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (year(y)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">29</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">28</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据公式，计算y年，m月 ，d日星期w  w = ([Y-1] + [(Y-1)/4] - [(Y-1)/100] + [(Y-1)/400] + D)mod 7</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">day</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</div><div class="line">            count = count + month(y, i);</div><div class="line">        &#125;</div><div class="line">        count = count + d;<span class="comment">//count 表示是y年的第几天</span></div><div class="line">        <span class="keyword">int</span> w = ((y - <span class="number">1</span>) + (y - <span class="number">1</span>) / <span class="number">4</span> - (y - <span class="number">1</span>) / <span class="number">100</span> + (y - <span class="number">1</span>) / <span class="number">400</span> + count) % <span class="number">7</span>;<span class="comment">//计算公式，公元元年1.1号星期1</span></div><div class="line">        <span class="keyword">return</span> w;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人计划至6月底]]></title>
      <url>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B36%E6%9C%88%E5%BA%95.html</url>
      <content type="html"><![CDATA[<h1 id="本月总体"><a href="#本月总体" class="headerlink" title="本月总体"></a>本月总体</h1><ol>
<li>看书:mysql/shell两本书看完，python简明教程看完,shell书看完前四章<strong>基本完成</strong></li>
<li>看书:java高并发一书，java虚拟机一书看完（附带看完操作系统）</li>
<li>操作系统，计算机网络，数据库，linux shell复习完</li>
<li>编程练习，每日1-2题（只有周六除外）,《程序员面试经典》84个题刷(java和python，熟悉，练习语法)</li>
<li>每早8：30-9：30看一小时书</li>
<li>网络编程小项目： 聊天室/文件共享 python/java实现，练手（java做成网页版）</li>
<li>每周日一整天编程真题</li>
</ol>
<h2 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h2><ol>
<li>计算机网络</li>
<li>操作系统</li>
<li>mysql必知必会</li>
<li>linux shell脚本攻略</li>
<li>python简明教程</li>
<li>程序员面试金典</li>
<li>分布式Java应用-基础与实践/大型网站系统与Java中间件实践</li>
<li>Java高并发编程实战/深入理解Java虚拟机</li>
</ol>
<ul>
<li><strong><em>注意：1和2必须完成，并完成总结；7.8结合看，总结一波，巩固其中的基础</em></strong></li>
</ul>
<h1 id="完成python基础学习"><a href="#完成python基础学习" class="headerlink" title="完成python基础学习"></a>完成python基础学习</h1><ol>
<li>任务一：用python编写一个批量测试脚本（测试zte代码）</li>
<li>任务二：学习完简明python教程一书<strong>完成</strong></li>
<li>时间： 一周完成（5.15号-5.20号）</li>
</ol>
<h1 id="完成linux-shell学习"><a href="#完成linux-shell学习" class="headerlink" title="完成linux shell学习"></a>完成linux shell学习</h1><ol>
<li>任务一： 学习完linux shell 脚本攻略一书</li>
<li>任务二： 完成leetcode 上shell题目</li>
<li>时间：两周完成（5.21号-6.1号）</li>
</ol>
<h1 id="完成数据库学习"><a href="#完成数据库学习" class="headerlink" title="完成数据库学习"></a>完成数据库学习</h1><ol>
<li>任务一：学习完mysql必知必会一书<strong>mysql必知必会1-22章基本看完</strong></li>
<li>任务二：完成leetcode 上database题目,总计13题，并总结<strong>已总结10题</strong></li>
<li>时间： 一周完成（5.21-5.26号）</li>
<li>任务三：牛客网上mysql习题 50%完成(<strong>取消</strong>)</li>
</ol>
<h1 id="完成Java并发编程学习"><a href="#完成Java并发编程学习" class="headerlink" title="完成Java并发编程学习"></a>完成Java并发编程学习</h1><ol>
<li>任务一： 学习完java并发编程实战一书</li>
<li>任务二：深入理解java虚拟机一书</li>
</ol>
<h1 id="完成操作系统复习"><a href="#完成操作系统复习" class="headerlink" title="完成操作系统复习"></a>完成操作系统复习</h1><ol>
<li>操作系统概念，第七版一书</li>
</ol>
<h1 id="完成计算机网络复习"><a href="#完成计算机网络复习" class="headerlink" title="完成计算机网络复习"></a>完成计算机网络复习</h1><ol>
<li>计算机网络（谢版），一书 </li>
</ol>
<h1 id="日程记录"><a href="#日程记录" class="headerlink" title="日程记录"></a>日程记录</h1><h2 id="5-15-5-24（10天任务）"><a href="#5-15-5-24（10天任务）" class="headerlink" title="5.15-5.24（10天任务）"></a>5.15-5.24（10天任务）</h2><ul>
<li>总结<ol>
<li>完成数据库（mysql）基础学习</li>
<li>完成linux shell基础xuex</li>
<li>完成python基础学习</li>
<li>今日头条2017四个编程题完成</li>
</ol>
</li>
</ul>
<h3 id="5-15"><a href="#5-15" class="headerlink" title="5.15"></a>5.15</h3><ol>
<li>学习了python基础</li>
</ol>
<h3 id="5-16"><a href="#5-16" class="headerlink" title="5.16"></a>5.16</h3><ol>
<li>学习完python基础-<strong>完成</strong></li>
<li>完成批量测试代码-<strong>完成</strong></li>
<li>编程练习： 显示日历；<strong>完成</strong></li>
</ol>
<h3 id="5-17"><a href="#5-17" class="headerlink" title="5.17"></a>5.17</h3><ol>
<li>编程练习：2题;<strong>完成,今日头条真题2个</strong></li>
<li>简明python教程一书例题做完- 未完成</li>
<li>完善zte测试代码 - 未完成</li>
<li>看mysql必知必会1-8章<strong>完成,见mysql总结</strong>，刷了2个leetcode数据库题目</li>
</ol>
<h3 id="5-18"><a href="#5-18" class="headerlink" title="5.18"></a>5.18</h3><ol>
<li>实验室804项目报告<strong>完成</strong></li>
<li>编程练习：1题<strong>完成</strong></li>
<li>看书：mysql必知必会9-16章-未完成</li>
</ol>
<h3 id="5-19"><a href="#5-19" class="headerlink" title="5.19"></a>5.19</h3><ol>
<li>String kmp算法总结完毕，编程练习刷题1 未完成</li>
<li>看书：mysql必知必会9-16章<strong>完成,刷数据库题目3个</strong></li>
<li>看书：python简明教程看完；（刷题2）未完成</li>
</ol>
<h3 id="5-20"><a href="#5-20" class="headerlink" title="5.20"></a>5.20</h3><ol>
<li>看书： linux私房菜看完bash和shell script两章<strong>完成</strong></li>
<li>编程练习： 1题 <strong>字典序，重点看</strong></li>
</ol>
<h3 id="5-21"><a href="#5-21" class="headerlink" title="5.21"></a>5.21</h3><ol>
<li>看书: python简明教程后面内容看完<strong>延后</strong></li>
<li>编程练习：1题，今日头条的四题总结完，kmp算法总结完成<strong>未完成</strong></li>
<li>python编程练习，剑指offer题目练习（3）</li>
</ol>
<h3 id="5-22"><a href="#5-22" class="headerlink" title="5.22"></a>5.22</h3><ol>
<li>python简明教程后面看完<strong>完成</strong></li>
</ol>
<h3 id="5-23"><a href="#5-23" class="headerlink" title="5.23"></a>5.23</h3><ol>
<li>早上看书：mysql必知必会17-22章看完<strong>完成,并刷了三个leetcode数据库题目</strong></li>
<li>下午编码：编程题练习，2题<strong>修改，完成KMP算法总结</strong></li>
<li>晚上看书：看linxu shell脚本攻略<strong>完成，看完第一章，并编写一测试脚本</strong></li>
</ol>
<h3 id="5-24"><a href="#5-24" class="headerlink" title="5.24"></a>5.24</h3><ol>
<li>早上看书：linux shell脚本攻略第二章过完<strong>完成</strong></li>
<li>下午编码： 编程练习，2题，总结完字符串与整数部分（面试经典）</li>
<li>晚上看书：操作系统第一章过一遍<strong>完成</strong></li>
</ol>
<h2 id="5-25-6-04（10天任务）"><a href="#5-25-6-04（10天任务）" class="headerlink" title="5.25-6.04（10天任务）"></a>5.25-6.04（10天任务）</h2><ul>
<li>计划<ol>
<li>复习完操作系统，总结完成（操作系统概念一书）</li>
<li>复习完计算机网络，总结完成（计算机网络-谢仁希一书）</li>
<li>编程真题8道<a href="https://www.nowcoder.com/contestRoom?orderByHotValue=1&amp;filter=0&amp;mutiTagIds=672_139_138" target="_blank" rel="external">链接</a>；总共需要三小时做完；三小时总结；</li>
<li>每日一小题/周日4个真题 code!</li>
</ol>
</li>
<li>总结<ol>
<li>操作系统部分看完</li>
<li>编程练习完成</li>
<li>计算机网络总结未完成</li>
</ol>
</li>
</ul>
<h3 id="5-25"><a href="#5-25" class="headerlink" title="5.25"></a>5.25</h3><ol>
<li>早上看书：复习完操作系统（未完成）</li>
<li>当日1编程题,总结完字符串和数组（未完成）</li>
</ol>
<p>##￥ 5.29</p>
<ol>
<li>刷编程题，见计划链接（一整天做完，总结完），用java和Python两种搞完，熟悉Python语法。<strong>基本完成</strong></li>
</ol>
<h3 id="5-30"><a href="#5-30" class="headerlink" title="5.30"></a>5.30</h3><ol>
<li>空</li>
</ol>
<h3 id="6-1号"><a href="#6-1号" class="headerlink" title="6.1号"></a>6.1号</h3><ol>
<li>看书：《大型网站系统与Java中间件实践》</li>
</ol>
<h3 id="6-2号"><a href="#6-2号" class="headerlink" title="6.2号"></a>6.2号</h3><ol>
<li>复习操作系统<strong>看完cpu调度和死锁</strong></li>
</ol>
<h3 id="6-3号"><a href="#6-3号" class="headerlink" title="6.3号"></a>6.3号</h3><ol>
<li>复习计算机网络，完成总结（延后）</li>
<li>复习操作系统，看内存管理<strong>未完成</strong></li>
</ol>
<h2 id="6-5号-6-10号"><a href="#6-5号-6-10号" class="headerlink" title="6.5号-6.10号"></a>6.5号-6.10号</h2><h3 id="6-5号"><a href="#6-5号" class="headerlink" title="6.5号"></a>6.5号</h3><ol>
<li>早上：刷阶梯训练，看程序员面试金典（<strong>总结完数学及位运算</strong>）</li>
<li>下午：认真看书，总结。操作系统/内存管理章节</li>
<li>晚上：单车锻炼； 看Java深入部分与总结（分布式，中间件）</li>
</ol>
<h3 id="6-7-6-9号"><a href="#6-7-6-9号" class="headerlink" title="6.7-6.9号"></a>6.7-6.9号</h3><ol>
<li>学习装箱问题相关算法，并总结</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础-java知识体系]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html</url>
      <content type="html"><![CDATA[<p>java技能图谱(来自牛客网)<br><img src="../images/Java技能图谱.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试编程题总结(数据结构和算法总结)]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><ol>
<li><a href="https://algorithm.yuanbin.me/zh-hans/index.html" target="_blank" rel="external">参考/数据结构与算法/leetcode/lintcode题解||:总结超详细,推荐!!</a></li>
<li>提交不通过时思考方向： 是否整型溢出！（int,long）</li>
</ol>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>重难点是: <strong>模式匹配(kmp算法)</strong>和<strong>正则表达式匹配</strong>; 在选择题中,可能会出现问next数组的题目</p>
<h2 id="Java字符串API"><a href="#Java字符串API" class="headerlink" title="Java字符串API"></a>Java字符串API</h2><ul>
<li><strong>StringBuilder</strong>常用,线程不安全,效率高; StringBuffer  线程安全,效率低;</li>
<li>matches()字符串是否匹配给定的正则表达式。</li>
<li>indexOf()返回指定子字符串在此字符串中第一次出现处的索引。(模式匹配api)</li>
<li>trim()返回字符串的副本，忽略前导空白和尾部空白。</li>
<li>valueOf()返回…字符串形式</li>
<li>split()按给定的正则表达式拆分字符串</li>
<li>replace/replaceAll/replaceFirst 替换字符串</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul>
<li>定义:s和t为给定的两个字符串,在主串s中查找子串t的过程称为模式匹配,返回t在s中第一次出现的位置</li>
<li>OJ题目:<a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">LeetCode|字符串匹配,子串第一次出现的位置</a></li>
<li>三种方法:<ol>
<li>java api: indexOf;</li>
<li>暴力搜</li>
<li>KMP算法</li>
</ol>
</li>
<li>kmp算法选择题:next数组<ul>
<li><a href="https://www.nowcoder.com/questionTerminal/57bdf294407c4477969fc7b4d56c7be7" target="_blank" rel="external">next数组</a></li>
</ul>
</li>
<li>求next数组的方法（递归法）</li>
</ul>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><ul>
<li>OJ题目:剑指offer第52题,Solution52;</li>
<li><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer|正则表达式匹配</a> ;<a href="https://leetcode.com/problems/regular-expression-matching/#/description" target="_blank" rel="external">LeetCode|正则表达式匹配</a></li>
<li>解题思路<ul>
<li>字符串 正则表达式匹配<ol>
<li>模式中,当前字符的下一个字符不是<code>*</code><ul>
<li>如果当前字符匹配,则字符串和模式串都下移一位</li>
<li>如果当前字符不匹配,则直接返回false</li>
</ul>
</li>
<li>模式中,当前字符的下一个字符是<code>*</code><ul>
<li>如果当前字符不匹配,则<code>*</code>匹配0个前位字符,模式串后移两位(前位字符,<code>*</code>前面的那个字符)</li>
<li>如果当前字符匹配,分两组<ul>
<li><code>*</code>匹配0个前位字符,模式串后移两位</li>
<li><code>*</code>匹配一个或者多个前位字符,字符串后移以为,模式串不变</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><h2 id="字符串平移-String-shift"><a href="#字符串平移-String-shift" class="headerlink" title="字符串平移(String shift)"></a>字符串平移(String shift)</h2><ul>
<li>题目描述<ul>
<li>我们规定对一个字符串的shift操作如下： shift(“ABCD”, 0) = “ABCD” shift(“ABCD”, 1) = “BCDA” shift(“ABCD”, 2) = “CDAB” 换言之, 我们把最左侧的N个字符剪切下来, 按序附加到了右侧。给定一个长度为n的字符串，我们规定最多可以进行n次向左的循环shift操作。如果shift(string, x) = string (0＜= x ＜n), 我们称其为一次匹配(match)。求在shift过程中出现匹配的次数。</li>
</ul>
</li>
<li>解决： 字符串必为周期字符串，计算出最短周期（用kmp算法中的next数组计算）</li>
</ul>
<h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-substring/" target="_blank" rel="external">最长公共子串</a></li>
<li>思路: 暴力法和<strong>动态规划法</strong>.</li>
</ol>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-subsequence/" target="_blank" rel="external">最长公共子序列</a></li>
</ol>
<h2 id="字符串与整数-数组的互相转换"><a href="#字符串与整数-数组的互相转换" class="headerlink" title="字符串与整数,数组的互相转换"></a>字符串与整数,数组的互相转换</h2><p>1.</p>
<h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><h2 id="字符串反转-1"><a href="#字符串反转-1" class="headerlink" title="字符串反转"></a>字符串反转</h2><ul>
<li>StringBuilder.reverse方法;</li>
<li><a href="https://leetcode.com/problems/reverse-words-in-a-string/#/description" target="_blank" rel="external">leetcode|字符串反转</a></li>
</ul>
<h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><h1 id="数组-Integer"><a href="#数组-Integer" class="headerlink" title="数组/Integer"></a>数组/Integer</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的性质"><a href="#链表的性质" class="headerlink" title="链表的性质"></a>链表的性质</h2><p><img src="../images/链表题目总结.png" alt=""></p>
<ol>
<li>技巧: 快慢指针和假头结点</li>
</ol>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><ol>
<li><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第3题-从尾到头打印链表</a></li>
</ol>
<h2 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h2><ol>
<li><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第14题-链表中倒数第k个结点</a></li>
</ol>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><ol>
<li><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第15题-反转链表</a></li>
</ol>
<h2 id="合并两个排序链表-合并排序数组"><a href="#合并两个排序链表-合并排序数组" class="headerlink" title="合并两个排序链表/合并排序数组"></a>合并两个排序链表/合并排序数组</h2><ol>
<li><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第16题-合并两个排序链表</a></li>
<li>合并排序数组,不用辅助空间的方法</li>
</ol>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><ol>
<li><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第25题-复杂链表的复制</a></li>
</ol>
<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><ol>
<li><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第36题-两个链表的第一个公共结点</a></li>
</ol>
<h2 id="删除链表的重复结点"><a href="#删除链表的重复结点" class="headerlink" title="删除链表的重复结点"></a>删除链表的重复结点</h2><ol>
<li><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第56题-删除链表的重复结点</a></li>
</ol>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的定义与性质"><a href="#二叉树的定义与性质" class="headerlink" title="二叉树的定义与性质"></a>二叉树的定义与性质</h2><p><img src="../images/二叉树知识点.png" alt=""></p>
<ol>
<li>二叉树的第i层至多有 2^(i−1) 个结点;</li>
<li>深度为k的二叉树至多有 2^k − 1 个结点;</li>
<li><strong>对任何一棵二叉树T，如果其终端结点数为 n0, 度为2的结点数为 n2, 则 n0 = n2 + 1。</strong></li>
<li>一棵深度为 k, 且有 2^k − 1 个节点称之为<strong>满二叉树</strong>;</li>
<li>深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为<strong>完全二叉树</strong>。完全二叉树中重在节点标号对应,即完全二叉树的叶子结点只能出现在最下层和次下层,最下层的全在树的左部.</li>
<li>具有n个结点的完全二叉树的深度k为<code>(log2n)向下取整+1</code></li>
<li>对于具有n个结点的完全二叉树,从1开始编号(上下左右):<ul>
<li>i&gt;1,则序号为i的结点的父结点序号为<code>i/2</code>(整除);</li>
<li>若2i&lt;=n,则序号为i的结点的左子结点序号为2i; 若2i&gt;n,则结点i无左子结点;</li>
<li>若2i+1&lt;=n,则序号为i的结点的右子节点为2i+1; 若2i+1&gt;n,则无右子节点</li>
<li>若从0开始编号,则i的父节点为(i-1)/2,左子节点为2i+1,右2i+2;</li>
</ul>
</li>
</ol>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ol>
<li>深度优先遍历(DFS)<ul>
<li>前序中序后序三种遍历方式的递归实现</li>
<li>前序中序后序三种遍历方式的非递归实现</li>
<li><a href="http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91.html">三种遍历方法详解总结</a></li>
</ul>
</li>
<li>广度优先遍历(BFS)<ul>
<li>层序遍历</li>
<li>之字形遍历</li>
<li>镜像</li>
</ul>
</li>
<li>OJ链接<ul>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/#/description" target="_blank" rel="external">LeetCode:前序遍历</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/#/description" target="_blank" rel="external">LeetCode:中序遍历</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/#/description" target="_blank" rel="external">LeetCode:后序遍历</a></li>
</ul>
</li>
</ol>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ul>
<li>一颗二叉查找树(BST)是一颗二叉树，其中每个节点都含有一个可进行比较的键及相应的值，且每个节点的<br>键都大于等于左子树中的任意节点的键，而小于右子树中的任意节点的键。</li>
</ul>
<h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h3><ol>
<li><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第23题-二叉搜索树的后序遍历序列</a></li>
</ol>
<h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><ol>
<li><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第26题-二叉搜索树与双向链表</a></li>
</ol>
<h3 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h3><ol>
<li><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第62题-二叉搜索树的第k个结点</a></li>
<li>思路: 用栈对二叉搜索树进行<strong>中序遍历</strong>,搜到第k个结点时跳出</li>
</ol>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><ul>
<li>定义: 如果某二叉树中任意结点的左右子树的深度相差不超过1,那么它就是一颗平衡二叉树</li>
<li>AVL树,自平衡二叉树;<br><img src="../images/AVL.png" alt=""></li>
</ul>
<h3 id="平衡二叉树的判定"><a href="#平衡二叉树的判定" class="headerlink" title="平衡二叉树的判定"></a>平衡二叉树的判定</h3><ol>
<li><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第39题-平衡二叉树</a></li>
<li>思路: 每个结点只遍历一次的解法</li>
</ol>
<h2 id="哈夫曼树-最优二叉树"><a href="#哈夫曼树-最优二叉树" class="headerlink" title="哈夫曼树(最优二叉树)"></a>哈夫曼树(最优二叉树)</h2><h3 id="哈夫曼二叉树的定义及性质"><a href="#哈夫曼二叉树的定义及性质" class="headerlink" title="哈夫曼二叉树的定义及性质"></a>哈夫曼二叉树的定义及性质</h3><ol>
<li>最优二叉树,也称为哈夫曼树:对一组带有权值的叶子结点,构造具有最小带权路径长度的二叉树. 选取权值最小和次小的结点构造.</li>
<li>具有n个叶子节点的哈夫曼树总共有2n-1个结点;</li>
</ol>
<h2 id="其他典型题目"><a href="#其他典型题目" class="headerlink" title="其他典型题目"></a>其他典型题目</h2><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第4题-重建二叉树</a></li>
<li>描述: 由先序和中序遍历序列,重建二叉树</li>
<li>思路:</li>
</ol>
<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><ol>
<li><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第17题-树的子结构</a></li>
<li>思路:</li>
</ol>
<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><ol>
<li><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第18题-二叉树的镜像</a></li>
<li>思路: 对二叉树进行前序遍历,对遍历到的节点,交换其左右子节点(可用递归实现)</li>
</ol>
<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><ol>
<li><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第24题-二叉树中和为某一值的路径</a></li>
<li>思路: 本题重难点!</li>
</ol>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><ol>
<li><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第38题-二叉树的深度</a></li>
<li>思路: 递归;  <strong>思考非递归的方法</strong></li>
</ol>
<h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第58题-对称的二叉树</a></li>
<li>思路: 比较二叉树的前序遍历序列(根左右)和对称前序遍历序列(根右左),用<strong>递归</strong>的方式进行遍历</li>
</ol>
<h3 id="按之字顺序打印二叉树"><a href="#按之字顺序打印二叉树" class="headerlink" title="按之字顺序打印二叉树"></a>按之字顺序打印二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第59题-按之字形顺序打印二叉树</a></li>
<li>思路: 用两个栈存;</li>
</ol>
<h3 id="把二叉树打印成多行-二叉树层序遍历"><a href="#把二叉树打印成多行-二叉树层序遍历" class="headerlink" title="把二叉树打印成多行(二叉树层序遍历)"></a>把二叉树打印成多行(二叉树层序遍历)</h3><ol>
<li><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第60题-把二叉树打印成多行</a></li>
</ol>
<h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第61题-序列化二叉树</a></li>
<li>思路: 前序遍历的递归实现; 注意反序列化如何递归</li>
</ol>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><ol>
<li><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第5题-用两个栈实现队列</a></li>
<li>思路: 队列先进先出,进队时,直接压入stack1;出队列时,如果stack2为空,则将stack1的元素全部压入stack2,再取stack2栈顶,如果stack2不为空,直接去stack2栈顶.</li>
</ol>
<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><ol>
<li><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第20题-包含min函数的栈</a></li>
<li>思路: 使用一个辅助栈,元素进栈时,辅助栈记录当前元素为栈顶时的最小值;元素出栈时,辅助栈也将对应的最小值出栈;</li>
</ol>
<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><ol>
<li><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第64题-滑动窗口的最大值</a></li>
<li>思路: 利用<strong>双端队列</strong><ul>
<li>用一个双端队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次<ol>
<li>判断当前最大值是否过期</li>
<li>新增加的值从队尾开始比较，把所有比他小的值丢掉</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><img src="../images/排序.png" alt=""></p>
<ul>
<li>参考:<a href="http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F.html">见本人排序总结</a></li>
</ul>
<h2 id="经典题目记录"><a href="#经典题目记录" class="headerlink" title="经典题目记录"></a>经典题目记录</h2><h2 id="长度10000的数组-假设数组中的元素平均分成了100段-每一段内的元素有序-求整个数组最大的前20个数"><a href="#长度10000的数组-假设数组中的元素平均分成了100段-每一段内的元素有序-求整个数组最大的前20个数" class="headerlink" title="长度10000的数组,假设数组中的元素平均分成了100段,每一段内的元素有序,求整个数组最大的前20个数"></a>长度10000的数组,假设数组中的元素平均分成了100段,每一段内的元素有序,求整个数组最大的前20个数</h2><ul>
<li>使用堆排序<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><ol>
<li><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="external">牛客网-剑指offer第29题-最小的k个数</a></li>
<li>思路: O(nlogk)算法,堆排序</li>
</ol>
</li>
</ul>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h2 id="哈希表查找"><a href="#哈希表查找" class="headerlink" title="哈希表查找"></a>哈希表查找</h2><ul>
<li>处理冲突的方法<ol>
<li><strong>开放地址法</strong>: 由关键码得到哈希地址,如果该地址已经存放了元素,就按照一个探测序列去寻找下一个空的哈希地址</li>
<li><strong>拉链法</strong>:将地址相同的拉成一个链表,将各个链表放在相应的数组中</li>
</ol>
</li>
</ul>
<h1 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h1><h2 id="最大公约数-最小公倍数"><a href="#最大公约数-最小公倍数" class="headerlink" title="最大公约数/最小公倍数"></a>最大公约数/最小公倍数</h2><ul>
<li>最大公约数:greatest common divisor</li>
<li>欧几里得法(辗转相除法):设<code>a&gt;b</code>,<code>a=b*p+q</code>,b与q的最大公约也就是a与b的最大公约数,直到q为0,直接返回;</li>
<li>最小公倍数:lowest common multiple; <code>lcm(a,b)*gcd(a,b)=a*b</code>;</li>
<li>求两个数或n个数的最小公倍数或最大公约数:<br><img src="../images/gcd.png" alt=""></li>
</ul>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><ul>
<li>素数: 只有1和本身两个约数;判断是否为素数,只需要对前根号n个数进行判断<br><img src="../images/prime.png" alt=""></li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位操作有按位与、或、非、左移n位和右移n位等操作。</p>
<ol>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1): 可以把最右边的一个1变成0;<br>2.</li>
</ol>
<h3 id="二进制中的1的个数"><a href="#二进制中的1的个数" class="headerlink" title="二进制中的1的个数"></a>二进制中的1的个数</h3><ul>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1)</li>
</ul>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><ul>
<li>卡特兰数递推关系:<img src="../images/卡特兰.png" alt=""></li>
<li>卡特兰数通项式:<img src="../images/catalan.png" alt=""><img src="../images/catalan1.png" alt=""></li>
<li>栈的出栈序列:1到n的序列,依次进栈,有多少种不同的出栈序列</li>
</ul>
<h2 id="全排列和全组合"><a href="#全排列和全组合" class="headerlink" title="全排列和全组合"></a>全排列和全组合</h2><ul>
<li>思路: 从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理；</li>
<li>参考:<a href="https://segmentfault.com/a/1190000002710424" target="_blank" rel="external">全排列/全组合</a></li>
</ul>
<h1 id="其他经典算法"><a href="#其他经典算法" class="headerlink" title="其他经典算法"></a>其他经典算法</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h1 id="其他经典题目"><a href="#其他经典题目" class="headerlink" title="其他经典题目"></a>其他经典题目</h1><h2 id="打印日历"><a href="#打印日历" class="headerlink" title="打印日历"></a>打印日历</h2><ul>
<li><a href="http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%97%A5%E5%8E%86%E8%AE%A1%E7%AE%97.html">日历计算</a></li>
</ul>
<h1 id="校招真题练习"><a href="#校招真题练习" class="headerlink" title="校招真题练习"></a>校招真题练习</h1><h2 id="今日头条"><a href="#今日头条" class="headerlink" title="今日头条"></a>今日头条</h2><ol>
<li><a href="http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91.html">异或|字典树应用</a>   <strong>本题重点，不可暴力枚举,应用字典树</strong></li>
</ol>
<h2 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础-Object类通用方法]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-Object%E7%B1%BB%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h1 id="Object类概览"><a href="#Object类概览" class="headerlink" title="Object类概览"></a>Object类概览</h1><p><img src="../images/object.png" alt=""></p>
<ul>
<li>Object类,主要是用来扩展,它的所有非final方法(如上图,hashCode, equals, clone, toString, finalize)都有明确的通用约定,它们被设计成要被覆盖的(override),任何一个类,覆盖这些方法时,都要遵守这些约定.</li>
</ul>
<h1 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h1><ul>
<li>设计目的: 用于检测一个对象是否等于另外一个对象.Object类中,这个方法默认将判断两个对象是否具有相同的引用.<br><img src="../images/equals方法.png" alt=""></li>
<li>equals方法满足特性<ul>
<li>自反性 x.equals(x)返回true</li>
<li>对称性</li>
<li>传递性</li>
<li>一致性</li>
<li>非空性 x.equals(null) 返回false</li>
</ul>
</li>
<li><strong>覆盖equals方法时,遵守约定</strong></li>
</ul>
<h1 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h1><ul>
<li>设计目的:由对象导出的一个整型值,java用hash算法的原理,来查找比较元素,提高查找效率(例如java集合中)</li>
<li><strong>覆盖equals时,总要覆盖hashCode</strong></li>
<li>规范<ul>
<li>如果x.equals(y)为true, x.hashCode()与y.hashCode()具有相同的值,<strong>相等的对象必须具有相等的散列码</strong></li>
<li>如果两个对象,equals方法比较不相等,则hashCode方法不一定产生不同的整数结果</li>
</ul>
</li>
<li>hashMap底层原理<ul>
<li><a href="http://kakajw.iteye.com/blog/935226" target="_blank" rel="external">深入解析Java对象的hashCode和hashCode在HashMap的底层数据结构的应用</a></li>
</ul>
</li>
</ul>
<h1 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h1><ul>
<li>设计目的: 返回表示对象值得字符;通用约定:被返回的字符串应该是一个”简洁的,但信息丰富,且易于阅读的形式”</li>
<li>java.lang.Object默认返回类的名称+”@”符号+散列码的无符号16进制表示<br><img src="../images/toString方法.png" alt=""></li>
<li>当对象被传递给println, printf, 字符串联操作符(+)以及assert或者被调试器打印出来时,toString方法会被自动调用. <strong>建议所有子类覆盖toStirng方法</strong></li>
</ul>
<h1 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h1><ul>
<li>默认的clone操作是浅copy,它并没有克隆包含爱对象中的内部对象</li>
<li><p>所有的数组类型均包含一个public的clone方法,可以利用这个方法创建一个包含所有数组元素拷贝的一个新数组.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] luckNums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</div><div class="line"><span class="keyword">int</span>[] cloned = luckNums.clone();</div><div class="line">cloned[<span class="number">5</span>]=<span class="number">12</span>;<span class="comment">//doesn't change luckNums[5];</span></div></pre></td></tr></table></figure>
</li>
<li><p>要进行clone处理,</p>
<ul>
<li>则要实现标记接口Cloneable,</li>
<li>用public修饰符重新定义clone方法</li>
</ul>
</li>
<li><strong>谨慎的覆盖clone</strong></li>
</ul>
<h1 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h1><ul>
<li><img src="../images/finalize.png" alt=""></li>
<li><strong>工作原理</strong>: 一旦垃圾回收器准备好释放对象占用的存储空间,将首先调用其finalize()方法,并且在下一次垃圾回收动作发生时才会真正回收对象占用的内存.</li>
<li><strong>避免使用finalize方法</strong></li>
<li><a href="http://www.cnblogs.com/yantz/p/4610614.html" target="_blank" rel="external">finalize()和System.gc()区别</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础-面试总结]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h2><ul>
<li>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。“一次编译，到处运行”。在不同平台上安装对应的JVM，jvm与底层硬件交互，由虚拟机负责运行java程序。</li>
</ul>
<h2 id="JDK和JRE的区别"><a href="#JDK和JRE的区别" class="headerlink" title="JDK和JRE的区别"></a>JDK和JRE的区别</h2><ul>
<li>JRE: java runtime environment运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。J</li>
<li>JDK: java development kit完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序</li>
</ul>
<h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><ul>
<li>基本数据类型分类(4类8种)<ul>
<li>整数型<ul>
<li>byte 一个字节,-128~127</li>
<li>short 两个字节,-2^15~2^15-1</li>
<li>int 四个字节,-2^31-2^31-1</li>
<li>long 八个字节,-2^63-2^63-1</li>
</ul>
</li>
<li>浮点型:即小数型<ul>
<li>float 四个字节</li>
<li>double 八个字节</li>
</ul>
</li>
<li>字符型<ul>
<li>char 两个字节 0~65535(2^16-1),没有负数</li>
</ul>
</li>
<li>布尔型<ul>
<li>boolean :只有 true false ; boolean理论上占八分之一字节,但java中boolean类型没有明确指定它的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-面向对象三大特征"><a href="#1-3-面向对象三大特征" class="headerlink" title="1.3    面向对象三大特征"></a>1.3    面向对象三大特征</h2><ul>
<li>封装encapsulation：封装是指隐藏对象的属性和实现细节,仅对外提供公共访问方式</li>
<li>继承inheritance：Java只支持单继承,</li>
<li>多态polymorphism：</li>
</ul>
<h2 id="1-4-override和overload"><a href="#1-4-override和overload" class="headerlink" title="1.4    override和overload"></a>1.4    override和overload</h2><ul>
<li>override:方法重写: 子类中出现和父类中方法声明一模一样的方法</li>
<li><p>方法的重写（override）两同两小一大原则：</p>
<ul>
<li>方法名相同，参数类型相同</li>
<li>子类返回类型小于等于父类方法返回类型，(从而可类型自动转换)</li>
<li>子类抛出异常小于等于父类方法抛出异常，</li>
<li>子类访问权限大于等于父类方法访问权限。</li>
</ul>
</li>
<li><p>overload：方法重载: 本类中出现的方法名一样,参数列表不同的方法,与返回类型值无关</p>
</li>
</ul>
<h2 id="1-5-static和final"><a href="#1-5-static和final" class="headerlink" title="1.5    static和final"></a>1.5    static和final</h2><p>static，final初始化总结：<br>1、被final修饰而没有被static修饰的类的属性变量只能在两种情况下初始化:(必须初始化）<br>   a.在它被声明的时候赋值;b.在构造函数里初始化;c .在非静态块里<br>2、被static修饰而没有被final修饰的类的属性变量只能在两种情况下初始化:(可以不初始化）<br>   a.在它被声明的时候赋值;b.在静态或非静态快里初始化;<br>3、同时被final和static修饰的类的属性变量只能在两种情况下初始化:（必须初始化）<br>   a.在它被定义的时候;b.在类的静态块里初始化</p>
<p>接口里面定义的常量必须初始化；</p>
<h2 id="1-6-代码块执行顺序"><a href="#1-6-代码块执行顺序" class="headerlink" title="1.6    代码块执行顺序"></a>1.6    代码块执行顺序</h2><p><strong>父类静态-子类静态-父类属性初始化,普通代码,块构造函数-子类属性初始 构造块和构造函数(new 则执行)</strong><br>1.父类静态代码块 （  java虚拟机加载类时，就会执行该块代码，故只执行一次）<br>2 .子类静态代码块 （  java虚拟机加载类时，就会执行该块代码，故只执行一次）</p>
<ol>
<li>父类属性对象初始化<br>4.父类普通代码块（每次new,每次执行 ）</li>
<li>父类构造函数（每次new,每次执行）<br>6.子 类 属性对象初始化<br>7.子类普通代码块（每次new,每次执行 ）<br>8.子 类构造函数（每次new,每次执行</li>
</ol>
<p>final<br>final修饰的方法，不允许被子类覆盖。<br>final修饰的类，不能被继承。<br>final修饰的变量，不能改变值。<br>final修饰的引用类型，不能再指向别的东西，但是可以改变其中的内容。</p>
<h2 id="1-7-Java支持多继承么？"><a href="#1-7-Java支持多继承么？" class="headerlink" title="1.7    Java支持多继承么？"></a>1.7    Java支持多继承么？</h2><p>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。<br>但是java中的接口支持多继承，，即一个子接口可以有多个父接口(接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能)。</p>
<h2 id="1-8-方法覆盖-Overriding-和方法重载-Overloading-的区别"><a href="#1-8-方法覆盖-Overriding-和方法重载-Overloading-的区别" class="headerlink" title="1.8    方法覆盖(Overriding)和方法重载(Overloading)的区别"></a>1.8    方法覆盖(Overriding)和方法重载(Overloading)的区别</h2><p>Override 重写(覆盖) 子类中出现和父类中方法声明一模一样的方法,返回类型值一致<br>Overload 重载 本类中出现的方法名一样,参数列表不同的方法,与返回类型值无关</p>
<h2 id="1-9-如何理解多态"><a href="#1-9-如何理解多态" class="headerlink" title="1.9    如何理解多态"></a>1.9    如何理解多态</h2><p>实现多态的技术称为：动态绑定；动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法；<br>Java实现多态有三个必要条件：继承、重写、父类引用指向子类对象。</p>
<h2 id="1-10-Java四种权限修饰符"><a href="#1-10-Java四种权限修饰符" class="headerlink" title="1.10    Java四种权限修饰符"></a>1.10    Java四种权限修饰符</h2><h2 id="1-11-接口和抽象类"><a href="#1-11-接口和抽象类" class="headerlink" title="1.11    接口和抽象类"></a>1.11    接口和抽象类</h2><ol>
<li>接口中的成员方法，属性默认为public（可省略）且只能为public</li>
<li>接口中的成员变量，属性默认为public static final(可省略)</li>
<li>接口，只能声明为 public interface …{}</li>
<li>java中的接口支持多继承，一个接口可以继承(extends)多个父接口<br><img src="../images/interface.png" alt=""></li>
<li>抽象类则可以同时包含抽象和非抽象的方法</li>
<li>类可以不实现抽象类和接口声明的所有方法，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类不能被实例化。</li>
<li>abstract 不能与private、static、final或native并列修饰同一个方法<br><img src="../images/接口和抽象类区别.png" alt=""></li>
</ol>
<h2 id="1-12-进程和线程的区别"><a href="#1-12-进程和线程的区别" class="headerlink" title="1.12    进程和线程的区别"></a>1.12    进程和线程的区别</h2><p>进程是一种静态的概念，；进程是表示资源分配的基本单位，一个进程内可以包含多个线程；进程间切换开销大；<br>线程是进程中执行运算的最小单位，可以理解为程序内部的一条执行路径，顺序控制流；每个线程有独立的有独立的线程栈和程序计数器，线程切换开销小。</p>
<h2 id="线程的几种可用状态"><a href="#线程的几种可用状态" class="headerlink" title="线程的几种可用状态"></a>线程的几种可用状态</h2><ol>
<li>新建( new )：新创建了一个线程对象。</li>
<li>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li>
<li>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</li>
<li>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<br>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。<br>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</li>
<li>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生</li>
</ol>
<h2 id="Java创建线程的三种种方式"><a href="#Java创建线程的三种种方式" class="headerlink" title="Java创建线程的三种种方式"></a>Java创建线程的三种种方式</h2><ol>
<li>继承Thread类；重写其run方法；</li>
<li>实现Runnable接口；</li>
<li>使用ExecutorService、Callable、Future实现<strong>有返回结果</strong>的多线程(JDK5.0以后)</li>
</ol>
<h2 id="1-15-什么是死锁-deadlock-？"><a href="#1-15-什么是死锁-deadlock-？" class="headerlink" title="1.15    什么是死锁(deadlock)？"></a>1.15    什么是死锁(deadlock)？</h2><p>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。</p>
<h2 id="1-16-监视器-Monitor-如何线程同步"><a href="#1-16-监视器-Monitor-如何线程同步" class="headerlink" title="1.16    监视器(Monitor)如何线程同步"></a>1.16    监视器(Monitor)如何线程同步</h2><h2 id="1-17-Java集合框架有哪些接口"><a href="#1-17-Java集合框架有哪些接口" class="headerlink" title="1.17    Java集合框架有哪些接口"></a>1.17    Java集合框架有哪些接口</h2><p><img src="../images/集合体系图.png" alt=""></p>
<ul>
<li>list接口:<ul>
<li>元素可重复,元素有放入顺序;</li>
<li>ArrayList: 非线程安全,效率高;vector 线程安全,效率低</li>
<li>所有list中可以有null元素</li>
</ul>
</li>
<li>set接口:<ul>
<li>元素不可重复,无序</li>
<li>可以有null元素</li>
</ul>
</li>
<li>Queue接口<ul>
<li>一般不允许有null元素(LinkedList除外,它同时继承了List接口)</li>
</ul>
</li>
<li>Map接口<ul>
<li>HashMap非线程安全，高效，支持null；</li>
<li>HashTable线程安全，低效，不支持null </li>
</ul>
</li>
</ul>
<h2 id="1-18-什么是迭代器-Iterator-？"><a href="#1-18-什么是迭代器-Iterator-？" class="headerlink" title="1.18    什么是迭代器(Iterator)？"></a>1.18    什么是迭代器(Iterator)？</h2><h2 id="1-19-Iterator和ListIterator的区别是什么？"><a href="#1-19-Iterator和ListIterator的区别是什么？" class="headerlink" title="1.19    Iterator和ListIterator的区别是什么？"></a>1.19    Iterator和ListIterator的区别是什么？</h2><h2 id="1-20-Map遍历的几种方法"><a href="#1-20-Map遍历的几种方法" class="headerlink" title="1.20    Map遍历的几种方法"></a>1.20    Map遍历的几种方法</h2><p><a href="http://www.trinea.cn/android/hashmap-loop-performance/" target="_blank" rel="external">http://www.trinea.cn/android/hashmap-loop-performance/</a></p>
<h2 id="1-21-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#1-21-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="1.21    快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>1.21    快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h2><h2 id="1-22-为什么集合类没有实现Cloneable和Serializable接口？"><a href="#1-22-为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="1.22    为什么集合类没有实现Cloneable和Serializable接口？"></a>1.22    为什么集合类没有实现Cloneable和Serializable接口？</h2><ul>
<li>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</li>
</ul>
<h2 id="1-23-Java中的HashMap的工作原理是什么？"><a href="#1-23-Java中的HashMap的工作原理是什么？" class="headerlink" title="1.23        Java中的HashMap的工作原理是什么？"></a>1.23        Java中的HashMap的工作原理是什么？</h2><ol>
<li>HashMap底层是一个数组结构,数组的每一个元素是一个链表,而且链表中的每个节点是一个Entry[]键值对的数据结构。</li>
<li>添加元素的原理:put添加键值对,根据key计算hashCode,根据hashcode得到在数组中的下标(<code>int i = hash(key.hashcode)&amp;(len-1);</code>),新加入的放在链表头,最先加入的在链尾;</li>
<li>获取元素的原理: 首先计算hashCode值,找到数组对应的位置,然后根据equals方法,找到在对应位置的链表中找到对应的元素;</li>
</ol>
<h2 id="HashMap和Hashtable-ConcurrentHashMap区别？"><a href="#HashMap和Hashtable-ConcurrentHashMap区别？" class="headerlink" title="HashMap和Hashtable,ConcurrentHashMap区别？"></a>HashMap和Hashtable,ConcurrentHashMap区别？</h2><ul>
<li>HashMap非线程安全，高效，支持null；</li>
<li>HashTable线程安全，低效，不支持null </li>
<li>Hashtable中采用的锁机制是一次锁住整个hash表，从而同一时刻只能由一个线程对其进行操作；所有方法都是同步的</li>
<li>ConcurrentHashMap的设计有点特别，表现在多个线程操作上。它不用做外的同步的情况下默认同时允许16个线程读和写这个Map容器; 将hash表分为16个段,只锁住当前用到的段,并发性能提升;</li>
<li>迭代方法不同</li>
</ul>
<h2 id="hashCode-和equals-方法的重要性体现在什么地方？"><a href="#hashCode-和equals-方法的重要性体现在什么地方？" class="headerlink" title="hashCode()和equals()方法的重要性体现在什么地方？"></a>hashCode()和equals()方法的重要性体现在什么地方？</h2><h2 id="数组-Array-和列表-ArrayList-有什么区别？"><a href="#数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？"></a>数组(Array)和列表(ArrayList)有什么区别？</h2><h2 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h2><ul>
<li>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构.<br>这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。</li>
<li>2.对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。</li>
<li>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li>
</ul>
<h2 id="Comparable和Comparator接口是干什么的？"><a href="#Comparable和Comparator接口是干什么的？" class="headerlink" title="Comparable和Comparator接口是干什么的？"></a>Comparable和Comparator接口是干什么的？</h2><h2 id="什么是Java优先级队列-Priority-Queue-？"><a href="#什么是Java优先级队列-Priority-Queue-？" class="headerlink" title="什么是Java优先级队列(Priority Queue)？"></a>什么是Java优先级队列(Priority Queue)？</h2><h2 id="HashSet和TreeSet有什么区别？"><a href="#HashSet和TreeSet有什么区别？" class="headerlink" title="HashSet和TreeSet有什么区别？"></a>HashSet和TreeSet有什么区别？</h2><ul>
<li>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。</li>
<li>另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</li>
</ul>
<h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><ol>
<li><p>Java 5之后,基本数据类型和对应的包装类型,可以自动互相装换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer i = <span class="number">10</span>;<span class="comment">//装箱</span></div><div class="line"><span class="keyword">int</span> n = i;<span class="comment">//拆箱</span></div></pre></td></tr></table></figure>
</li>
<li><p>装箱和拆箱是如何实现的</p>
<ul>
<li>装箱时,调用的是Integer.valueOf()方法</li>
<li>拆箱时,调用的是Integer.intValue()方法</li>
</ul>
</li>
<li>Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别<ul>
<li>第一种方式不会触发自动装箱的过程；而第二种方式会触发；</li>
<li>在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</li>
</ul>
</li>
<li>Integer.valueOf,数值在[-128,127]之间则直接返回缓存中已经存在的对象</li>
<li><strong>“==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程)</strong></li>
<li>参考:<a href="http://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="external">深入剖析Java中的装箱和拆箱</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nowcoder.com/ta/review-java" target="_blank" rel="external">https://www.nowcoder.com/ta/review-java</a></p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="对Spring的理解"><a href="#对Spring的理解" class="headerlink" title="对Spring的理解"></a>对Spring的理解</h2><ul>
<li>Spring是一个轻量级的JavaEE开发框架; Spring的核心思想是控制反转和面向切面;</li>
<li>控制反转: 借助于“第三方”实现具有依赖关系的对象之间的解耦</li>
<li>面向切面:在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</li>
</ul>
<h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><h2 id="对mvc模式的理解"><a href="#对mvc模式的理解" class="headerlink" title="对mvc模式的理解"></a>对mvc模式的理解</h2><ul>
<li>一般J2EE web开发,是一个分层式的架构,表现层(web层)-业务层(service)层-持久层(dao层),mvc模式是表现层开发的一种设计模式,目的是解除控制逻辑,业务逻辑,视图之间的耦合;mvc模式由模型,视图,控制器三部分组成;控制器是接收客户端所提交的请求,将请求转发给适当的模型进行处理,然后将处理的结构返回给视图;</li>
</ul>
<h2 id="Session和cookie的区别"><a href="#Session和cookie的区别" class="headerlink" title="Session和cookie的区别"></a>Session和cookie的区别</h2><ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上</li>
<li>session能够存储任意的Java对象，cookie只能存储String类型的对象</li>
<li>session会保存在服务器上一段时间,当访问增多,会占用服务器性能,考虑减轻服务器性能的话,应该使用cookie</li>
<li>cookie不是很安全,别人可以分享本地cookie,进行cookie欺骗</li>
</ol>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层模型与TCP-IP四层模型"><a href="#OSI七层模型与TCP-IP四层模型" class="headerlink" title="OSI七层模型与TCP/IP四层模型"></a>OSI七层模型与TCP/IP四层模型</h2><p><img src="../images/osi七层模型.gif" alt=""></p>
<ul>
<li>实际应用的tcp/ip四层: 连接层,网络层,传输层,应用层</li>
<li>各层的作用<ol>
<li>物理层：通过媒介传输比特,确定机械及电气规范</li>
<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ol>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="../images/ip.png" alt=""><br><img src="../images/ip1.png" alt=""></p>
<ul>
<li>A类地址,<ul>
<li>可指派的网络号126个(2^7-2),见2的原因是: 网络号全0为保留地址,表示本网络;网络号127(0111 1111)保留为回环测试(如127.0.0.1)</li>
<li>可指派的主机号: 2^24-2; 减去全0的主机号,减去全1主机号</li>
</ul>
</li>
<li>B类地址<ul>
<li>可指派网络号2^14-1:128.0不指派,最小可指派的网络号是128.1</li>
<li>主机号减2,2^16-2;</li>
</ul>
</li>
<li>C类地址<ul>
<li>可指派网络号2^21-1:192.0.0不指派,最小可指派的网络号192.0.1</li>
<li>主机号减2: 2^8-2;</li>
</ul>
</li>
</ul>
<h2 id="TCP-UDP协议"><a href="#TCP-UDP协议" class="headerlink" title="TCP/UDP协议"></a>TCP/UDP协议</h2><ul>
<li>运输层协议和网络层协议的主要区别<br><img src="../images/运输层网络层.png" alt=""></li>
<li><p>运输层的协议端口号</p>
<ul>
<li>协议端口号(protocol port number),简称端口;使不同的操作系统中的进程可以相互通信,用统一的方法对TCP/IP体系中的应用进程进行标识;16位的端口号(65535个)</li>
<li>通信的终点是应用进程,但我们只需把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成</li>
</ul>
</li>
<li><p>tcp字段含义<br><img src="../images/tcp字段.png" alt=""></p>
</li>
<li><p>传输层定义两种传输协议：TCP（传输控制协议）和 UDP（或用户数据报协议）<br><img src="../images/tcp-udp.png" alt=""></p>
</li>
<li>TCP协议和UDP协议特性区别总结：<ol>
<li>TCP协议在传送数据段的时候要给段标号；UDP协议不</li>
<li>TCP协议可靠；UDP协议不可靠</li>
<li>TCP协议是面向连接；UDP协议采用无连接</li>
<li>TCP协议负载较高，采用虚电路；UDP采用无连接</li>
<li>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</li>
<li>TCP协议采用窗口技术和流控制</li>
</ol>
</li>
</ul>
<h2 id="TCP三次握手与四次分手"><a href="#TCP三次握手与四次分手" class="headerlink" title="TCP三次握手与四次分手"></a>TCP三次握手与四次分手</h2><p><img src="../images/tcp.jpg" alt=""></p>
<ol>
<li>三次握手和四次分手的过程</li>
<li>为什么要三次握手和四次分手</li>
<li>参考:<a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>http状态码<br><img src="../images/http状态码.png" alt=""><ul>
<li>404  未找到，服务器找不到所请求的网页。</li>
<li>302  临时移动，服务器从不同位置的网页响应请求，请求者应继续使用原有位置进行以后的请求。</li>
<li>500  （服务器内部错误），服务器遇到错误，无法完成请求。</li>
<li>403  （禁止）服务器拒绝请求</li>
</ul>
</li>
<li>http与https区别<ul>
<li>http协议</li>
<li>简单理解: https是安全版的http,</li>
<li>HTTP的端口号是80，https的端口号是443</li>
</ul>
</li>
</ul>
<h2 id="SNMP简单网络管理协议"><a href="#SNMP简单网络管理协议" class="headerlink" title="SNMP简单网络管理协议"></a>SNMP简单网络管理协议</h2><ul>
<li>simple network management protocol 简单网络管理协议</li>
<li>是一个网络管理员用来管理的工具相当于  一个app 所以是<strong>应用层</strong></li>
</ul>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul>
<li>Internet Control Message Protocol 互联网控制消息协议</li>
<li>网络层协议</li>
<li>用ping命令,检查一台主机的网络层是否连通;</li>
</ul>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ul>
<li>IEEE 802.3—CSMA/CD网络，定义CSMA/CD总线网的MAC子层和物理层的规范,人们习惯将<strong>IEEE 802.3称为”以太网</strong>;</li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li>描述操作系统的两个主要责任。</li>
<li>定义内存和进程管理。</li>
<li>解释分时操作是如何创建虚拟机假象的。</li>
<li>解释逻辑地址和物理地址之间的关系。</li>
<li>比较内存管理方法。</li>
<li>区别固定分区法和固定分区法。</li>
<li>定义和应用分区选择算法。</li>
<li>解释请求分页是如何创建虚拟机假象的。</li>
<li>解释进程生存周期的各个阶段和过渡。</li>
<li>解释各种 CPU 调度算法的处理。</li>
<li>进程间的通信方式</li>
</ul>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>UNIX中有如下的通信方式：</p>
<ul>
<li>1） 文件和记录锁定。<br>为避免两个进程间同时要求访问同一共享资源而引起访问和操作的混乱，在进程对<br>共享资源进行访问前必须对其进行锁定，该进程访问完后再释放。这是UNIX为共享<br>资源提供的互斥性保障。</li>
<li>2 ）管道。<br>管道一般用于两个不同进程之间的通信。当一个进程创建一个管道，并调用fork创<br>建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样 提供了<br>两个进程之间数据流动的一种方式。</li>
<li>3 ） FIFO 。<br>FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个<br>FIFO都有一个名字，允许不相关的进程访问同一个FIFO。因此也成为命名管。</li>
<li>4）消息队列。<br>UNIX下不同进程之间可实现共享资源的一种机制；UNIX允许不同进程将格式化的数<br>据流以消息形式发送给任意<br>进程。对消息队列具有操作权限的进程都可以使用msget完成对消息队列的操作控制<br>。通过使用消息类型，进程可以按任何顺序读消息，或为消息安排优先级顺序。</li>
<li>5 ）信号灯。<br>作为进程间通讯的一种方法，它不是用于交换大批数据，而用于多进程之间的同步<br>（协调对共享存储段的存取）。</li>
<li>6 ）共享内存。<br>通过信号灯实现存储共享（类似“红灯停、绿灯行”）</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库四大特性"><a href="#数据库四大特性" class="headerlink" title="数据库四大特性"></a>数据库四大特性</h2><ol>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ol>
<h1 id="linux-shell"><a href="#linux-shell" class="headerlink" title="linux/shell"></a>linux/shell</h1><h1 id="面试问题收集"><a href="#面试问题收集" class="headerlink" title="面试问题收集"></a>面试问题收集</h1><ol>
<li>说说所知道的设计模式</li>
<li>多线程下的单例模式</li>
<li>多线程编程，遇到的问题，怎么解决的</li>
<li>大型项目如何分配，管理</li>
</ol>
<h1 id="项目-实习-学习"><a href="#项目-实习-学习" class="headerlink" title="项目/实习/学习"></a>项目/实习/学习</h1><h2 id="说说你所知道的设计模式-及应用"><a href="#说说你所知道的设计模式-及应用" class="headerlink" title="说说你所知道的设计模式,及应用"></a>说说你所知道的设计模式,及应用</h2><h2 id="最近看了什么书-待看的书籍"><a href="#最近看了什么书-待看的书籍" class="headerlink" title="最近看了什么书/待看的书籍"></a>最近看了什么书/待看的书籍</h2><p>**</p>
<ul>
<li>操作系统(教材版) <strong>优先</strong></li>
</ul>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><ul>
<li>您好,我叫刘航,湖北孝感人;来自华中科技大学电信学院,18年6月份研究生毕业;</li>
<li>研究生一年级期间,参加华为软件精英挑战赛,并获得全国亚军; 16年暑假在华为公司武汉研究所实习;</li>
<li>在软件技能方面,熟悉Java基础,了解linux, Spring框架,对设计模式也有一定的了解; 有个人博客站点,总结学习成果;</li>
<li>个人爱好方面,喜欢运动,特别是跑步,大概每周会跑一次8公里;感觉跑步特别锻炼人的意志力;</li>
</ul>
<h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><ul>
<li>比赛规模：    全国八个赛区，赛区32强，赛区4强进决赛</li>
<li>描述：在有向图中求最短路径的问题，约束是：给定了起点和终点，同时给定了一系列必经节点，求经过所有必经节点的最短路径。</li>
<li>解决思路： 指派问题结合分支定界来结局，可以把这个看成一个指派问题，根据有向图信息，得到一个费用矩阵，求一个最小指派，每个节点都要连接另一个节点，这样会形成一系列的环，然后用分支定界来破开环，最后形成一个环  即可。求指派问题： 用匈牙利算法，km算法（效率更高）</li>
</ul>
<h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><ul>
<li><p>名称：统一网元采集器；</p>
</li>
<li><p>项目周期：3个月（2016.06-2016.09）；</p>
</li>
<li><p>团队规模：后端开发3；前端3人；测试2人；</p>
</li>
<li><p>目标用户：内部平台，主要供公司内部的技术服务人员使用。</p>
</li>
<li><p>项目描述：采集网元信息的平台，（网元：一个网络系统中的某个网络单元或者节点, 即能独立完成一种或几种功能的设备，如基站，交换机），主要作用是采集网元设备的信息（比如这个设备的类型，是否正在运行，设备的硬件信息温度等）；  主要功能（模块）包括： 网元信息管理，采集模板管理，采集脚本管理，采集日志管理；</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础-正则表达式]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h1 id="正则表达式基础语法"><a href="#正则表达式基础语法" class="headerlink" title="正则表达式基础语法"></a>正则表达式基础语法</h1><ul>
<li><p>定义:是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串</p>
</li>
<li><p>常用的元字符</p>
<ul>
<li><code>.</code>    匹配除换行符以外的任意字符</li>
<li><code>\w</code>    匹配字母或数字或下划线或汉字</li>
<li><code>\s</code>    匹配任意的空白符</li>
<li><code>\d</code>    匹配数字</li>
<li>\b    匹配单词的开始或结束</li>
<li>`^``    匹配字符串的开始</li>
<li><code>$</code>    匹配字符串的结束</li>
</ul>
</li>
<li><p>重复</p>
<ul>
<li><code>*</code>    重复零次或更多次</li>
<li><code>+</code> 重复一次或更多次</li>
<li><code>?</code>    重复零次或一次(记忆:问号表示有或者没有)</li>
<li><code>{n}</code>    重复n次</li>
<li><code>{n,}</code>    重复n次或更多次</li>
<li><code>{n,m}</code>    重复n到m次</li>
</ul>
</li>
<li><p>字符类</p>
<ul>
<li>使用方括号<code>[]</code>: 匹配方括号中的任意字符</li>
<li>例如:像<code>[0-9]</code>代表的含意与<code>\d</code>就是完全一致的：一位数字；同理<code>[a-z0-9A-Z_]</code>也完全等同于<code>\w</code>（如果只考虑英文的话）。</li>
</ul>
</li>
<li><p>分支条件</p>
<ul>
<li>使用<code>|</code>,即”或”</li>
<li>例如:<code>0\d{2}-\d{8}|0\d{3}-\d{7}</code>这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)</li>
</ul>
</li>
<li>反义<ul>
<li><code>\W</code>匹配任意不是字母，数字，下划线，汉字的字符</li>
<li><code>\S</code>    匹配任意不是空白符的字符</li>
<li><code>\D</code>    匹配任意非数字的字符</li>
<li><code>\B</code>    匹配不是单词开头或结束的位置</li>
<li><code>[^x]</code>匹配除了x以外的任意字符</li>
<li><code>[^aeiou]</code>    匹配除了aeiou这几个字母以外的任意字符</li>
</ul>
</li>
<li>分组<ul>
<li>使用小括号’()’</li>
<li>例如:<code>(\d{1,3}\.){3}\d{1,3}</code>是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：<code>\d{1,3}</code>匹配1到3位的数字，<code>(\d{1,3}\.){3}</code>匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</li>
</ul>
</li>
</ul>
<h1 id="glob-模式"><a href="#glob-模式" class="headerlink" title="glob 模式"></a>glob 模式</h1><ul>
<li>shell所使用的简化的正则表达式</li>
<li>星号（<code>*</code>）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>*</code>) 表示匹配任意中间目录，比如a/<code>**</code>/z 可以匹配 a/z, a/b/z 或 a/b/c/z等  </li>
</ul>
<h1 id="Java中正则表达式使用"><a href="#Java中正则表达式使用" class="headerlink" title="Java中正则表达式使用"></a>Java中正则表达式使用</h1><ul>
<li>java正则表达式中的转义<code>\</code>与<code>\\</code>:  Java 的正则表达式在匹配点(<code>.</code>)  和斜杠(<code>\</code>)，表达式要分别写作 <code>\\.</code>和 <code>\\\\</code></li>
<li>参考:<a href="https://unmi.cc/understand-java-regex-backslash/" target="_blank" rel="external">理解 Java 正则表达式怪异的 <code>\\</code>和 <code>\\\\</code></a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">强烈推荐教程</a></li>
<li><a href="https://regexper.com/" target="_blank" rel="external">正则表达式可视化理解</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人计划至四月底]]></title>
      <url>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B3%E5%9B%9B%E6%9C%88%E5%BA%95.html</url>
      <content type="html"><![CDATA[<h1 id="每日日程流程"><a href="#每日日程流程" class="headerlink" title="每日日程流程"></a>每日日程流程</h1><ol>
<li>刷面试题5x3;(3)</li>
<li>刷剑指offer,4题(2.5小时)</li>
<li>Java面试知识点总结: 5点(30分钟)</li>
<li>下午看书: effective java/Spring/jvm</li>
<li>晚上总结成文档</li>
</ol>
<h1 id="Spring-IOC-AOP-MVC总结"><a href="#Spring-IOC-AOP-MVC总结" class="headerlink" title="Spring IOC/AOP/MVC总结"></a>Spring IOC/AOP/MVC总结</h1><ol>
<li>Spring AOP深入总结–4.15号之前完成,四天时间</li>
<li>Spring MVC深入总结–4.22号之前完成,一周时间</li>
<li>Spring ICO深入总结–4.29号之前完成,一周时间</li>
<li>总结其中用到的各种设计模式</li>
</ol>
<h1 id="剑指offer总结"><a href="#剑指offer总结" class="headerlink" title="剑指offer总结"></a>剑指offer总结</h1><ol>
<li>每日刷4题–4.22号之前将66个题刷完(基本完成,目前已经完成57题)</li>
<li>剑指offer刷题总结,分类整理总结–4.25号完成,三天时间(基本总结完成)</li>
</ol>
<h1 id="Effective-Java-1-4章-第10章"><a href="#Effective-Java-1-4章-第10章" class="headerlink" title="Effective Java: 1-4章,第10章"></a>Effective Java: 1-4章,第10章</h1><ol>
<li>涉及到的各种设计模式总结<ul>
<li>构建者模式,一天(已完成)</li>
<li>装饰者模式,一天(已完成)</li>
<li>适配器模式,一天(已完成)</li>
<li>FlyWeight模式,一天</li>
<li>桥接模式</li>
<li>观察者模式(书p234),一天</li>
</ul>
</li>
<li>总结Java对象通用方法:equals, hashCode, toString,  ,finalizeclone (已完成)</li>
</ol>
<h1 id="Java并发总结-深入理解jvm第五部分"><a href="#Java并发总结-深入理解jvm第五部分" class="headerlink" title="Java并发总结(深入理解jvm第五部分)"></a>Java并发总结(深入理解jvm第五部分)</h1><ol>
<li>java内存模型</li>
<li>java并发工具<ul>
<li>Executor framework</li>
<li>Concurrent Collection</li>
<li>Synchronizer</li>
</ul>
</li>
</ol>
<h1 id="Java垃圾回收总结"><a href="#Java垃圾回收总结" class="headerlink" title="Java垃圾回收总结"></a>Java垃圾回收总结</h1><ol>
<li>finalize与 System.gc();</li>
<li>Java内存管理机制</li>
<li>垃圾收集器与内存分配策略</li>
</ol>
<h1 id="面试题练习"><a href="#面试题练习" class="headerlink" title="面试题练习"></a>面试题练习</h1><ol>
<li>每天练习15道题目: 5x3;</li>
<li>Java面试常考知识点总结: 每日总结10点</li>
</ol>
<h1 id="每日进展记录"><a href="#每日进展记录" class="headerlink" title="每日进展记录"></a>每日进展记录</h1><h2 id="阶段一-4-12-4-15-剑指offer刷到50题"><a href="#阶段一-4-12-4-15-剑指offer刷到50题" class="headerlink" title="阶段一: 4.12-4.15(剑指offer刷到50题)"></a>阶段一: 4.12-4.15(剑指offer刷到50题)</h2><ul>
<li>4.12 剑指offer刷完40题,还剩26题;刷面试题5*3;</li>
<li>4.13 刷面试题5*3; 面试腾讯</li>
<li>4.14 刷剑指offer</li>
<li>4.15 剑指offer刷至50题!完成</li>
</ul>
<h2 id="阶段二-4-16-4-24-编程题总结一波"><a href="#阶段二-4-16-4-24-编程题总结一波" class="headerlink" title="阶段二: 4.16-4.24(编程题总结一波)"></a>阶段二: 4.16-4.24(编程题总结一波)</h2><ul>
<li>4.16-4.18  编程题归类总结</li>
<li>4.19 编程题基本总结完成</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring笔记3-Spring-AOP]]></title>
      <url>http://liuhang.net.cn/Spring-aop.html</url>
      <content type="html"><![CDATA[<h1 id="AOP基础"><a href="#AOP基础" class="headerlink" title="AOP基础"></a>AOP基础</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><ul>
<li>AOP: aspect-oriented programming 面向切面编程</li>
<li>理解:<strong><em>在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</em></strong>; 把切入到指定类指定方法的代码片段称为<strong>切面</strong>，而切入到哪些类、哪些方法则叫<strong>切入点</strong></li>
<li>应用举例:  声明式事物,日志<br><img src="../images/aop理解.png" alt=""></li>
</ul>
<h1 id="Spring-AOP深入分析及实现原理"><a href="#Spring-AOP深入分析及实现原理" class="headerlink" title="Spring AOP深入分析及实现原理"></a>Spring AOP深入分析及实现原理</h1><p><img src="../images/spring-aop架构.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="external">Spring AOP 实现原理与 CGLIB 应用</a></li>
<li><a href="https://my.oschina.net/huangyong/blog/161338" target="_blank" rel="external">AOP 那点事儿</a></li>
<li><a href="https://my.oschina.net/huangyong/blog/161402" target="_blank" rel="external">AOP 那点事儿（续集）</a><br>参考2和参考3写的特别好,强烈推荐!!</li>
<li><a href="http://www.cnblogs.com/xiohao/p/4146273.html" target="_blank" rel="external">Spring-AOP和AspectJ的区别和联系</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式6-装饰者模式]]></title>
      <url>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。装饰模式是一种用于替代继承的技术,使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</li>
<li>适用场景:装饰原有对象、在不改变原有对象的情况下扩展增强新功能/新特征.。当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li>看需要被增强的对象继承了哪些类或者接口,编写一个类去继承或者实现这些接口或者父类</li>
<li>在这个编写的类中,增加一个变量,变量类型为要增强的对象的类型;然后定义构造函数,构造这个变量;</li>
<li>这个类去实现接口或者父类时,调用2中定义的变量的相应方法(从而在装饰类中保留原有类的方法)</li>
<li>重写需要增强的方法(从而增强要装饰的方法,增强这个方法的功能)</li>
</ol>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul>
<li>装饰模式中的四种角色<ul>
<li>①Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法。</li>
<li>②ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象（被装饰者），实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</li>
<li>③Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</li>
<li>④ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</li>
</ul>
</li>
<li>抽象构件 Component.Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> decorator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2016/12/15.</div><div class="line"> * 角色：抽象构件 Component.Java</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">- 具体构件类 ConcreteComponent.java</div><div class="line"></div><div class="line">```java</div><div class="line"><span class="keyword">package</span> decorator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2016/12/15.</div><div class="line"> * 具体构建类,继承抽象类Component</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是具体的构件类,被装饰(增强)的"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>抽象装饰类 Decorator.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> decorator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2016/12/15.</div><div class="line"> * 作用:引入抽象构件类， 给具体构件类增加职责，但是具体职责在其子类中实现</div><div class="line"></div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Component component;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.component = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//调用原有业务方法</span></div><div class="line">        component.operation();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>具体装饰类A</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> decorator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2016/12/15.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.operation();</div><div class="line">        addedBehavior();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addedBehavior</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是具体的装饰类A，我可以增强原有对象方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>具体装饰类B</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> decorator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2016/12/15.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorB</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.operation();</div><div class="line">        addedAnotherBehavior();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addedAnotherBehavior</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是具体的装饰类B，我也可以增强原有对象方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> decorator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2016/12/15.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Component component, decoratorA;</div><div class="line"></div><div class="line">        component = <span class="keyword">new</span> ConcreteComponent();</div><div class="line">        decoratorA = <span class="keyword">new</span> ConcreteDecoratorA(component);<span class="comment">//对原有具体构件component进行装饰</span></div><div class="line"></div><div class="line">        component.operation();</div><div class="line">        System.out.println(<span class="string">"\n装饰一次后:"</span>);</div><div class="line">        decoratorA.operation();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"\n二次装饰"</span>);</div><div class="line">        Component decoratorB;</div><div class="line">        decoratorB = <span class="keyword">new</span> ConcreteDecoratorB(decoratorA);<span class="comment">// 如果需要对原有构件对象装饰后的decoratorA对象上进行再次装饰</span></div><div class="line">        decoratorB.operation();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>测试结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">我是具体的构件类,被装饰(增强)的</div><div class="line"></div><div class="line">装饰一次后:</div><div class="line">我是具体的构件类,被装饰(增强)的</div><div class="line">我是具体的装饰类A，我可以增强原有对象方法</div><div class="line"></div><div class="line">二次装饰</div><div class="line">我是具体的构件类,被装饰(增强)的</div><div class="line">我是具体的装饰类A，我可以增强原有对象方法</div><div class="line">我是具体的装饰类B，我可以增强原有对象方法</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/janice0529/article/details/44160091" target="_blank" rel="external">Decorator参考</a></li>
<li><a href="http://www.kancloud.cn/digest/xing-designpattern/143730" target="_blank" rel="external">设计模式参考</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式4-构建者模式]]></title>
      <url>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4-%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h1 id="构建者模式"><a href="#构建者模式" class="headerlink" title="构建者模式"></a>构建者模式</h1><h2 id="什么是Builder-model"><a href="#什么是Builder-model" class="headerlink" title="什么是Builder model"></a>什么是Builder model</h2><ul>
<li><p>解决痛点: 一个类中包含几个必须参数,多个可选参数,使用重叠构造器(构造器重载),当有许多参数时,构造器很多,代码难以阅读; 可使用JavaBean模式,用set方法对每个参数进行赋值,但可能有线程安全问题; 用builder model,可保证像重叠构造器的安全性和JavaBeany模式一样的可读性.</p>
</li>
<li><p>使用场景: 如果类的构造器或者静态工厂中具有多个参数,设计这种类时,可选择Builder模式,特别是当大多数参数是可选的时候,与使用传统的重叠构造器模式相比,使用Builder模式的客户端代码更容易阅读和编写,构建器也比JavaBeans更安全.</p>
</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul>
<li>builder model 设计步骤<ol>
<li>设计内部类Builder,用必要的参数构造构造器,得到builder对象</li>
<li>在builder对象上调用各个可选参数的setter方法,设置相关可选参数</li>
<li>调用builder对象的无参build方法生成不可变对象.(这里,原对象的构造方法传入build对象参数)</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//final 修饰必须初始化,声明时或者构造函数或者非静态块中</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">        <span class="comment">//Required parameter</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</div><div class="line"></div><div class="line">        <span class="comment">// Optional parameters: initialized to default values</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.servingSize = servingSize;</div><div class="line">            <span class="keyword">this</span>.servings = servings;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setCalories</span><span class="params">(<span class="keyword">int</span> calories)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.calories = calories;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setFat</span><span class="params">(<span class="keyword">int</span> fat)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.fat = fat;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setCarbohydrate</span><span class="params">(<span class="keyword">int</span> carbohydrate)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.carbohydrate = carbohydrate;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setSodium</span><span class="params">(<span class="keyword">int</span> sodium)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.sodium = sodium;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);<span class="comment">//静态内部类,访问私有构造方法</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//私有构造方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">        servingSize = builder.servingSize;</div><div class="line">        servings = builder.servings;</div><div class="line">        calories = builder.calories;</div><div class="line">        fat = builder.fat;</div><div class="line">        sodium = builder.sodium;</div><div class="line">        carbohydrate = builder.carbohydrate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">       NutritionFacts nutritionFacts = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">1</span>, <span class="number">2</span>).setCarbohydrate(<span class="number">1</span>).build();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式5-服务提供者框架-适配器模式]]></title>
      <url>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%A1%86%E6%9E%B6-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h1 id="服务提供者框架"><a href="#服务提供者框架" class="headerlink" title="服务提供者框架"></a>服务提供者框架</h1><h2 id="什么是服务提供者框架"><a href="#什么是服务提供者框架" class="headerlink" title="什么是服务提供者框架"></a>什么是服务提供者框架</h2><ul>
<li>多个服务提供者实现一个服务，系统为客户端提供多个实现，并把他们从多个实现中解耦出来</li>
</ul>
<h2 id="服务提供者框架图解"><a href="#服务提供者框架图解" class="headerlink" title="服务提供者框架图解"></a>服务提供者框架图解</h2><ul>
<li><img src="../images/Service_Provider.png" alt="服务提供者框架"></li>
</ul>
<h2 id="服务提供者框架组件"><a href="#服务提供者框架组件" class="headerlink" title="服务提供者框架组件"></a>服务提供者框架组件</h2><ol>
<li>服务接口(Service Interface):面向接口编程，将服务通过抽象统一声明，以供客户端调用，由各个服务提供者提供具体实现。如JDBC的Connection接口。</li>
<li>服务提供者接口(Service Provider Interface)：服务提供者接口，<strong>用于创建服务实例</strong>，如JDBC中的Driver类；提供者要实现具体的获取实例的方法，该类被代替具体的服务Connection注册到DriverManager中，当调用DriverManager的getConnection方法时就会调用已注册的Driver的方法来创建实例。</li>
<li>服务访问API(Service Access API):用于客户端获取相应的服务，如JDBC就是通过DriverManager的getConnection来获取具体的服务。</li>
<li>提供者注册API(Provider Registration API)：用于<strong>加载（注册）服务提供者</strong>，使得客户端可以访问它实现的服务； 如JDBC的DriverManager，当调用class.forName加载MySQL的驱动包时，就会把MySQL的Driver注册到DriverManager中，后续调用getConnection，返回的就是MySQL实现的Connection。</li>
</ol>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><ul>
<li>service provider framework 包含四个部分<ol>
<li>服务接口 service interface</li>
<li>服务提供者接口 service provider interface</li>
<li>服务访问api  service access api</li>
<li>提供者注册api provider registration api<br>api设计是静态工厂方法使用的体现</li>
</ol>
</li>
<li><strong>设计一个服务提供者框架,就是做一个服务接口(让别人,服务提供者,去实现),然后做一个类,来注册(加载)别人的实现,即我在客户端可以选择我要使用(加载)哪个提供者提供的服务.</strong></li>
<li><strong>优点:</strong> 以jdbc为例,java api 提供数据库连接服务,但数据库厂商有很多家,jdk里面不能为每个厂商编写连接,java api只需要提供一个服务接口,各个数据库厂商去实现这个接口即可,客户端调用数据库连接服务时,自助选择加载哪个厂商提供的数据库连接.客户端只需要用java api提供的接口进行编程即可,如<code>java.sql.Connection</code>. <strong>“多个服务提供者实现一个服务(多个数据库厂商都实现了数据库连接服务),系统(java api)为服务提供者的客户端(即我们这些要使用数据库连接服务的人或代码)提供多个实现,并把他们从多个实现解耦出来(提供者与服务者解耦,java api不去实现不同数据库的具体连接)”</strong></li>
</ul>
<h2 id="简单代码示例"><a href="#简单代码示例" class="headerlink" title="简单代码示例"></a>简单代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Service Interface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</div><div class="line">    ...<span class="comment">//Service specific methods here;</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// Service Provider Interface : get service instance</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</div><div class="line">    <span class="function">Service <span class="title">newService</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/4/6.</div><div class="line"> * Non instantiable class for service registration and access</div><div class="line"> * 非 可实例化的类，提供服务访问API和服务提供者注册API</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceManager</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceManager</span><span class="params">()</span> </span>&#123;<span class="comment">//私有化构造方法</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Provider&gt; providers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="comment">//线程安全map</span></div><div class="line"></div><div class="line">    <span class="comment">// Provider registration API</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerProviders</span><span class="params">(String name, Provider provider)</span> </span>&#123;</div><div class="line">        providers.put(name, provider);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Service access API</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Service <span class="title">newInstance</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        Provider provider = providers.get(name);</div><div class="line">        <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No provider registered with name: "</span> + name);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> provider.newService();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="服务提供者框架在JDBC中的应用分析"><a href="#服务提供者框架在JDBC中的应用分析" class="headerlink" title="服务提供者框架在JDBC中的应用分析"></a>服务提供者框架在JDBC中的应用分析</h2><ul>
<li>使用jdbc的简单步骤(mysql为例)<ol>
<li>加载数据库驱动<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code><ul>
<li>这里包含了调用提供者注册api,注册提供者<code>DriverManager.registerDriver</code><br><img src="../images/Driver注册.png" alt=""></li>
</ul>
</li>
<li>获取数据库连接<code>Connection conn = DriverManager.getConnection(url(jdbc:mysql://localhost:3306/dataBaseName/),user,password);</code></li>
<li>用connection对数据库进行curd操作;</li>
</ol>
</li>
<li>JDBC(java database connectivity)<ol>
<li>java.sql.Connection接口即”服务接口”,提供对各种数据库的连接;</li>
<li>java.sql.Driver接口即”服务提供者接口”,封装了connection服务;<br><img src="../images/Driver接口.png" alt=""></li>
<li>java.sql.DriverManager类: DriverManager.registerDriver是提供者注册api, DriverManager.getConnection是服务访问api;</li>
</ol>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://xiaohuishu.net/2015/06/03/%E6%8E%A2%E7%A9%B6%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%A1%86%E6%9E%B6/" target="_blank" rel="external">探究服务提供者框架,分析JDBC实现
</a></li>
<li><a href="https://toutiao.io/posts/4akr5c/preview" target="_blank" rel="external">Java 服务提供者框架</a></li>
<li><a href="http://noahsnail.com/2016/09/27/2016-9-28-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%A1%86%E6%9E%B6/" target="_blank" rel="external">服务提供者框架</a></li>
</ol>
<h1 id="服务提供者框架变体-适配器模式"><a href="#服务提供者框架变体-适配器模式" class="headerlink" title="服务提供者框架变体-适配器模式"></a>服务提供者框架变体-适配器模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul>
<li>适配器模式定义: <strong>适配器模式将一个类的接口，转化成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间</strong>。</li>
<li>适配器模式与装饰者模式:<ul>
<li>适配器模式,与装饰模式(Decorator model),代理模式有类似的地方,都属于<strong>结构型设计模式</strong></li>
<li>适配器模式:对不符合接口要求的类,改成跟接口要求一样(例如改个名字)</li>
<li>装饰者模式: 对原有类,进行增强(装饰), 两者实现方法都是,先拥有一个被装饰(被适配)的类实例,然后对其进行装饰增强(适配器模式就是只改名字,改成符合要求的接口样子)</li>
</ul>
</li>
<li>适配器模式设计方法:<ul>
<li>适配器其实是分为对象适配器和类适配器两种</li>
<li><strong>对象适配器</strong>:使用组合的方法，在Adapter中会保留一个原对象（Adaptee）的引用，适配器的实现就是讲Target中的方法委派给Adaptee对象来做,用Adaptee中的方法实现Target中的方法。</li>
<li><strong>类适配器</strong>:是通过类的继承来实现的。Adpater直接继承了Target和Adaptee中的所有方法，并进行改写，从而实现了Target中的方法。</li>
</ul>
</li>
</ul>
<h2 id="适配器模式在spring-mvc应用分析"><a href="#适配器模式在spring-mvc应用分析" class="headerlink" title="适配器模式在spring mvc应用分析"></a>适配器模式在spring mvc应用分析</h2><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/u010288264/article/details/53835185" target="_blank" rel="external">从SpringMVC来看适配器模式</a></li>
<li><a href="http://haolloyin.blog.51cto.com/1177454/346128" target="_blank" rel="external">适配器模式:对象适配器和类适配器</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础-IO]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-IO.html</url>
      <content type="html"><![CDATA[<h1 id="输入输出流分类"><a href="#输入输出流分类" class="headerlink" title="输入输出流分类"></a>输入输出流分类</h1><p><img src="../media/输入输出流分类.png" alt=""></p>
<h1 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h1><p><img src="../media/节点流和处理流.png" alt=""></p>
<h2 id="节点流类型"><a href="#节点流类型" class="headerlink" title="节点流类型"></a>节点流类型</h2><p><img src="../media/节点流类型.png" alt=""></p>
<h2 id="处理流类型"><a href="#处理流类型" class="headerlink" title="处理流类型"></a>处理流类型</h2><p><img src="../media/处理流类型.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.cnblogs.com/xdp-gacl/p/3634409.html" target="_blank" rel="external">java-流</a></li>
<li><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="external">java-api</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础-序列化与反序列化]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
      <content type="html"><![CDATA[<h1 id="序列化和反序列化的概念"><a href="#序列化和反序列化的概念" class="headerlink" title="序列化和反序列化的概念"></a>序列化和反序列化的概念</h1><ul>
<li><strong>把对象转换为字节序列的过程称为对象的序列化。</strong></li>
<li><strong>把字节序列恢复为对象的过程称为对象的反序列化。</strong></li>
<li>对象的序列化主要有两种用途：<ul>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li>
<li>在网络上传送对象的字节序列。</li>
</ul>
</li>
<li>举例<ul>
<li>比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</li>
</ul>
</li>
</ul>
<h1 id="序列化API"><a href="#序列化API" class="headerlink" title="序列化API"></a>序列化API</h1><ul>
<li><code>java.io.ObjectOutputStream</code>代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</li>
<li><code>java.io.ObjectInputStream</code>代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.cnblogs.com/xdp-gacl/p/3777987.html" target="_blank" rel="external">Java序列化与反序列化|孤傲苍狼</a></li>
<li><a href="https://github.com/giantray/stackoverflow-java-top-qa/blob/master/contents/what-is-a-serialversionuid-and-why-should-i-use-it.md" target="_blank" rel="external">serialVersionUID 有什么作用？该如何使用？</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础-异常]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8.html</url>
      <content type="html"><![CDATA[<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><ul>
<li>Java中的异常层次结构<ul>
<li>Throwable<ul>
<li>Error</li>
<li>Exception<ul>
<li>RuntimeException : 由程序错误导致的异常,包含这几种情况: 错误的类型转换; 数组访问越界; 访问空指针;</li>
<li>其他Exception:  包括情况: 试图在文件尾部后面读取数据; 试图打开一个不存在的文件; 试图根据给定的字符串查找Class对象,而该字符串表示的类并不存在;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>出现RuntimeException 则一定是程序员的问题</li>
<li>将派生于Error类或者RuntimeException类的所有异常,称为<strong>未检查异常</strong></li>
<li>其他Exception称为<strong>已检查异常</strong>, 需要程序员显示声明(throws)或者捕获(try,catch),不然不能通过编译</li>
</ul>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><ul>
<li>异常处理的两种方式<ul>
<li>a: try..catch..finally 捕获并处理异常</li>
<li>b: throws: 声明异常,交给该方法的调用者来处理<ul>
<li>跟在方法声明后面,表示抛出异常.</li>
<li>声明抛出异常,由该方法的调用者来处理</li>
<li>方法体内里通过<code>throw</code>抛出异常,则方法声明中要用<code>throws</code>声明.</li>
</ul>
</li>
</ul>
</li>
<li>注意事项<ul>
<li>原则: 如果方法内部可以将问题处理,用try处理; 如果处理不了,用throws在方法上声明有异常,交由方法的调用者处理.</li>
<li>区别: 后续程序需要继续运行,则用try catch处理; 后续程序不需要继续运行,就用throws处理   </li>
</ul>
</li>
<li>方法重写注意<ul>
<li>子类重写方法时,如果父类方法抛出多个异常,子类方法只能抛出父类异常的子集; 子类方法只能抛出父类异常相同的类或者子类.<h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2></li>
</ul>
</li>
<li>被finally控制的语句体一定会执行(特殊: 执行到finally之前,jvm退出了,比如遇到了<code>System.exit(0);</code>)</li>
<li>finally作用: 用于释放资源,例如IO和数据库操作中<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo3</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            System.out.println(<span class="number">10</span>/<span class="number">0</span>);</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">            System.out.println(<span class="string">"除数为零"</span>);</div><div class="line">            <span class="comment">//System.exit(0);</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            System.out.println(<span class="string">"是否执行"</span>);<span class="comment">//有return语句也会执行;碰到exit(0),jvm提前退出,则不执行</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul>
<li>使用自定义异常的步骤<ul>
<li>1.通过继承<code>java.lang.Exception</code>声明自己的异常类</li>
<li>2.在方法的适当位置,生成自定义异常的实例,并用throw语句抛出</li>
<li>3.在方法声明部分,用throws声明异常</li>
</ul>
</li>
</ul>
<h2 id="练习demo"><a href="#练习demo" class="headerlink" title="练习demo"></a>练习demo</h2><ul>
<li><a href="https://github.com/husthang/javaFoundation/tree/master/src/exception" target="_blank" rel="external">ExceptionDemo</a></li>
<li>博客推荐: <a href="http://www.cnblogs.com/xdp-gacl/p/3627390.html" target="_blank" rel="external">孤傲苍狼博客java异常</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[读书笔记-简单的逻辑学]]></title>
      <url>http://liuhang.net.cn/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%A6.html</url>
      <content type="html"><![CDATA[<h1 id="Chapter-1-学习逻辑学的思想准备"><a href="#Chapter-1-学习逻辑学的思想准备" class="headerlink" title="Chapter 1 学习逻辑学的思想准备"></a>Chapter 1 学习逻辑学的思想准备</h1><ol>
<li>语言敏感度及运用叫</li>
<li>对现实的正确认识</li>
<li>主观认识与客观存在的相互作用方式</li>
</ol>
<h2 id="全神贯注"><a href="#全神贯注" class="headerlink" title="全神贯注"></a>全神贯注</h2><h2 id="确认事实"><a href="#确认事实" class="headerlink" title="确认事实"></a>确认事实</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式1-概述]]></title>
      <url>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E6%A6%82%E8%BF%B0.html</url>
      <content type="html"><![CDATA[<h1 id="设计原则-开闭原则"><a href="#设计原则-开闭原则" class="headerlink" title="设计原则-开闭原则"></a>设计原则-开闭原则</h1><ul>
<li>“一个软件实体应当对扩展开放，对修改关闭(Software entities should be open for extension, but closed for modification)”</li>
<li>开闭原则理解，在设计一个模块的时候应该使这个模块可以在不被修改的前提下被扩展。换言之，应该可以在不必修改源代码的情况下改变这个模块的行为。</li>
</ul>
<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><ul>
<li>设计模式可以分为三大类，分别是<strong>创建型设计模式</strong>、<strong>行为型设计模式</strong>以及<strong>结构型设计模式</strong>。</li>
</ul>
<h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><ul>
<li>单例模式(Singleton)</li>
<li>构建模式(Builder)</li>
<li>原型模式(Prototype)</li>
<li>抽象工厂模式(Abstract Factory)</li>
<li>工厂方法模式(Factory Method)</li>
</ul>
<h2 id="行为设计模式"><a href="#行为设计模式" class="headerlink" title="行为设计模式"></a>行为设计模式</h2><ul>
<li>策略模式(Strategy)</li>
<li>状态模式(State)</li>
<li>责任链模式(Chain of Responsibility)</li>
<li>解释器模式(Interpreter)</li>
<li>命令模式(Command)</li>
<li>观察者模式(Observer)</li>
<li>备忘录模式(Memento)</li>
<li>迭代器模式(Iterator)</li>
<li>模板方法模式(Template Method)</li>
<li>访问者模式(Visitor)</li>
<li>中介者模式(Mediator)</li>
</ul>
<h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><ul>
<li>装饰者模式(Decorator)</li>
<li>代理模式(Proxy)</li>
<li>组合模式(Composite)</li>
<li>桥连接模式(Bridge)</li>
<li>适配器模式(Adapter)</li>
<li>蝇量模式(Flyweight)</li>
<li>外观模式(Facade)</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.kancloud.cn/digest/xing-designpattern/143722" target="_blank" rel="external">写最好的设计模式专栏</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础算法-递归和动态规划]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</url>
      <content type="html"><![CDATA[<h1 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h1><ul>
<li><strong>动态规划的核心是，用空间换时间，找到递推关系</strong></li>
<li>“求第n个，求前n个，求所有的…”可用递归做</li>
</ul>
<h1 id="简单示例："><a href="#简单示例：" class="headerlink" title="简单示例："></a>简单示例：</h1><ol>
<li>斐波拉契数列<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归方法，效率不行</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>)+fibonacci(n-<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//动态规划法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=n; i++)&#123;</div><div class="line">        db[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol>
<li>背包问题</li>
<li>n皇后问题<ul>
<li>dfs深搜</li>
</ul>
</li>
<li>最长公共子序列</li>
<li>放苹果</li>
<li>拼凑钱币问题<ul>
<li><a href="https://www.nowcoder.com/questionTerminal/178b912722ac42a2865057a66d4e7de2" target="_blank" rel="external">链接</a></li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础算法-排序]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F.html</url>
      <content type="html"><![CDATA[<p><img src="../images/排序.png" alt="各种排序比较"></p>
<ol>
<li>稳定性: 若相同关键码元素间的位置关系在排序前与排序后保持一致,则为稳定的</li>
</ol>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><ul>
<li>插入排序的基本思想：每次将一个待排序的记录，按排序要求，<strong><em>插入</em></strong>到已经排序好的序列中的适当位置；</li>
</ul>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><ul>
<li>基本过程:<ul>
<li>对n个记录的表,从第二个记录开始,直到第n个记录,逐个向有序表中进行插入操作,得到n个记录有序的表</li>
</ul>
</li>
<li>性能分析:<ul>
<li>最好情况: 待排序序列已经有序,只需要比较n-1次,每次直接插入到已排序序列的尾部,复杂度O(n);</li>
<li>最坏情况,第i趟操作,插入的记录要插入到已排序序列的最前面,复杂度达到O(n^2);</li>
<li><strong>直接插入排序的性能与序列初始排列有关,初始基本有序,则效率可达O(n);</strong></li>
</ul>
</li>
<li>稳定性<ul>
<li><strong>直接插入排序是稳定的</strong>,根据其过程,关键码相同,位置关系会保持不变;</li>
</ul>
</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul>
<li>希尔排序是对直接插入排序的改进: 根据直接插入排序的两个性质: 当n比较小时,直接插入排序效率较高;当n很大时,若已经基本有序,其效率可提高到O(n);</li>
<li>基本过程:<ul>
<li>小增量排序: 选取一个步长d,将n个元素分为d个组,间隔d的为一个组,分别对每组进行直接插入排序,然后减少步长,知道步长为1,使得间隔为1的记录有序;</li>
</ul>
</li>
<li>性能分析: 跟选取的步长有关</li>
<li>稳定性: <strong>希尔排序不稳定</strong>,不同组内的相同值得元素,相对位置可能会发生变化;</li>
</ul>
<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><ul>
<li>交换排序的思想：序列中的两个元素相比较，若与排序要求相逆，则两者<strong>交换</strong>；</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>基本过程<ul>
<li>对n个记录,进行n-1趟排序,第一趟从第1个到第n个记录,两两比较,最大的”冒泡”到底部,第2趟从第1个到n-1个记录,最大的到n-1的位置;</li>
<li>如果在某趟两两比较中,一次交换都未发生,则表明已经有序,排序结束.</li>
</ul>
</li>
<li>性能分析<ul>
<li>最好情况: 已经有序,一趟两两比较之后就结束了,复杂度达到O(n);</li>
<li>最坏情况:逆序,复杂度到O(n^2)</li>
</ul>
</li>
<li>稳定性：<strong>冒泡排序是稳定的</strong>,值相同时不会进行交换</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>一趟快速排序的过程是：<ul>
<li>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</li>
<li>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</li>
<li>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</li>
<li>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</li>
<li>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</li>
</ul>
</li>
<li>举例:<ul>
<li>28,16,32,12,60,2,5,72一次快排的的变化<ul>
<li>5,16,32,12,60,2,28,72</li>
<li>5,16,28,12,60,2,32,72</li>
<li>5,16,2,12,60,28,32,72</li>
<li>5,16,2,12,28,60,32,72</li>
</ul>
</li>
</ul>
</li>
<li><p>性能分析:</p>
<ul>
<li>快排通常被任务是同数量级的排序方法中<strong>平均性能最好</strong></li>
<li>一次划分时间复杂度O(n),多次递归,每次划分得到两个等长序列,理想情况:O(log2n); 最坏情况,每次得到一个子序列O(n); 所以,最好O(nlog2n),最坏O(n^2);</li>
</ul>
</li>
<li><p>稳定性：<strong>不稳定</strong>,例如2,2,1序列;</p>
</li>
</ul>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ul>
<li>选择排序思想：在未排序的序列中<strong>选择</strong>出最小的已经排序的末尾</li>
</ul>
<h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><ul>
<li>基本过程:<ul>
<li>第一趟从n个记录找到最小的,与第一个交换; 第2趟,从第2个开始的n-1个中选出最小的,与第2个交换</li>
</ul>
</li>
<li>性能分析: 最好情况最坏情况都是O(n^2)</li>
<li>稳定性: <strong>直接选择排序不稳定</strong>,如5,8,5,2,9 第一趟排序后,第一个5和2换了位置</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>二叉堆具有以下性质：<ul>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li>
</ul>
</li>
<li><p>基本过程</p>
<ul>
<li>首先将n个元素,按关键码建成堆,将堆顶元素R[1]与R[n]交换(或输出),然后再将R[1]到R[n-1]调整为堆,继续取堆顶元素…以此类推,得到有序序列;</li>
<li>分解为两个问题:<ol>
<li>如何将n个元素建成堆</li>
<li>取出堆顶元素后,如何将剩下的元素调整为一个新的堆;(<strong>筛选问题</strong>)</li>
</ol>
</li>
<li><strong>筛选问题</strong>解决:<ul>
<li>根节点R[1]与左右子节点中较大的那个交换,然后继续往下对交换的那个子树再重复这个过程;</li>
</ul>
</li>
<li>建堆方法:<ul>
<li>从R[n/2]开始(第一个有子节点的节点开始),进行筛选过程,然后R[n/2-1]直到R[1];</li>
</ul>
</li>
</ul>
</li>
<li><p>堆排序使用于 top K 问题</p>
<ul>
<li>寻找前k个最大的数:<ul>
<li>建立一个有k个数的小根堆,此时堆顶是当前k各数的最小值,对剩下的n-k个数遍历,如果大于堆顶,则替换堆顶,并调整堆.时间复杂度: O（N*logK）</li>
</ul>
</li>
<li><p>k路合并,求top k问题;</p>
<ul>
<li><p>20路已经有序，20路合并  求Top500:有 20 个数组，每个数组有 500 个元素，并且是有序排列好的，现在在这 20*500个数中找出排名前 500 的数。</p>
</li>
<li><p>答：从20个数组中各取一个数，并记录每个数的来源数组，建立一个含20个元素的大根堆。此时堆顶就是最大的数，取出堆顶元素，并从堆顶元素的来源数组中取下一个数加入堆，再取最大值，一直这样进行500次即可。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ul>
<li>归并排序的思想：归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</li>
<li>基本过程: 先递归分解,再合并两个已经有序的表;</li>
<li>性能分析: 空间复制度O(n)</li>
<li>稳定性: <strong>稳定</strong></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="external">经典排序算法总结与实现</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础算法-查找]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础数据结构-栈和队列]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础数据结构-链表]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java随手总结（零散知识点记录）]]></title>
      <url>http://liuhang.net.cn/Java%E9%9A%8F%E6%89%8B%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="四中权限修饰符"><a href="#四中权限修饰符" class="headerlink" title="四中权限修饰符"></a>四中权限修饰符</h1><p><img src="media/14899742700152.jpg" alt=""></p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础增强-网络编程]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.cnblogs.com/xdp-gacl/p/3631965.html" target="_blank" rel="external">Java网络编程-孤傲苍狼</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础增强-集合框架]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html</url>
      <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p><img src="../images/集合体系图.png" alt="集合体系图"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://kakajw.iteye.com/blog/935226" target="_blank" rel="external">深入解析Java对象的hashCode和hashCode在HashMap的底层数据结构的应用</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="external">哈希表</a></li>
<li><a href="http://blog.csdn.net/zcg_java/article/details/43232251" target="_blank" rel="external">List,Set,Map接口</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础增强-代理]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-%E4%BB%A3%E7%90%86.html</url>
      <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="external">Java 动态代理机制分析及扩展</a></li>
<li><a href="http://blog.jobbole.com/104433/" target="_blank" rel="external">Java JDK 动态代理使用及实现原理分析</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础增强-注解]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-%E6%B3%A8%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.cnblogs.com/xdp-gacl/p/3622275.html" target="_blank" rel="external">Java注解总结-孤傲苍狼</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础增强-反射]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-%E5%8F%8D%E5%B0%84.html</url>
      <content type="html"><![CDATA[<h1 id="Class类的使用"><a href="#Class类的使用" class="headerlink" title="Class类的使用"></a>Class类的使用</h1><ul>
<li><strong>Java中万事万物皆对象，我们写的每一个类，也是对象，它是java.lang.Class类的实例对象</strong></li>
<li>类是Class类的实例对象，这个实例对象中，存了类的各种信息，<strong>类类型</strong>；</li>
<li>基本的数据类型，void关键字，也存在类类型</li>
<li>三种方法获取类的类类型（class type）<ul>
<li><code>Class c1=Foo.class</code> <code>int.class</code>也可，每个类都有隐含的静态变量class</li>
<li><code>Class c2=foo.getClass()</code> 已知类的对象（实例）</li>
<li><code>Class c3=Class.forName(&quot;类的全称&quot;)</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.liuhang.reflection;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/3/23.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Foo foo1 = <span class="keyword">new</span> Foo(); <span class="comment">//foo1是Foo类的实例对象</span></div><div class="line">        <span class="comment">//Foo这个类，也是一个实例对象，它是Class类的实例对象，"类类型"，这个Class类的实例对象中，保存了这个类的各种信息</span></div><div class="line">        <span class="comment">//获取Class类实例对象的三种方式</span></div><div class="line">        <span class="comment">//知道类名，每个类都有隐含的静态变量class</span></div><div class="line">        Class c1 = Foo.class;</div><div class="line">        <span class="comment">//知道类的实例对象</span></div><div class="line">        Class c2 = foo1.getClass();</div><div class="line">        System.out.println(c1 == c2);<span class="comment">//输出 true， 每个类，只可能是Class类的一个实例对象；</span></div><div class="line">        <span class="comment">//知道类的全称</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class c3 = Class.forName(<span class="string">"com.liuhang.reflection.Foo"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//可以类的类类型，来创建该类实例对象</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Foo foo2 = (Foo) c1.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h1><ul>
<li><code>Class.forName(&quot;类的全称&quot;)</code>，还代表动态加载类，运行时加载</li>
<li>编译时刻加载类-静态加载类，运行时刻加载类-动态加载类</li>
<li><code>new</code>对象，是静态加载，在编译时刻就要加载所有可能使用到的类;</li>
</ul>
<h1 id="获取方法信息"><a href="#获取方法信息" class="headerlink" title="获取方法信息"></a>获取方法信息</h1><ul>
<li><code>java.lang.reflect.Method</code></li>
<li><code>getMethods(),getDecleardMethods()</code></li>
<li>method.getReturnType,getParameterTypes`</li>
</ul>
<h1 id="获取成员变量、构造函数信息"><a href="#获取成员变量、构造函数信息" class="headerlink" title="获取成员变量、构造函数信息"></a>获取成员变量、构造函数信息</h1><ul>
<li><code>java.lang.reflect.Field</code>,Field类封装了关于类成员变量的操作</li>
<li><code>java.lang.reflect.Constructor;</code>Constructor类封装了冠以类的构造函的操作</li>
</ul>
<h1 id="方法反射的基本操作"><a href="#方法反射的基本操作" class="headerlink" title="方法反射的基本操作"></a>方法反射的基本操作</h1><ul>
<li><code>method.invoke</code></li>
</ul>
<h1 id="通过反射了解集合泛型的本质"><a href="#通过反射了解集合泛型的本质" class="headerlink" title="通过反射了解集合泛型的本质"></a>通过反射了解集合泛型的本质</h1><ul>
<li>编译之后，集合是去泛型化得，Java中集合的泛型，是防止错误输入的，只在编译时有效</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.liuhang.reflection;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/3/24.</div><div class="line"> * 获取类的方法信息</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Print class message.</div><div class="line">     * 打印类的成员信息</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> object the object该类的对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassMessage</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        <span class="comment">//要获取类的信息，首先要获取类的类类型class type</span></div><div class="line">        Class c1 = object.getClass();<span class="comment">//传递的是哪个子类的d对象，c1就是该子类的类类型</span></div><div class="line">        <span class="comment">//获取类的全称</span></div><div class="line">        System.out.println(<span class="string">"类的名称"</span> + c1.getName());</div><div class="line"></div><div class="line">        <span class="comment">//一个成员方法，就是一个java.lang.reflect.Method对象,getMethods获取的是所有的public方法，包括继承而来的</span></div><div class="line">        <span class="comment">//getDeclaredMethods获取所有该类自己声明的方法，不问访问权限</span></div><div class="line">        System.out.println(<span class="string">"输出类的方法信息methods:"</span>);</div><div class="line">        Method[] methods = c1.getMethods();</div><div class="line">        c1.getDeclaredMethods();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</div><div class="line">            <span class="comment">//得到方法返回值类型的类类型</span></div><div class="line">            Class returnType = methods[i].getReturnType();</div><div class="line">            System.out.print(returnType.getName() + <span class="string">" "</span>);</div><div class="line">            <span class="comment">//得到方法的名称</span></div><div class="line">            System.out.print(methods[i].getName() + <span class="string">"("</span>);</div><div class="line">            <span class="comment">//获取参数类型,得到参数列表的类型的类类型</span></div><div class="line">            Class[] paramTypes = methods[i].getParameterTypes();</div><div class="line">            <span class="keyword">for</span> (Class c : paramTypes) &#123;</div><div class="line">                System.out.print(c.getName() + <span class="string">","</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">")"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//getFields方法，获取所有的public成员变量信息</span></div><div class="line">        System.out.println(<span class="string">"输出类的成员变量信息fields:"</span>);</div><div class="line">        Field[] fields = c1.getFields();</div><div class="line">        c1.getDeclaredFields();</div><div class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">            Class fieldType = field.getType();</div><div class="line">            <span class="comment">//得到成员变量的名称</span></div><div class="line">            String fieldName = field.getName();</div><div class="line">            <span class="comment">//得到成员变量的类型名称</span></div><div class="line">            String typeName = fieldType.getName();</div><div class="line">            System.out.println(typeName + <span class="string">" "</span> + fieldName);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//getConstructors方法，所有共有</span></div><div class="line">        System.out.println(<span class="string">"输出类的构造函数信息constructor:"</span>);</div><div class="line">        Constructor[] constructors = c1.getConstructors();</div><div class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</div><div class="line">            System.out.print(constructor.getName() + <span class="string">"（"</span>);</div><div class="line">            Class[] paraTypes = constructor.getParameterTypes();</div><div class="line">            <span class="keyword">for</span> (Class c : paraTypes) &#123;</div><div class="line">                System.out.print(c.getSimpleName() + <span class="string">","</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">")"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//        String s = "hello";</span></div><div class="line"><span class="comment">//        printClassMessage(s);</span></div><div class="line">        Integer n1 = <span class="number">1</span>;</div><div class="line">        printClassMessage(n1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/husthang/java-learning/tree/master/java-advanced/src/main/java/com/liuhang/reflection" target="_blank" rel="external">练习代码</a></li>
<li><a href="http://www.imooc.com/learn/199" target="_blank" rel="external">慕课网-反射</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础增强-泛型]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-%E6%B3%9B%E5%9E%8B.html</url>
      <content type="html"><![CDATA[<h1 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h1><ul>
<li>泛型的本质是参数化类型（Parametersized Type）的应用，所操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法的创建中，即泛型类，泛型接口和泛型方法</li>
<li><strong>可读性与安全性</strong>，例如集合中有类型参数，在编译时进行类型检查</li>
<li>没有使用泛型时，只要是对象，不管是什么类型的对象，都可以存储进同一个集合中，使用泛型集合，可以<strong>将一个集合中的元素限定为一个特定类型</strong>，这样集合中就只能存储同一类型的对象，这样更安全；并且当从集合中获取一个对象时，编译器也知道这个对象的类型，<strong>不需要对对象进行强制类型转换</strong>，这样更方便。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.cnblogs.com/xdp-gacl/p/3629723.html" target="_blank" rel="external">泛型总结-孤傲苍狼</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[奇技-hexo总结]]></title>
      <url>http://liuhang.net.cn/%E5%A5%87%E6%8A%80-hexo%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.bootcss.com/p/font-awesome/" target="_blank" rel="external">Font Awesome图标</a></li>
<li><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">next主题配置</a></li>
<li><a href="http://www.ehcoo.com/seo.html" target="_blank" rel="external">hexo搜索引擎优化seo</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础增强-多线程]]></title>
      <url>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h1 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.cnblogs.com/xdp-gacl/p/3633936.html" target="_blank" rel="external">多线程总结一-孤傲苍狼</a></li>
<li><a href="http://www.cnblogs.com/xdp-gacl/p/3634382.html" target="_blank" rel="external">多线程总结二-孤傲苍狼</a></li>
<li><a href="http://blog.csdn.net/jiyiqinlovexx/article/details/50989328" target="_blank" rel="external">volatile理解-此博客推荐！</a></li>
<li><a href="http://blog.psjay.com/posts/summary-of-java-concurrency-two-synchronized-and-atomicity/" target="_blank" rel="external">Java并发总结：同步与原子性-推荐</a></li>
<li><a href="http://www.kancloud.cn/seaboat/java-concurrent/117870" target="_blank" rel="external">CAS算法-乐观锁</a></li>
<li><a href="https://github.com/husthang/java-learning/tree/master/java-advanced/src/main/java/com/liuhang/thread" target="_blank" rel="external">我的练习代码|GitHub</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的博客汇总]]></title>
      <url>http://liuhang.net.cn/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB.html</url>
      <content type="html"><![CDATA[<h1 id="我的博客"><a href="#我的博客" class="headerlink" title="我的博客"></a>我的博客</h1><ul>
<li><a href="https://my.oschina.net/husthang/blog" target="_blank" rel="external">oschina博客</a></li>
<li><a href="http://liuhang.net.cn/">个人网站</a></li>
</ul>
<h1 id="博客分类"><a href="#博客分类" class="headerlink" title="博客分类"></a>博客分类</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Web项目总结-redis总结]]></title>
      <url>http://liuhang.net.cn/Web%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-redis%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a>NoSql</h2><ul>
<li>NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充;</li>
</ul>
<h2 id="NoSql数据库分类"><a href="#NoSql数据库分类" class="headerlink" title="NoSql数据库分类"></a>NoSql数据库分类</h2><ol>
<li>键值(Key-Value)存储数据库: <strong>Redis</strong>、Voldemort、Berkeley DB</li>
<li>列存储数据库：Cassandra, <strong>HBase</strong>, Riak</li>
<li>文档型数据库：CouchDB、<strong>MongoDB</strong></li>
<li>图形(Graph)数据库： Neo4J，InfoGrid</li>
</ol>
<h2 id="Redis简介-1"><a href="#Redis简介-1" class="headerlink" title="Redis简介"></a>Redis简介</h2><ol>
<li>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。支持的键值数据类型包括：字符串类型，散列类型，列表类型，集合类型，有序集合类型。</li>
<li>应用场景<ul>
<li><strong>缓存（数据查询、短连接、新闻内容、商品内容等等）（最多使用）</strong>，缓存还可以用<strong>memcached</strong></li>
<li>分布式集群架构中的session分离。</li>
<li>聊天室的在线好友列表。</li>
<li>任务队列。（秒杀、抢购、12306等等）</li>
<li>应用排行榜。</li>
<li>网站访问统计。</li>
<li>数据过期处理（可以精确到毫秒）</li>
</ul>
</li>
</ol>
<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><ol>
<li>Redis约定次版本号（即第一个小数点后的数字）为偶数的版本是稳定版<br>（如2.4版、2.6版），奇数版本是非稳定版（如2.5版、2.7版）</li>
<li><p>Download, extract and compile Redis with:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-3.2.8.tar.gz</div><div class="line">tar xzf redis-3.2.8.tar.gz</div><div class="line">cd redis-3.2.8</div><div class="line">make</div></pre></td></tr></table></figure>
</li>
<li><p>编译后执行<code>sudo make install</code>,可执行文件会被复制到<code>/usr/local/bin</code>目录内，在命令行内直接输入程序名即可执行；（Redis可执行文件说明见下表）<br><img src="../media/14890418974755.jpg" alt=""></p>
</li>
<li><p>启动</p>
<ul>
<li>直接运行<code>redis-server</code>,Redis服务器默认会使用6379端口，通过–port端口可指定端口号。（注释：6379是手机键盘上MERZ对应的数字，MERZ是一个意大利歌手的名字）;<code>redis-server --port 6380</code></li>
</ul>
</li>
<li>打开命令行客户端<ul>
<li><code>redis-cli</code></li>
</ul>
</li>
<li>停止<ul>
<li><code>redis-cli shutdown</code></li>
</ul>
</li>
</ol>
<h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><ul>
<li>Redis中存储数据是通过key-value存储的，对于value的类型有以下几种：<ul>
<li>字符串</li>
<li>Hash类型</li>
<li>List</li>
<li>Set</li>
<li>SortedSet（zset）</li>
</ul>
</li>
<li>在redis中的命令语句中，命令是忽略大小写的，而key是不忽略大小写的。</li>
</ul>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><ul>
<li>命令用法<ul>
<li>赋值 <code>set key value</code></li>
<li>取制 <code>get key</code></li>
<li>取值赋值（多个） <code>MSET key value [key value …] ; MGET key [key …]</code></li>
<li>取值并赋值 <code>getset key value</code></li>
<li>删除 <code>del key</code></li>
<li>数值增减<ul>
<li>递增 <code>incr key</code>; 增加指定的整数 <code>incrby key increment</code></li>
<li>递减 <code>decr key</code>; 减少指定的整数 <code>decrby key decrement</code><br><img src="../media/14890484914948.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><ul>
<li>散列类型，提供字段和字段值的映射，字段值只能是字符串类型（不可嵌套其他类型）</li>
<li>例如User对象包括username,password,name,age字段，可使用hash解决<br><img src="../media/14890472547872.jpg" alt=""></li>
<li>命令用法<ul>
<li>赋值 <code>hset key filed value</code></li>
<li>取制 <code>hget key filed</code></li>
<li>取值赋值（多个） <code>hmest key filed value [filed value …] ; hmget key  filed [filed]</code></li>
<li>取值并赋值 <code>getset key value</code></li>
<li>删除 <code>hdel key filed [filed...]</code>,删除一个或多个，返回被删除字段个数</li>
</ul>
</li>
</ul>
<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><ul>
<li>列表类型（list）可以存储一个有序的字符串列表，常用的<strong>操作是向列表两端添加元素，或者获得列表的某一个片段</strong>。</li>
<li>列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。</li>
<li>命令用法<ul>
<li>向列表两端增加元素:<code>lpush key value [value]</code>向列表左边添加;<code>rpush key value [value]</code>右边添加</li>
<li>查看列表<code>lrange key start stop</code>,索引从0开始，可以是负数，如-1代表最后边的</li>
<li>从列表两端弹出元素<code>lpop key</code>;<code>rpop key</code>;</li>
<li>获取列表元素个数<code>llen key</code>;<br><img src="../media/14891152268107.jpg" alt=""></li>
</ul>
</li>
</ul>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><ul>
<li>集合中的数据是不重复且没有顺序</li>
<li>与List类型比较</li>
</ul>
<p><img src="../media/14890502770124.jpg" alt=""></p>
<ul>
<li>集合类型的常用操作是<strong>向集合中加入或删除元素</strong>、<strong>判断某个元素是否存在</strong>等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。 Redis还提供了多个集合之间的交集、并集、差集的运算。</li>
<li>常用命令<ul>
<li>增加/删除元素：<code>sadd key member [member...]</code>;<code>srem key memeber [member]</code></li>
<li>获得集合中的所有元素：<code>smembers key</code></li>
<li>判断元素是否在集合中：<code>sismember key member</code></li>
<li>运算命令<ul>
<li>差集（属于A且不属于B的元素集合）<code>sdiff key [key ...]</code></li>
<li>交集 <code>sinter key [key...]</code></li>
<li>并集 <code>sunion key [key...]</code><br><img src="../media/14891164162143.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><ul>
<li>在集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 </li>
<li>在某些方面有序集合和列表类型有些相似。 <ol>
<li>二者都是有序的。 </li>
<li>二者都可以获得某一范围的元素。 </li>
</ol>
</li>
<li>但是，二者有着很大区别： <ol>
<li>列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 </li>
<li>有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 </li>
<li>列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） </li>
<li>有序集合要比列表类型更耗内存。 </li>
</ol>
</li>
<li>命令：<ul>
<li>增加元素：向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。<code>zadd key score member [score member...]</code></li>
<li>获取元素分数 <code>zscore key member</code></li>
<li>删除元素：移除有序集key中的一个或多个成员，不存在的成员将被忽略。当key存在但不是有序集类型时，返回一个错误。<code>zrem key member [member...]</code></li>
<li>获得排名在某个范围的元素列表<ul>
<li>按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素）<code>zrange key start stop [withscores]</code></li>
<li>从大到小 <code>zrevrange key start stop [withscores]</code><br><img src="../media/14891282942094.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://redisdoc.com/" target="_blank" rel="external">Redis 命令参考</a></li>
<li><a href="https://redis.io/download" target="_blank" rel="external">Redis 下载安装</a></li>
<li><a href="http://www.redis.cn/" target="_blank" rel="external">Redis中文网</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础数据结构-二叉树]]></title>
      <url>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>二叉树的前序中序后序三种遍历方法，用递归实现较为容易，在上数据结构的课时，非递归实现会了，但过了一段时间又忘了，每次要写非递归实现的时候都要想好久。这里总结一下，将前序和后序遍历非递归实现方法统一，便于理解记忆！</li>
</ul>
<h2 id="二叉树DFS非递归实现"><a href="#二叉树DFS非递归实现" class="headerlink" title="二叉树DFS非递归实现"></a>二叉树DFS非递归实现</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul>
<li>depth first search:先访问子节点，再访问父节点，最后访问第二个子节点。根据根节点相对于左右子节点的访问先后顺序又可细分为以下三种方式:<ul>
<li>前序(pre-order)：先根后左再右</li>
<li>中序(in-order)：先左后根再右</li>
<li>后序(post-order)：先左后右再根<br><img src="../images/binary_tree_traversal.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="DFS非递归实现"><a href="#DFS非递归实现" class="headerlink" title="DFS非递归实现"></a>DFS非递归实现</h3><h4 id="前序和后序遍历"><a href="#前序和后序遍历" class="headerlink" title="前序和后序遍历"></a>前序和后序遍历</h4><ul>
<li><strong>前序遍历和后序遍历归为一类</strong>,所用思想基本一模一样:</li>
<li>前序遍历的步骤为<ul>
<li>对root进行异常处理</li>
<li>将root压入栈</li>
<li>while循环遍历,终止条件为栈为空，所有元素均已处理完</li>
<li>从栈顶取元素读,取并存入结果</li>
<li>将取出元素的右、左节点分别压入栈内，以便下次循环取元素时为本次节点的左,右子节点.</li>
</ul>
</li>
<li>运用辅助栈,保存遍历到的节点(用栈后入先出的特性,控制已经遍历到的节点的访问顺序). 以前序深度优先遍历为例,先访问根节点,然后访问左树,左树全部访问完了,再访问右树</li>
<li><strong>后续遍历思想</strong>: 左-右-根;<strong>可以视为, 根-右-左,然后结果转置即可</strong>. 如前面示意图,根右左,访问顺序则为:<code>ACFBED</code>;可以看出,这样访问刚好为后续遍历的转置. 根右左访问与前序(根左右)遍历操作思想一模一样</li>
<li><p>前序遍历</p>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="external">leetcode|Binary Tree Preorder Traversal二叉树前序遍历</a></li>
<li><a href="http://www.lintcode.com/en/problem/binary-tree-preorder-traversal/" target="_blank" rel="external">lintcode|Binary Tree Preorder Traversal二叉树前序遍历</a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 前序遍历,迭代法</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">     List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</div><div class="line">     Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">     stack.push(root);</div><div class="line">     <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">         TreeNode node = stack.pop();</div><div class="line">         result.add(node.val);</div><div class="line">         <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right);</div><div class="line">         <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) stack.push(node.left);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>后序遍历</p>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="external">leetcode|Binary Tree Postorder Traversal后序遍历</a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</div><div class="line">        Deque&lt;TreeNode&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        stack.push(root);</div><div class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</div><div class="line">            TreeNode node=stack.pop();</div><div class="line">            result.add(node.val);</div><div class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) stack.push(node.left);</div><div class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) stack.push(node.right);</div><div class="line">        &#125;</div><div class="line">        Collections.reverse(result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul>
<li>中序遍历思路: 中序遍历迭代法思路不同于前序和后序.<ol>
<li>首先针对对当前节点,一直对其左子树迭代并将非空节点入栈</li>
<li>节点指针迭代为空(到树底了)后不再入栈,然后取栈顶元素,存结果;</li>
<li>将当前指针用出栈的节点的右子节点替代,然后回到第一步继续迭代,直到当前节点为空且栈为空.</li>
</ol>
</li>
<li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="external">|leetcodeBinary Tree Inorder Traversal中序遍历</a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</div><div class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (root!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(root);</div><div class="line">                root=root.left;</div><div class="line">            &#125;</div><div class="line">            TreeNode node=stack.pop();</div><div class="line">            result.add(node.val);</div><div class="line">            root=node.right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的定义与性质"><a href="#二叉树的定义与性质" class="headerlink" title="二叉树的定义与性质"></a>二叉树的定义与性质</h2><p><img src="../images/二叉树知识点.png" alt=""></p>
<ol>
<li>二叉树的第i层至多有 2^(i−1) 个结点;</li>
<li>深度为k的二叉树至多有 2^k − 1 个结点;</li>
<li><strong>对任何一棵二叉树T，如果其终端结点数为 n0, 度为2的结点数为 n2, 则 n0 = n2 + 1。</strong></li>
<li>一棵深度为 k, 且有 2^k − 1 个节点称之为<strong>满二叉树</strong>;</li>
<li>深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为<strong>完全二叉树</strong>。完全二叉树中重在节点标号对应,即完全二叉树的叶子结点只能出现在最下层和次下层,最下层的全在树的左部.</li>
<li>具有n个结点的完全二叉树的深度k为<code>(log2n)向下取整+1</code></li>
<li>对于具有n个结点的完全二叉树,从1开始编号(上下左右):<ul>
<li>i&gt;1,则序号为i的结点的父结点序号为<code>i/2</code>(整除);</li>
<li>若2i&lt;=n,则序号为i的结点的左子结点序号为2i; 若2i&gt;n,则结点i无左子结点;</li>
<li>若2i+1&lt;=n,则序号为i的结点的右子节点为2i+1; 若2i+1&gt;n,则无右子节点</li>
<li>若从0开始编号,则i的父节点为(i-1)/2,左子节点为2i+1,右2i+2;</li>
</ul>
</li>
</ol>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ol>
<li>深度优先遍历(DFS)<ul>
<li>前序中序后序三种遍历方式的递归实现</li>
<li>前序中序后序三种遍历方式的非递归实现</li>
<li><a href="http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91.html">三种遍历方法详解总结</a></li>
</ul>
</li>
<li>广度优先遍历(BFS)<ul>
<li>层序遍历</li>
<li>之字形遍历</li>
<li>镜像</li>
</ul>
</li>
<li>OJ链接<ul>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/#/description" target="_blank" rel="external">LeetCode:前序遍历</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/#/description" target="_blank" rel="external">LeetCode:中序遍历</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/#/description" target="_blank" rel="external">LeetCode:后序遍历</a></li>
</ul>
</li>
</ol>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ul>
<li>一颗二叉查找树(BST)是一颗二叉树，其中每个节点都含有一个可进行比较的键及相应的值，且每个节点的<br>键都大于等于左子树中的任意节点的键，而小于右子树中的任意节点的键。</li>
</ul>
<h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h3><ol>
<li><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第23题-二叉搜索树的后序遍历序列</a></li>
</ol>
<h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><ol>
<li><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第26题-二叉搜索树与双向链表</a></li>
</ol>
<h3 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h3><ol>
<li><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第62题-二叉搜索树的第k个结点</a></li>
<li>思路: 用栈对二叉搜索树进行<strong>中序遍历</strong>,搜到第k个结点时跳出</li>
</ol>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><ul>
<li>定义: 如果某二叉树中任意结点的左右子树的深度相差不超过1,那么它就是一颗平衡二叉树</li>
<li>AVL树,自平衡二叉树;<br><img src="../images/AVL.png" alt=""></li>
</ul>
<h3 id="平衡二叉树的判定"><a href="#平衡二叉树的判定" class="headerlink" title="平衡二叉树的判定"></a>平衡二叉树的判定</h3><ol>
<li><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第39题-平衡二叉树</a></li>
<li>思路: 每个结点只遍历一次的解法</li>
</ol>
<h2 id="哈夫曼树-最优二叉树"><a href="#哈夫曼树-最优二叉树" class="headerlink" title="哈夫曼树(最优二叉树)"></a>哈夫曼树(最优二叉树)</h2><h3 id="哈夫曼二叉树的定义及性质"><a href="#哈夫曼二叉树的定义及性质" class="headerlink" title="哈夫曼二叉树的定义及性质"></a>哈夫曼二叉树的定义及性质</h3><ol>
<li>最优二叉树,也称为哈夫曼树:对一组带有权值的叶子结点,构造具有最小带权路径长度的二叉树. 选取权值最小和次小的结点构造.</li>
<li>具有n个叶子节点的哈夫曼树总共有2n-1个结点;</li>
</ol>
<h2 id="其他典型题目"><a href="#其他典型题目" class="headerlink" title="其他典型题目"></a>其他典型题目</h2><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第4题-重建二叉树</a></li>
<li>描述: 由先序和中序遍历序列,重建二叉树</li>
<li>思路:</li>
</ol>
<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><ol>
<li><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第17题-树的子结构</a></li>
<li>思路:</li>
</ol>
<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><ol>
<li><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第18题-二叉树的镜像</a></li>
<li>思路: 对二叉树进行前序遍历,对遍历到的节点,交换其左右子节点(可用递归实现)</li>
</ol>
<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><ol>
<li><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第24题-二叉树中和为某一值的路径</a></li>
<li>思路: 本题重难点!</li>
</ol>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><ol>
<li><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第38题-二叉树的深度</a></li>
<li>思路: 递归;  <strong>思考非递归的方法</strong></li>
</ol>
<h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第58题-对称的二叉树</a></li>
<li>思路: 比较二叉树的前序遍历序列(根左右)和对称前序遍历序列(根右左),用<strong>递归</strong>的方式进行遍历</li>
</ol>
<h3 id="按之字顺序打印二叉树"><a href="#按之字顺序打印二叉树" class="headerlink" title="按之字顺序打印二叉树"></a>按之字顺序打印二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第59题-按之字形顺序打印二叉树</a></li>
<li>思路: 用两个栈存;</li>
</ol>
<h3 id="把二叉树打印成多行-二叉树层序遍历"><a href="#把二叉树打印成多行-二叉树层序遍历" class="headerlink" title="把二叉树打印成多行(二叉树层序遍历)"></a>把二叉树打印成多行(二叉树层序遍历)</h3><ol>
<li><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第60题-把二叉树打印成多行</a></li>
</ol>
<h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第61题-序列化二叉树</a></li>
<li>思路: 前序遍历的递归实现; 注意反序列化如何递归</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring笔记2-spring-IOC]]></title>
      <url>http://liuhang.net.cn/Spring-ioc.html</url>
      <content type="html"><![CDATA[<h1 id="Spring-IOC基础"><a href="#Spring-IOC基础" class="headerlink" title="Spring-IOC基础"></a>Spring-IOC基础</h1><h2 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h2><ol>
<li>基本概念<ul>
<li><strong>控制反转(Inversion of Control)</strong>是一种是面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。实现控制反转主要有两种方式：<strong>依赖注入</strong>和<strong>依赖查找</strong>。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取响应名称的对象，获得依赖对象的时间也可以在代码中自由控制。</li>
<li><strong>依赖注入</strong>就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。</li>
</ul>
</li>
<li>ICO与DI的关系<ul>
<li><strong>依赖注入</strong>是一种设计模式</li>
<li><strong>控制反转</strong>是一种设计原则,一种编程思想.</li>
<li>IoC框架使用依赖注入作为实现控制反转的方式，但是控制反转还有其他的实现方式，比如依赖查找，所以不能将控制反转和依赖注入等同。</li>
</ul>
</li>
<li>Spring中的依赖注入<ul>
<li>Spring依赖注入的两种方式：setter方法注入(setter injection)和构造器注入(constructor injection)</li>
</ul>
</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC#.E5.AE.9E.E7.8E.B0.E6.96.B9.E6.B3.95" target="_blank" rel="external">参考</a></li>
</ol>
<h2 id="Spring中Bean的基本装配"><a href="#Spring中Bean的基本装配" class="headerlink" title="Spring中Bean的基本装配"></a>Spring中Bean的基本装配</h2><ol>
<li>两种注入方式,构造器注入(对应xml c空间),属性的settr方法注入(对应xml p空间)</li>
<li>基于xml装配<ul>
<li>构造器注入: c-命名空间;元素:<code>&lt;constructor-arg ref=&quot;bean-id&quot;/&gt;</code></li>
<li>setter注入: p-命名空间;元素:<code>&lt;property name=&quot;属性名&quot; ref=&quot;bean-id&quot;/&gt;</code></li>
<li>装配集合(此时命名空间无法做到),需用元素</li>
</ul>
</li>
<li><p>基于注解装配</p>
<ul>
<li>Spring3基于注解实现Bean依赖注入支持如下四种注解<ul>
<li>spring自带依赖注入注解： Spring自带的一套依赖注入注解；</li>
<li>JSR-250注解：Java平台的公共注解，是Java EE 5规范之一，在JDK6中默认包含这些注解，从Spring2.5开始支持。</li>
<li>JSR-330注解：Java 依赖注入标准，Java EE 6规范之一，可能在加入到未来JDK版本，从Spring3开始支持；</li>
<li>JPA注解：用于注入持久化上下文和实体管理器。</li>
</ul>
</li>
<li>Spring自带注解<ul>
<li>@Required: 依赖检查,只能放置在setter方法上,要求xml中配置该Bean时必须注入.</li>
<li>@Autowired 自动装配,默认是根据类型注入，可以用于构造器、字段、方法注入(不只settr方法)</li>
<li>@Qualifier 与 Autowired 配合根据名字装配;(还能进行更细粒度的控制)</li>
<li>@Component: 取代<bean class=""> 声明bean, 用在要被自动扫描和装配的类上(类级别)</bean></li>
<li>@Bean, 声明一个single bean, 用法方法上(方法级别)</li>
</ul>
</li>
<li>JSR-250注解<ul>
<li>@Resource：自动装配，默认根据类型装配，如果指定name属性将根据名字装配</li>
</ul>
</li>
<li>SR-330注解<ul>
<li>@Inject：等价于默认的@Autowired</li>
<li>@Name,类似@Component</li>
</ul>
</li>
</ul>
</li>
<li><p>Bean的生命周期</p>
<ul>
<li>流程<ul>
<li><img src="../images/Spring-Bean生命周期.png" alt="Spring-Bean生命周期"></li>
</ul>
</li>
<li><a href="http://www.jianshu.com/p/3944792a5fff" target="_blank" rel="external">参考</a></li>
<li><a href="http://javabeat.net/life-cycle-management-of-a-spring-bean/" target="_blank" rel="external">life cycle</a></li>
<li><a href="https://github.com/husthang/spring-learning/tree/master/spring-ioc" target="_blank" rel="external">Code</a></li>
</ul>
</li>
</ol>
<h2 id="Bean高级装配"><a href="#Bean高级装配" class="headerlink" title="Bean高级装配"></a>Bean高级装配</h2><ol>
<li>Bean的作用域</li>
<li>Spring profile<ul>
<li><a href="http://www.jianshu.com/p/948c303b2253" target="_blank" rel="external">参考</a></li>
</ul>
</li>
<li>条件化的Bean声明</li>
<li>Spring表达式语言(SpEL)</li>
</ol>
<h2 id="示例代码及单元测试"><a href="#示例代码及单元测试" class="headerlink" title="示例代码及单元测试"></a>示例代码及单元测试</h2><ol>
<li>@RunWith注解</li>
<li>@Rule注解</li>
<li>Assert用法</li>
<li>System Rules用法<ul>
<li><a href="http://stefanbirkner.github.io/system-rules/" target="_blank" rel="external">参考</a></li>
</ul>
</li>
<li><a href="https://github.com/husthang/spring-learning/tree/master/spring-ioc" target="_blank" rel="external">代码</a></li>
</ol>
<h1 id="Spirng-IOC深入分析"><a href="#Spirng-IOC深入分析" class="headerlink" title="Spirng-IOC深入分析"></a>Spirng-IOC深入分析</h1><h1 id="IoC容器简单实现"><a href="#IoC容器简单实现" class="headerlink" title="IoC容器简单实现"></a>IoC容器简单实现</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring笔记1-spring入门]]></title>
      <url>http://liuhang.net.cn/Spring-%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<h2 id="Java-EE了解"><a href="#Java-EE了解" class="headerlink" title="Java EE了解"></a>Java EE了解</h2><ol>
<li>Java EE是什么<ul>
<li>学习Java各种框架之前,有必要对Java EE有基本的了解,方便理解各种框架兴起的原因(为什么要用这个框架,而不用JavaEE中相应的东西).</li>
<li>Java平台企业版（Java Platform Enterprise Edition），是Sun公司为企业级应用推出的标准平台.</li>
</ul>
</li>
<li>分层模型<ul>
<li>分层结构图<ul>
<li><img src="../images/Java-EE分层模型.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>组件<ul>
<li>Java EE是一系列技术标准所组成的平台<ul>
<li>Applet - Java Applet</li>
<li>EJB - 企业级JavaBean（Enterprise Java Beans）</li>
<li>JAAS - Java Authentication and Authorization Service</li>
<li>JACC - J2EE Authorization Contract for Containers</li>
<li>JAF - Java Beans Activation Framework</li>
<li>JAX-RPC - Java API for XML-Based Remote Procedure Calls</li>
<li>JAX-WS - Java API for XML Web Services</li>
<li>JAXM - Java API for XML Messaging</li>
<li>JAXP - Java XML解析API（Java API for XML Processing）</li>
<li>JAXR - Java API for XML Registries</li>
<li>JCA - J2EE连接器架构（J2EE Connector Architecture）</li>
<li>JDBC - Java数据库联接（Java Database Connectivity）</li>
<li>JMS - Java消息服务（Java Message Service）</li>
<li>JMX - Java Management</li>
<li>JNDI - Java名称与目录接口（Java Naming and Directory Interface）</li>
<li>JSF - Java Server Faces</li>
<li>JSP - Java服务器页面（Java Server Pages）</li>
<li>JSTL - Java服务器页面标准标签库（Java Server Pages Standard Tag Library）</li>
<li>JTA - Java事务API（Java Transaction API）</li>
<li>JavaMail</li>
<li>Servlet - Java Servlet API</li>
<li>StAX - Streaming APIs for XML Parsers</li>
<li>WS - Web Services</li>
</ul>
</li>
</ul>
</li>
<li>参考<ul>
<li><a href="https://zh.wikipedia.org/zh-cn/Java_EE" target="_blank" rel="external">Java EE维基百科</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j2ee/" target="_blank" rel="external">Java EE简介</a></li>
</ul>
</li>
</ol>
<h2 id="spring框架概述"><a href="#spring框架概述" class="headerlink" title="spring框架概述"></a>spring框架概述</h2><ol>
<li>什么是spring<ul>
<li>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。<strong>Spring的核心是控制反转（IoC）和面向切面（AOP）</strong>。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</li>
<li>分层： 一站式，每一个层都提供的解决方案(如下结构图)<ul>
<li>web层：struts，spring-MVC</li>
<li>service层：spring</li>
<li>dao层：hibernate，mybatis ， jdbcTemplate  –&gt; spring-data</li>
<li><img src="../images/框架体系结构.png" alt="框架体系结构"></li>
</ul>
</li>
</ul>
</li>
<li>spring体系结构<ul>
<li><img src="../images/spring体系图.png" alt="spring体系结构"></li>
<li>容器是spring的核心. Spring容器使用DI(Dependency Inject)管理构成应用的组件,它会创建相互协作的组件之间的关联. Spring自带多个容器实现,可以归为两种类型: bean工厂(由<code>org.springframework.beans.factory.BeanFactory</code>接口定义);应用上下文(由<code>org.springframework.context.ApplicationContext</code>接口定义)基于BeanFactory构建</li>
</ul>
</li>
<li>spring优点<ul>
<li>方便解耦，简化开发  （高内聚低耦合）<ul>
<li>Spring就是一个大工厂（容器），可以将所有对象创建和依赖关系维护，交给Spring管理</li>
<li>spring工厂是用于生成bean</li>
</ul>
</li>
<li>AOP编程的支持<ul>
<li>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能</li>
</ul>
</li>
<li>声明式事务的支持<ul>
<li>只需要通过配置就可以完成对事务的管理，而无需手动编程</li>
</ul>
</li>
<li>方便程序的测试<ul>
<li>Spring对Junit4支持，可以通过注解方便的测试Spring程序</li>
</ul>
</li>
<li>方便集成各种优秀框架<ul>
<li>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持</li>
</ul>
</li>
<li>降低JavaEE API的使用难度<ul>
<li>Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb基础-入门]]></title>
      <url>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<h2 id="JavaWeb基础知识体系"><a href="#JavaWeb基础知识体系" class="headerlink" title="JavaWeb基础知识体系"></a>JavaWeb基础知识体系</h2><p><img src="../images/JavaWeb基础知识体系.png" alt="JavaWeb基础知识体系"></p>
<h2 id="Web容器、服务器的含义和区别"><a href="#Web容器、服务器的含义和区别" class="headerlink" title="Web容器、服务器的含义和区别"></a>Web容器、服务器的含义和区别</h2><ol>
<li><a href="http://aoyouzi.iteye.com/blog/2028611" target="_blank" rel="external">Web容器,服务器理解</a>  博客推荐</li>
<li>容器: 举例说明: Servlet没有main()方法。Servlet受控于另一个Java应用，这个Java应用称为容器.<ul>
<li><a href="http://openhome.cc/Gossip/ServletJSP/Container.html" target="_blank" rel="external">何谓容器</a> ,关于容器的详解</li>
<li>在具体层面,容器实际上是Java应用程序,运行于JVM之上,不同类型的容器负责不同的工作，例如Servlet/JSP所运行的Web容器（Web Container),功能之一就是把JSP代码翻译成java代码</li>
</ul>
</li>
<li>服务器，硬件角度上说就是一台高性能的Computer。我们通常指的服务器其实应该是装有能够处理具体请求事务的服务器软件的Computer</li>
<li>Web服务器是指驻留于因特网上某种类型计算机的程序，是可以向发出请求的浏览器提供文档的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上</li>
<li>Client-Server架构<br><img src="/images/Client-Server.png" alt="Client-Server"></li>
</ol>
<ul>
<li>动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server Plugin（服务器插件）来处理，此插件用于区分是请求的是静态资源(<em>.htm或者是</em>.htm)还是动态资源。</li>
<li>如果WEB Server Plugin发现客户端请求的是静态资源(<em>.htm或者是</em>.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。</li>
<li>如果WEB Server Plugin发现客户端请求的是动态资源（<em>.jsp、</em>.asp/<em>.aspx、</em>.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。</li>
</ul>
<h2 id="Apache、Tomcat与Catalina作为软件名字的含义与关系"><a href="#Apache、Tomcat与Catalina作为软件名字的含义与关系" class="headerlink" title="Apache、Tomcat与Catalina作为软件名字的含义与关系"></a>Apache、Tomcat与Catalina作为软件名字的含义与关系</h2><ol>
<li>JavaWeb中常见这三个词,一直没闹清楚这三个词命名的来源和含义,找到一篇文章总结的不错.<a href="http://blog.csdn.net/yingchengsun/article/details/44340211" target="_blank" rel="external">文章戳这里</a></li>
</ol>
<h2 id="JavaWeb应用的组成结构"><a href="#JavaWeb应用的组成结构" class="headerlink" title="JavaWeb应用的组成结构"></a>JavaWeb应用的组成结构</h2><p><img src="/images/JavaWeb应用组成结构.png" alt="JavaWeb目录结构"></p>
<h2 id="浏览器与服务器的交互过程"><a href="#浏览器与服务器的交互过程" class="headerlink" title="浏览器与服务器的交互过程"></a>浏览器与服务器的交互过程</h2><ol>
<li>URL:统一资源定位符(即网址) uniform resources location<br>URI:统一资源标识符, uniform resource identify<br><a href="http://localhost:8080/doc/1.html" target="_blank" rel="external">http://localhost:8080/doc/1.html</a><br>协议  主机IP(端口号)   URI(当前应用的资源路径)</li>
<li>浏览器与服务器交互过程图<br><img src="/images/浏览器与服务器交互图.png" alt="浏览器与服务器交互过程图"></li>
</ol>
<h2 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h2><ol>
<li><p>Tomcat目录层次结构<br><img src="/images/Tomcat目录层次结构.png" alt="Tomcat目录结构"><br><strong>应学会查看logs日志信息来排查错误</strong></p>
</li>
<li><p>Tomcat体系结构<br><img src="/images/Tomcat体系结构.png" alt="Tomcat体系结构"><br>Tomcat服务器的启动是基于一个server.xml文件的，Tomcat启动的时候首先会启动一个Server，Server里面就会启动Service，Service里面就会启动多个”Connector(连接器)”，每一个连接器都在等待客户机的连接，当有用户使用浏览器去访问服务器上面的web资源时，首先是连接到Connector(连接器)，Connector(连接器)是不处理用户的请求的，而是将用户的请求交给一个Engine(引擎)去处理，Engine(引擎)接收到请求后就会解析用户想要访问的Host，然后将请求交给相应的Host，Host收到请求后就会解析出用户想要访问这个Host下面的哪一个Web应用,一个web应用对应一个Context。</p>
</li>
</ol>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ol>
<li>hypertext transfer protocol（超文本传输协议）</li>
<li>HTTP请求<ul>
<li>一个完整的HTTP请求包括如下内容：一个请求行、若干消息头、以及实体内容<br><img src="/images/httpRequest.png" alt="范例"></li>
<li>第一行请求行 请求方式(get,post) URI  协议版本    </li>
</ul>
</li>
<li>HTTP响应<ul>
<li>状态码<br><img src="/images/状态码.png" alt="状态码"></li>
<li>一个HTTP响应代表服务器向客户端回送的数据，它包括： 一个状态行、若干消息头、以及实体内容 。<br><img src="/images/httpResponse.png" alt="http响应"></li>
</ul>
</li>
</ol>
<h2 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h2><p><a href="http://www.cnblogs.com/xdp-gacl/p/3729033.html" target="_blank" rel="external">JavaWeb开发入门-孤傲苍狼</a>   这篇博客非常值得好好学习一下!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring-ssm框架整合]]></title>
      <url>http://liuhang.net.cn/Spring-ssm%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html</url>
      <content type="html"><![CDATA[<h1 id="框架体系结构"><a href="#框架体系结构" class="headerlink" title="框架体系结构"></a>框架体系结构</h1><ol>
<li><p>框架三层架构<img src="/media/14887819567898.jpg" alt=""></p>
</li>
<li><p>框架的意义与作用</p>
<ul>
<li>所谓框架，就是把一些繁琐的重复性代码封装起来，使程序员在编码中把更多的经历放到业务需求的分析和理解上面。框架封装了很多细节，程序员在使用的时候会非常简单。常用框架有ssh(struts2,spring,hibernate),ssm(springMvc,spring,mybatis)</li>
</ul>
</li>
</ol>
<h1 id="Intellij搭建ssm框架记录"><a href="#Intellij搭建ssm框架记录" class="headerlink" title="Intellij搭建ssm框架记录"></a>Intellij搭建ssm框架记录</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>新建Maven工程，并建立各层的包，如下图<img src="/media/14887846658067.jpg" alt=""></li>
<li>依赖管理，集中定义依赖版本号<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--集中定义依赖版本号--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.1.3.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">jstl.version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">jstl.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">jsp-api.version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">jsp-api.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">mybatis.spring.version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">mybatis.spring.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">mybatis.generator.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">mybatis.generator.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.12<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">jackson.version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">jackson.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">pagehelper.version</span>&gt;</span>4.1.6<span class="tag">&lt;/<span class="name">pagehelper.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">commons-fileupload.version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">commons-fileupload.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">commons-io.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">commons-io.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><ol>
<li><p><strong>依赖配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--Mybatis相关--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--mybatis分页插件--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pagehelper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--数据库连接池--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--Mysql--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>mybatis配置文件</strong>:MybatisConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE configuration</span></div><div class="line">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</div><div class="line">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--配置mybatis分页插件--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageHelper"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>spring配置文件</strong>applicationContext-dao.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></div><div class="line">	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt;</div><div class="line">    <span class="comment">&lt;!--加载配置文件--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:properties/*.properties"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!--数据库连接池--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--配置SqlSessionFactory--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/MybatisConfig.xml"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--扫描mapper接口生成的代理对象放到spring容器中--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.taotao.manager.mapper"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>数据库配置文件dp.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jdbc.driver=com.mysql.jdbc.Driver</div><div class="line">jdbc.url=jdbc:mysql://localhost:3306/taotao?characterEncoding=utf-8</div><div class="line">jdbc.username=liuhang</div><div class="line">jdbc.password=liuhang</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><ol>
<li><p>依赖配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Spring相关 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>spring配置文件：applicationContext-service.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></div><div class="line">	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt;</div><div class="line">    <span class="comment">&lt;!--启用组件扫描，扫描带@service注解的类--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.liuhang.service"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>事物配置文件：applicationContext-transaction.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></div><div class="line">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></div><div class="line">          <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 传播行为 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"create*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"select*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span></span></div><div class="line">                     <span class="attr">pointcut</span>=<span class="string">"execution(* com.liuhang.service.*.*(..))"</span>/&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h2><ol>
<li><p>配置springmvc</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></div><div class="line">	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;</div><div class="line">    <span class="comment">&lt;!--启用注解驱动的mvc组件--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!--包扫描器 扫描@Controller--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.liuhang.controller"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!--配置视图解析器--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 配置静态资源映射：两个*，它表示映射resources/下所有的URL，包括子路径（即接多个/）--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span> <span class="attr">location</span>=<span class="string">"/WEB-INF/js/"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span> <span class="attr">location</span>=<span class="string">"/WEB-INF/css/"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>配置web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></div><div class="line">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</div><div class="line">         <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>ssm-liuhang<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--加载Spring容器--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--配置DispatchServlet--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/springMvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--启动tomcat时就初始化--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>搭建完毕后的目录结构如下：<br><img src="/media/14887877133769.jpg" alt=""></p>
<h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1></li>
</ol>
<ul>
<li><a href="https://github.com/husthang/ssm" target="_blank" rel="external">GitHub|我的ssm模板</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Web项目总结-Nginx总结]]></title>
      <url>http://liuhang.net.cn/Web%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-Nginx%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="What-is-Nginx"><a href="#What-is-Nginx" class="headerlink" title="What is Nginx"></a>What is Nginx</h2><ul>
<li>Nginx(发音：engine X)是一款由俄罗斯程序设计师Igor Sysocy开发的,基于C语言的轻量级的HTTP服务器（相比于Apache、Lighttpd而言），同时是一个高性能的HTTP和反向代理服务器。</li>
</ul>
<h2 id="Nginx-应用场景"><a href="#Nginx-应用场景" class="headerlink" title="Nginx 应用场景"></a>Nginx 应用场景</h2><ul>
<li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li>
<li>虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</li>
<li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</li>
</ul>
<h2 id="Mac下Nginx安装配置相关问题"><a href="#Mac下Nginx安装配置相关问题" class="headerlink" title="Mac下Nginx安装配置相关问题"></a>Mac下Nginx安装配置相关问题</h2><ul>
<li><p>mac下直接用homebrew安装，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew update &amp;&amp; brew install nginx</div></pre></td></tr></table></figure>
</li>
<li><p>跟Linux系统有些不同，在Mac下面Nginx默认监听了8080端口号,若要<strong>改到80端口</strong>（http协议默认端口），输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 下面的1.8.0请根据最新安装版本号对应修改，给nginx足够权限</div><div class="line">sudo chown root:wheel /usr/local/Cellar/nginx/1.8.0/bin/nginx</div><div class="line">sudo chmod u+s /usr/local/Cellar/nginx/1.8.0/bin/nginx</div><div class="line"></div><div class="line"># 用vi编辑器打开nginx配置文件，找到server字段的listen字段并将其值修改为80</div><div class="line">vi /usr/local/etc/nginx/nginx.conf</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Nginx配置解析"><a href="#Nginx配置解析" class="headerlink" title="Nginx配置解析"></a>Nginx配置解析</h2><ul>
<li><p>默认配置文件解析：可以在终端执行 cat /usr/local/etc/nginx/nginx.conf.default 查看默认配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># user字段表明了Nginx服务是由哪个用户哪个群组来负责维护进程的，默认是nobody</span></div><div class="line"><span class="comment"># 查看当前用户命令： whoami</span></div><div class="line">user nobody;</div><div class="line"></div><div class="line"><span class="comment"># worker_processes字段表示Nginx服务占用的内核数量</span></div><div class="line"><span class="comment"># 为了充分利用服务器性能你可以直接写你本机最高内核</span></div><div class="line"><span class="comment"># 查看本机最高内核数量命令： sysctl -n hw.ncpu</span></div><div class="line">worker_processes 4;</div><div class="line"></div><div class="line"><span class="comment"># error_log字段表示Nginx错误日志记录的位置</span></div><div class="line"><span class="comment"># 模式选择：debug/info/notice/warn/error/crit</span></div><div class="line"><span class="comment"># 上面模式从左到右记录的信息从最详细到最少</span></div><div class="line">error_log  /usr/<span class="built_in">local</span>/var/logs/nginx/error.log debug;</div><div class="line"></div><div class="line"><span class="comment"># Nginx执行的进程id,默认配置文件是注释了</span></div><div class="line"><span class="comment"># 如果上面worker_processes的数量大于1那Nginx就会启动多个进程</span></div><div class="line"><span class="comment"># 而发信号的时候需要知道要向哪个进程发信息，不同进程有不同的pid，所以写进文件发信号比较简单</span></div><div class="line"><span class="comment"># 你只需要手动创建，比如我下面的位置： touch /usr/local/var/run/nginx.pid</span></div><div class="line">pid  /usr/<span class="built_in">local</span>/var/run/nginx.pid;</div><div class="line"></div><div class="line">events &#123;</div><div class="line">    <span class="comment"># 每一个worker进程能并发处理的最大连接数</span></div><div class="line">    <span class="comment"># 当作为反向代理服务器，计算公式为： `worker_processes * worker_connections / 4`</span></div><div class="line">    <span class="comment"># 当作为HTTP服务器时，公式是除以2</span></div><div class="line">    worker_connections  2048;</div><div class="line">&#125;</div><div class="line"></div><div class="line">http &#123;</div><div class="line">    <span class="comment"># 关闭错误页面的nginx版本数字，提高安全性</span></div><div class="line">    server_tokens off;</div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line">    <span class="comment"># 日志记录格式，如果关闭了access_log可以注释掉这段</span></div><div class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></div><div class="line">    <span class="comment">#                 '$status $body_bytes_sent "$http_referer" '</span></div><div class="line">    <span class="comment">#                '"$http_user_agent" "$http_x_forwarded_for"';</span></div><div class="line"></div><div class="line">    <span class="comment"># 关闭access_log可以让读取磁盘IO操作更快</span></div><div class="line">    <span class="comment"># 当然如果你在学习的过程中可以打开方便查看Nginx的访问日志</span></div><div class="line">    access_log off;</div><div class="line"></div><div class="line">    sendfile        on;</div><div class="line"></div><div class="line">    <span class="comment"># 在一个数据包里发送所有头文件，而不是一个接一个的发送</span></div><div class="line">    tcp_nopush     on;</div><div class="line"></div><div class="line">    <span class="comment"># 不要缓存</span></div><div class="line">    tcp_nodelay on;</div><div class="line"></div><div class="line">    keepalive_timeout  65;</div><div class="line"></div><div class="line">    gzip  on;</div><div class="line">    client_max_body_size 10m;</div><div class="line">    client_body_buffer_size 128k;</div><div class="line"></div><div class="line">   include /usr/<span class="built_in">local</span>/etc/nginx/sites-enabled/*;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Nginx配置文件结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">events &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    server &#123;</div><div class="line">        ...</div><div class="line">        location xxx &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>举例说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    <span class="comment"># Nginx监听端口号</span></div><div class="line">    listen       80;</div><div class="line">    <span class="comment"># 服务器的名字，默认为localhost，你也可以写成aotu.jd.com，这样子就可以通过aotu.jd.com来访问</span></div><div class="line">    server_name  localhost;</div><div class="line">    <span class="comment"># 代码放置的根目录</span></div><div class="line">    root /var/www/;</div><div class="line">    <span class="comment"># 编码</span></div><div class="line">    charset utf-8;    </div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        <span class="comment"># index字段声明了解析的后缀名的先后顺序</span></div><div class="line">        <span class="comment"># 下面匹配到/的时候默认找找html，再找不到就找htm</span></div><div class="line">        index index.html index.htm;</div><div class="line">        <span class="comment"># 自动索引</span></div><div class="line">        autoindex on;</div><div class="line"></div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><h2 id="Nginx配置反向代理"><a href="#Nginx配置反向代理" class="headerlink" title="Nginx配置反向代理"></a>Nginx配置反向代理</h2><ul>
<li>如下配置，访问tomcat.taotao.com时，分别轮流的访问8080和8081两个tomcat，配置tomcat集群<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">upstream tomcats&#123;</div><div class="line">	server 192.168.25.148:8080;</div><div class="line">	server 192.168.25.148:8081;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  tomcat.taotao.com;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass   http://tomcats;</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Nginx配置负载均衡"><a href="#Nginx配置负载均衡" class="headerlink" title="Nginx配置负载均衡"></a>Nginx配置负载均衡</h2><ul>
<li>如下，upstream的server后面添加一个weight即可代表权重。权重越高，分配请求的数量就越多。默认权重是1<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">upstream tomcats&#123;</div><div class="line">	server 192.168.25.148:8080 weight=2;</div><div class="line">	server 192.168.25.148:8081;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  tomcat.taotao.com;</div><div class="line"></div><div class="line">        <span class="comment">#charset koi8-r;</span></div><div class="line"></div><div class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass   http://tomcats;</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="反向代理理解"><a href="#反向代理理解" class="headerlink" title="反向代理理解"></a>反向代理理解</h2><ul>
<li><strong>正向代理</strong>就是<strong>代理服务器替代访问方【用户A】去访问目标服务器【服务器B】</strong>，在现实中的例子就是『翻墙』，通过代理服务器去访问真实想访问的，代理服务器为一堆客户做代理；目标服务器不知道真实的客户端是谁。</li>
<li><strong>反向代理</strong>，用户去访问的时候，不知道真正访问的是哪一台服务器，就跟打10086一样，只管拨通10086，不管那边是哪个服务人员；<strong>为服务器做代理</strong>；</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Web项目总结-Fastdfs总结]]></title>
      <url>http://liuhang.net.cn/Web%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-Fastdfs%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="FastDFS介绍"><a href="#FastDFS介绍" class="headerlink" title="FastDFS介绍"></a>FastDFS介绍</h1><h2 id="什么是FastDFS"><a href="#什么是FastDFS" class="headerlink" title="什么是FastDFS"></a>什么是FastDFS</h2><ul>
<li>FastDFS是一款用c语言编写的开源的、分布式文件系统，由淘宝开发平台部资深架构师余庆开发。FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</li>
</ul>
<h2 id="FastDFS架构"><a href="#FastDFS架构" class="headerlink" title="FastDFS架构"></a>FastDFS架构</h2><ul>
<li>Tracker server是FastDFS的协调者，负责管理所有的storage server和group，每个storage在启动后会连接Tracker，告知自己所属的group等信息；</li>
<li>Storage server以组（group）为单位组织，一个group内包含多台storage机器，数据互为备份</li>
<li><img src="/media/14887163155946.jpg" alt=""></li>
</ul>
<h2 id="文件上传流程"><a href="#文件上传流程" class="headerlink" title="文件上传流程"></a>文件上传流程</h2><ul>
<li><img src="/media/14887165375824.jpg" alt="文件上传流程"></li>
</ul>
<h2 id="文件下载流程"><a href="#文件下载流程" class="headerlink" title="文件下载流程"></a>文件下载流程</h2><ul>
<li><img src="/media/14887165496609.jpg" alt="文件下载流程"></li>
</ul>
<h2 id="上传的文件名"><a href="#上传的文件名" class="headerlink" title="上传的文件名"></a>上传的文件名</h2><ul>
<li><img src="/media/14887169687396.jpg" alt=""></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/happyfish100/fastdfs" target="_blank" rel="external">FastDFS源码</a></li>
<li><a href="http://tech.uc.cn/?p=221" target="_blank" rel="external">FastDFS原理介绍</a></li>
</ul>
<h1 id="Ubuntu-14-04下部署FastDFS-5-08-Nginx-1-8-1"><a href="#Ubuntu-14-04下部署FastDFS-5-08-Nginx-1-8-1" class="headerlink" title="Ubuntu 14.04下部署FastDFS 5.08+Nginx 1.8.1"></a>Ubuntu 14.04下部署FastDFS 5.08+Nginx 1.8.1</h1><h2 id="完全配置过程"><a href="#完全配置过程" class="headerlink" title="完全配置过程"></a>完全配置过程</h2><ul>
<li>mac环境下，建议安装一个linux虚拟机进行配置，直接osx中配置，可能出现一些莫名的错误；VirtualBox安装Ubuntu 14.04虚拟机；配置过程略复杂，详情步骤参考下面的链接！(有时间我重新配置一篇，再贴出详细截图)</li>
</ul>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.linuxidc.com/Linux/2016-07/133485.htm" target="_blank" rel="external">Ubuntu 14.04下部署FastDFS 5.08+Nginx 1.9.14</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[奇技-Intellij IDEA总结]]></title>
      <url>http://liuhang.net.cn/%E5%A5%87%E6%8A%80-Intellij-IDEA%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="快捷键篇"><a href="#快捷键篇" class="headerlink" title="快捷键篇"></a>快捷键篇</h2><p>⌘ Command<br>⇧ Shift<br>⌥ Option<br>⌃ Control<br>↩︎ Return/Enter<br>⌫ Delete<br>⌦ 向前删除键（Fn+Delete）<br>↑ 上箭头<br>↓ 下箭头<br>← 左箭头<br>→ 右箭头<br>⇞ Page Up（Fn+↑）<br>⇟ Page Down（Fn+↓）<br>Home Fn + ←<br>End Fn + →<br>⇥ 右制表符（Tab键）<br>⇤ 左制表符（Shift+Tab）<br>⎋ Escape (Esc)</p>
<ul>
<li><a href="https://github.com/husthang/IntelliJ-IDEA-Tutorial/blob/newMaster/keymap-mac-introduce.md" target="_blank" rel="external">IntelliJ IDEA For Mac 快捷键</a></li>
<li>command+D 复制当前行到下一行</li>
<li>command+X 剪切当前行</li>
<li>Fn+ ← home</li>
<li>Fn+ → end</li>
<li>command+B go to Declaration</li>
<li>⌘⇧↩ 自动结束代码，行末自动添加分号</li>
</ul>
<h2 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h2><ol>
<li>Jrebel<ul>
<li>激活: <a href="http://jingyan.baidu.com/article/647f01159d32e77f2048a85d.html" target="_blank" rel="external">免费激活</a> 要绑定Facebook或者Twitter</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/husthang/IntelliJ-IDEA-Tutorial" target="_blank" rel="external">IDEA教程</a></li>
<li><a href="https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F" target="_blank" rel="external">Intellij学生授权</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[奇技-chrome总结]]></title>
      <url>http://liuhang.net.cn/%E5%A5%87%E6%8A%80-chrome%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="快捷键篇"><a href="#快捷键篇" class="headerlink" title="快捷键篇"></a>快捷键篇</h2><ol>
<li>参考<a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans" target="_blank" rel="external">Chrome 键盘快捷键-mac</a></li>
<li>个人常用<ul>
<li>打开新窗口    ⌘ + n</li>
<li>打开新的标签页，并跳转到该标签页    ⌘ + t</li>
<li>关闭当前标签页或弹出式窗口    ⌘ + w</li>
<li>退出 Google Chrome     ⌘ + q</li>
<li>打开“开发者工具”    ⌘ + Option + i</li>
<li>重新加载当前网页     ⌘ + r</li>
<li>开启或关闭全屏模式    ⌘ + Ctrl + f</li>
<li>跳转到地址栏    ⌘ + l</li>
</ul>
</li>
</ol>
<h2 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h2><ol>
<li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="external">Octotree</a><br>Github查看代码神器，强烈推荐！！</li>
<li><a href="https://chrome.google.com/webstore/detail/evernote-web-clipper/pioclpoplcdbaefihamjohnefbikjilc/related?utm_source=chrome-ntp-icon" target="_blank" rel="external">印象笔记剪藏</a>，查资料时做笔记的神器 </li>
<li><a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?utm_source=chrome-ntp-icon" target="_blank" rel="external">postman</a>，java web后端开发必备</li>
</ol>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol>
<li>chrome浏览器,地址栏搜索出现:无法访问,连接已经重置,与hosts文件无关<br> 用搜索框搜索出现链接重置,问题无关 hosts，在于链接是http方式访问。搜索框输入 chrome://net-internals/#hsts<br> 在 Input a domain name to add it to the HSTS set: 这一行下面的 Domain: [ ]<br> 输入 www.google.com.hk 点 Add这个方法可以让 Chrome 访问 www.google.com.hk 时，强制选择 https 方式<br> <a href="https://github.com/racaljk/hosts/issues/387" target="_blank" rel="external">参考</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[奇技-Git总结]]></title>
      <url>http://liuhang.net.cn/%E5%A5%87%E6%8A%80-Git%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="GitHub团队合作"><a href="#GitHub团队合作" class="headerlink" title="GitHub团队合作"></a>GitHub团队合作</h1><ol>
<li><a href="https://code.tutsplus.com/articles/team-collaboration-with-github--net-29876" target="_blank" rel="external">Team Collaboration With GitHub</a><br> <a href="http://xiaocong.github.io/blog/2013/03/20/team-collaboration-with-github/" target="_blank" rel="external">中文翻译在这</a></li>
<li><a href="http://jinlong.github.io/2015/10/12/syncing-a-fork/" target="_blank" rel="external">如何同步 Github fork 出来的分支</a>    </li>
</ol>
<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="add-commit"><a href="#add-commit" class="headerlink" title="add,commit"></a>add,commit</h2><ul>
<li><code>git log</code>,<code>git log --pretty=oneline</code>只显示一行</li>
<li><code>git add &lt;file&gt;</code> <code>git commit -m &quot;...&quot;</code></li>
<li>commit id: 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来,SHA-1散列</li>
<li>commit: 每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。提交一个commit快照,就相当于保存了一次版本</li>
<li>所有的版本控制系统，只能跟踪纯文本文件的改动，比如TXT文件，网页，所有的程序代码等等. 二进制文件(如图片,视频等)可以管理,但不能跟踪改动.</li>
</ul>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul>
<li>版本回退:在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，往上100个版本可以写成<code>HEAD~100</code>。 <code>git reset --hard HEAD^</code>退回到上一个版本(即这时文件的内容与结构和上次的commit时的一样了). <code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本</li>
<li>总结<ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset commit_id</code>,不指定参数,则默认soft。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。<code>git log --pretty=oneline</code>,显示简洁版日志</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
</li>
</ul>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><ul>
<li><img src="../images/工作区暂存区示意图.jpeg" alt="示意图"></li>
<li><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支</li>
</ul>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ul>
<li><code>git diff HEAD -- file</code>查看工作区和版本库里面最新版本的区别</li>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。<strong>此命令含义,从index暂存区,检出此文件更新工作区</strong></li>
<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>(<strong>reset直接跟文件,默认mixed</strong>,这个命令的全部是: <code>git reset --mixed HEAD file</code>含义是将file从HEAD版本复制到暂存区),这个命令让暂存区恢复,然后只需要丢弃工作区的修改即可,这就回到了场景1，从暂存区检出此文件. <strong>此场景方法二</strong>: 直接一步到位<code>git checkout HEAD -- file</code>同时撤销本地和暂存区修改.</li>
</ul>
<h2 id="重置解密"><a href="#重置解密" class="headerlink" title="重置解密"></a>重置解密</h2><ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86#_git_reset" target="_blank" rel="external">reset与checkout</a></li>
<li>reset<ul>
<li><img src="../images/reset-soft.png" alt="`git reset --soft HEAD~`"></li>
<li><img src="../images/reset-mixed.png" alt="`git reset --mixed HEAD~`"></li>
<li><img src="../images/reset-hard.png" alt="`git reset --hard HEAD~`"></li>
</ul>
</li>
<li><code>checkout</code>:<code>git checkout [tree-ish] -- file</code><ul>
<li>如果不指定commit,则默认从index暂存区的内容覆盖本地修改</li>
<li>如果指定了commit,从commit版本复制出来更新index索引和工作区的修改.<a href="http://cnblog.me/2015/08/15/git-checkout/" target="_blank" rel="external">参考</a></li>
</ul>
</li>
</ul>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><ul>
<li>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</li>
<li>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001376951758572072ce1dc172b4178b910d31bc7521ee4000" target="_blank" rel="external">参考</a></li>
</ul>
<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><ul>
<li>文件 .gitignore 的格式规范如下：<ul>
<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
</li>
<li>.gitignore文件 <a href="https://github.com/github/gitignore" target="_blank" rel="external">.gitignore模板</a></li>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#忽略文件" target="_blank" rel="external">参考</a></li>
</ul>
<h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><ul>
<li>命令<ul>
<li>查看分支：git branch</li>
<li>创建分支：git branch <name></name></li>
<li>切换分支：git checkout <name></name></li>
<li>创建+切换分支：git checkout -b <name></name></li>
<li>合并某分支到当前分支：git merge <name></name></li>
<li>删除分支：git branch -d <name></name></li>
</ul>
</li>
<li>HEAD<ul>
<li>在Git中，HEAD是一个指针，指向版本库中当前所在的本地分支(将 HEAD 想象为当前分支的别名)</li>
</ul>
</li>
<li>远程分支<ul>
<li>以<code>(remote)/(branch)</code>形式命名,远程分支与远程仓库通信时会自动移动.</li>
<li><code>git fetch origin</code> 拉取远程仓库,并移动远程分支,<strong>注意</strong><code>git pull</code>命令比较”魔法”,不推荐使用,应显示的使用<code>git fetch</code>与<code>git merge</code>.</li>
<li><code>git push (remote) (branch)</code>把本地branch分支,推送到远程remote.详细:<code>git push origin serverfix:serverfix</code>，含义“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix分支”</li>
</ul>
</li>
<li>参考<ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B" target="_blank" rel="external">GitBook分支</a></li>
</ul>
</li>
</ul>
<h2 id="换行符配置"><a href="#换行符配置" class="headerlink" title="换行符配置"></a>换行符配置</h2><ol>
<li>core.autocrlf<ul>
<li>如果你在windows系统上，设置为true,提交时crlf转换为lf，检出时lf转换为crlf<code>git config --global core.autocrlf true</code></li>
<li>如果你在linux或mac系统上，设置为input，提交时crlf转换为lf，检出时不转换<code>git config --global core.autocrlf input</code></li>
<li>仅仅在windows开发，则设置为false。取消转换功能</li>
</ul>
</li>
<li>core.safecrlf<ul>
<li><code>git config --global core.safecrlf true(false/ware)</code>是否能提交混合换行符的文件<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1></li>
</ul>
</li>
<li>git GUI推荐:<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[奇技-mac总结]]></title>
      <url>http://liuhang.net.cn/%E5%A5%87%E6%8A%80-mac%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>参考<a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="external">Mac 键盘快捷键</a></li>
<li>修饰键图标<br>Command ⌘<br>Shift ⇧<br>Option ⌥<br>Control ⌃<br>Caps Lock ⇪<br>Fn</li>
<li>个人常用快捷键<ul>
<li>Option-Command-V    移动：将剪贴板中的文件从其原始位置移动到当前位置。</li>
<li>Command–空格键    Spotlight</li>
<li>Command-M    将最前面的窗口最小化至 Dock。</li>
<li>control +command+f 窗口最大化(退出最大化)切换</li>
</ul>
</li>
</ol>
<h2 id="软件推荐"><a href="#软件推荐" class="headerlink" title="软件推荐"></a>软件推荐</h2><ol>
<li>数据库管理：<a href="https://www.sequelpro.com/" target="_blank" rel="external">Sequle Pro</a></li>
<li>Git GUI：<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a></li>
<li>FTP客户端：<a href="https://www.filezilla.cn/" target="_blank" rel="external">FileZilla</a></li>
<li>虚拟机：<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">VirtualBox</a>,<a href="http://www.parallels.com/cn/products/desktop/" target="_blank" rel="external">Parallels Desktop for Mac</a>,VirtualBox免费，也比较好用，装Ubuntu等没有压力。</li>
<li>SwitchHosts: <a href="https://oldj.github.io/SwitchHosts/" target="_blank" rel="external">快速切换hosts文件工具</a>，强烈推荐，<strong>方便翻墙，web开发</strong>，<a href="https://laod.cn/hosts/2017-google-hosts.html" target="_blank" rel="external">hosts更新网站</a></li>
<li>PDF阅读编辑：<a href="http://skim-app.sourceforge.net/" target="_blank" rel="external">Skim</a></li>
<li>文本编辑器：<a href="https://atom.io/" target="_blank" rel="external">Atom</a>，markdown编辑神器，GitHub官方推荐</li>
<li>Synergy 实现Windows与Mac OSX之间共享一套键鼠: <a href="http://www.jianshu.com/p/c4b538d2152e" target="_blank" rel="external">Synergy</a></li>
<li>邮件客户端: <a href="http://www.yomail.com/" target="_blank" rel="external">YoMail</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM-虚拟机类加载机制]]></title>
      <url>http://liuhang.net.cn/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>“代码编译的结果是从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步”</li>
<li>“write once, run anywhere”-字节码技术的关键。</li>
<li>Java虚拟机接收的是有效的Class文件，任何一种语言，只要可以编译成Class文件，即可在虚拟机上运行。</li>
</ul>
<h1 id="Java源码的编译机制（类文件结构）"><a href="#Java源码的编译机制（类文件结构）" class="headerlink" title="Java源码的编译机制（类文件结构）"></a>Java源码的编译机制（类文件结构）</h1><ol>
<li>javac将java源码编译为class文件步骤<br><img src="../images/javac.png" alt=""></li>
</ol>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p><img src="../images/类加载过程.png" alt=""></p>
<h2 id="装载-Load"><a href="#装载-Load" class="headerlink" title="装载(Load)"></a>装载(Load)</h2><ol>
<li>装载阶段，JVM完成三件事情<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（获取不一定要从文件，还可以是zip,网络，运行时计算生成动态代理技术）</li>
<li>将字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口(反射机制)（Hotspot这个对象存放在方法区）</li>
</ul>
</li>
<li>数组类本身不通过类加载器创建，由Java虚拟机直接创建。</li>
</ol>
<h2 id="链接（Link）"><a href="#链接（Link）" class="headerlink" title="链接（Link）"></a>链接（Link）</h2><ol>
<li>校验： 确认Class文件中字节流信息符合虚拟机要求，不会危害虚拟机自身安全。</li>
<li>准备: 准备阶段是正式为类变量（被static修饰的变量）分配内存并设置类变量初始值的阶段。（设置为默认初始值，但在初始化阶段赋值为给定的值）</li>
<li>解析： 虚拟机将常量池中的符号引用替换为直接引用</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol>
<li>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程：类变量赋值，静态语句块（static{}）执行</li>
<li>以下情况初始化过程会被触发执行<ul>
<li>调用了new</li>
<li>反射java.lang.reflect调用了类方法</li>
<li>子类调用了初始化</li>
<li>jVM启动时，执行指定的主类（含main()方法的类）</li>
</ul>
</li>
<li>在执行初始化过程之前，首先必须完成链接过程中的校验和准备阶段，解析阶段不强制。 </li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="../images/classloader.png" alt=""></p>
<ol>
<li>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为“类加载器”。</li>
<li>从虚拟机的角度，只存在两种不同的类加载器：启动类加载器(bootstrap classloader)，c++实现；其他所有的类加载器，都由java实现，全继承自抽象类java.lang.ClassLoader。<ul>
<li>启动类加载器 bootstrap classloader,java_home/jre/lib/rt.jar</li>
<li>扩展类加载器，extension classloader.加载jre/lib/ext/*.jar</li>
<li>应用程序类加载器，application classloader： 加载启动参数中Classpath中的</li>
<li>自定义类加载器，其父加载器默认为application classloader.</li>
</ul>
</li>
<li>双亲委派模型<ul>
<li>对于任意一个类，都需要由加载它的类加载器和这个类本身一通确立其在Java虚拟机中的唯一性。</li>
<li>双亲委派模型工作过程： 一个类加载器收到了类加载请求，首先不会自己尝试加载这个类，委派父类加载，只有当父类反馈无法加载（搜索范围中没有这个类）时，子加载器自己尝试加载。</li>
</ul>
</li>
</ol>
<h1 id="类执行机制（虚拟机字节码执行引擎）"><a href="#类执行机制（虚拟机字节码执行引擎）" class="headerlink" title="类执行机制（虚拟机字节码执行引擎）"></a>类执行机制（虚拟机字节码执行引擎）</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>执行引擎在执行Java代码的时候可能会用解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）</li>
</ul>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式2-简单工厂模式]]></title>
      <url>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><ul>
<li>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于<strong>类创建型模式</strong>（同属于创建型模式的还有工厂方法模式，抽象工厂模式，单例模式，建造者模式）。在简单工厂模式中，可以<strong>根据参数的不同返回不同类的实例</strong>。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li>
</ul>
<h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><p><img src="/media/14873386849094.png" alt=""></p>
<ul>
<li>从上图可以看出，简单工厂模式由三部分组成：具体工厂、具体产品和抽象产品。<ul>
<li>工厂类（Creator）角色：担任这个角色的是简单工厂模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体Java类实现。</li>
<li>抽象产品（AbstractProduct）角色：担任这个角色的类是由简单工厂模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个Java接口或者Java抽象类实现。</li>
<li>具体产品（ConcreteProduct）角色：简单工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。</li>
</ul>
</li>
</ul>
<h2 id="三、模式动机"><a href="#三、模式动机" class="headerlink" title="三、模式动机"></a>三、模式动机</h2><ul>
<li>使用简单工厂模式可以将产品的“消费”和生产完全分开，客户端只需要知道自己需要什么产品，如何来使用产品就可以了，具体的产品生产任务由具体的工厂类来实现。工厂类根据传进来的参数生产具体的产品供消费者使用。这种模式使得更加利于扩展，当有新的产品加入时仅仅需要在工厂中加入新产品的构造就可以了。</li>
</ul>
<h2 id="四、实例分析"><a href="#四、实例分析" class="headerlink" title="四、实例分析"></a>四、实例分析</h2><ul>
<li>话说有一位土豪，他家有三辆汽车——Benz奔驰、Bmw宝马、Audi奥迪，还雇了司机为他开车。不过，土豪坐车时总是怪怪的：上Benz车后跟司机说“开奔驰车！”坐上Bmw后他说“开宝马车！”，坐上Audi说“开奥迪车！”。你一定说：这人有病！直接说开车不就行了？！ 而当把土豪的行为放到我们程序设计中来时，会发现这是一个普遍存在的现象。幸运的是，这种有病的现象在OO（面向对象）语言中可以避免了。下面就以Java语言为例来讲解一下如何避免这种问题。</li>
<li>实例代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.liuhang.factoryModel;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/2/17.</div><div class="line"> * 汽车抽象类,所有汽车类的父类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.liuhang.factoryModel;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/2/17.</div><div class="line"> * Audi奥迪类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Audi</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Create an Audi"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Audi start engine"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.liuhang.factoryModel;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/2/17.</div><div class="line"> * Car工厂类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String type)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"Audi"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Audi();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"Bmw"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Bmw();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"Benz"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Benz();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.liuhang.factoryModel;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/2/17.</div><div class="line"> * 测试简单工厂模式</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyFactoryModelTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEasyFactoryModel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Car car = Driver.getCar(<span class="string">"Benz"</span>);</div><div class="line">        car.drive();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从这个实例的实现中,我们可以看到,土豪不需要自己new汽车对象，而是告诉Driver类今天我想要开什么车，Driver就会自动的将想要的汽车创建出来，然后土豪坐在车里只需要说开车就好了，这与我们现实中的逻辑相符合.Driver类就是我们说的工厂，他用if-else语句来判断需要创建什么类型的对象（当然也可以使用switch语句），这就是<strong>简单工厂模式</strong>。</li>
</ul>
<h2 id="五、模式优点"><a href="#五、模式优点" class="headerlink" title="五、模式优点"></a>五、模式优点</h2><ul>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
<li>当需要引入新的产品是不需要修改客户端的代码，只需要添加相应的产品类并修改工厂类就可以了，所以说从产品的角度上简单工厂模式是符合“开-闭”原则的。</li>
</ul>
<h2 id="六、模式缺点"><a href="#六、模式缺点" class="headerlink" title="六、模式缺点"></a>六、模式缺点</h2><ul>
<li>由于工厂类集中了所有产品创建逻辑，工厂类一般被我们称作“全能类”或者“<strong>上帝类</strong>”，因为所有的产品创建他都能完成，这看似是好事，但仔细想想是有问题的。比如全国上下所有的事情都有国家主义一个人干会不会有问题，当然有！一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。所以说从工厂的角度来说简单工厂模式是不符合“开-闭”原则的。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<h2 id="七、适用场景"><a href="#七、适用场景" class="headerlink" title="七、适用场景"></a>七、适用场景</h2><ul>
<li>在以下情况下可以使用简单工厂模式：<ol>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ol>
</li>
</ul>
<h2 id="八、简单工厂模式在JDK中的应用"><a href="#八、简单工厂模式在JDK中的应用" class="headerlink" title="八、简单工厂模式在JDK中的应用"></a>八、简单工厂模式在JDK中的应用</h2><ul>
<li>JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style,Locale locale)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><ol>
<li><a href="http://www.kancloud.cn/digest/xing-designpattern/143722" target="_blank" rel="external">写最好的设计模式专栏</a></li>
<li><a href="https://github.com/husthang/java-learning/tree/master/java-advanced/src/main/java/com/liuhang/factoryModel" target="_blank" rel="external">我的代码|GitHub</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux总结]]></title>
      <url>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="linux文件属性与权限"><a href="#linux文件属性与权限" class="headerlink" title="linux文件属性与权限"></a>linux文件属性与权限</h1><ol>
<li><p>文件属性和权限<br> <img src="../media/14886281048094.gif" alt=""><img src="../media/14886281421383.gif" alt=""></p>
</li>
<li><p>文件属性与权限的更改</p>
<ul>
<li><code>chgrp</code>：改变文件用户组</li>
<li><code>chown</code>：改变文件所有者</li>
<li><code>chmod</code> ：改变文件权限，rwx对应数字4，2，1</li>
</ul>
</li>
<li>文件类型<ul>
<li>任何设备在Linux中都是文件</li>
</ul>
</li>
<li>参考：<a href="http://cn.linux.vbird.org/linux_basic/0210filepermission.php" target="_blank" rel="external">文件权限</a></li>
</ol>
<h1 id="linux文件与目录管理"><a href="#linux文件与目录管理" class="headerlink" title="linux文件与目录管理"></a>linux文件与目录管理</h1><h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><ol>
<li>目录相关操作<ul>
<li><code>.</code>：此层目录</li>
<li><code>..</code>：上层目录</li>
<li><code>-</code>：代表前一个工作目录</li>
<li><code>~</code>：代表目前用户所在的文件夹</li>
<li><code>cd</code>： change directory</li>
<li><code>mkdir</code>： make directory</li>
<li><code>pwd</code>：print working directory</li>
<li><code>rmdir</code>： 删除空目录</li>
</ul>
</li>
<li>查看文件与目录<ul>
<li>ls<ul>
<li><code>-a</code>：常用，列出全部，包括隐藏</li>
<li><code>-l</code>：常用，列出详细信息， <code>ll</code>缩写</li>
</ul>
</li>
</ul>
</li>
<li>复制、移动与删除： <code>cp,rm,mv</code><ul>
<li><code>cp</code>： 复制文件或目录<ul>
<li><code>-r</code>，递归复制，用于目录的复制行为（常用）</li>
</ul>
</li>
<li><code>rm</code>： remove,移除文件或者目录<ul>
<li><code>rm [-fir] 文件或目录</code>，f强制，i删除前询问，r递归（用于目录删除）</li>
</ul>
</li>
<li><code>mv</code>：移动文件与目录，或更名</li>
</ul>
</li>
<li>取得路径的文件名与目录名称<ul>
<li><code>basename</code>：取得最后的文件名</li>
<li><code>dirname</code>：取得目录名</li>
</ul>
</li>
</ol>
<h2 id="文件内容查询"><a href="#文件内容查询" class="headerlink" title="文件内容查询"></a>文件内容查询</h2><ol>
<li><code>cat</code>：从第一行显示文件内容</li>
<li><code>tac</code>：cat的倒写，从最后一行显示文件内容</li>
<li><code>head</code>：<code>head [-n number] file</code>，只看头几行</li>
<li><code>tail</code>：只看结尾几行</li>
<li><code>nl</code>：显示的时候，输出行号</li>
<li><code>touch</code>：创建新文件或修改文件更新时间</li>
<li><code>file</code>： 查看文件类型</li>
</ol>
<h2 id="命令与文件查询"><a href="#命令与文件查询" class="headerlink" title="命令与文件查询"></a>命令与文件查询</h2><ol>
<li>脚本文件名的查询<ul>
<li><code>which</code>：寻找执行文件，根据PATH路径寻找，例如<code>which ifconfig</code>,<code>which cd</code></li>
</ul>
</li>
<li>文件名的查找<ul>
<li><code>whereis</code>：寻找特定文件</li>
<li><code>locate</code>：后面跟文件的步伐名称</li>
<li><code>find</code>：<ul>
<li>find命令具体使用见：<a href="http://man.linuxde.net/find" target="_blank" rel="external">find命令用法</a></li>
<li>将当前目录下所有文件转为unix类型： <code>find . -type f | xargs dos2unix</code>;</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h2><ol>
<li>压缩<ul>
<li><code>tar -zcvf log.tar.gz a.log</code>,-c 创建</li>
</ul>
</li>
<li>解压<ul>
<li><code>tar -zxvf log.tar.gz</code>，-x extract 欢迎</li>
</ul>
</li>
</ol>
<h1 id="vim基本使用"><a href="#vim基本使用" class="headerlink" title="vim基本使用"></a>vim基本使用</h1><ol>
<li>i → Insert 模式，按 ESC 回到 Normal 模式.</li>
<li>:wq → 存盘 + 退出 (:w 存盘, :q 退出)</li>
<li>hjkl移动光标(←↓↑→).</li>
<li>命令模式下，输入<code>/关键字</code>，查询关键字</li>
<li>q! → 退出不保存</li>
</ol>
<h1 id="shell-script"><a href="#shell-script" class="headerlink" title="shell script"></a>shell script</h1><ol>
<li>管道命令 <code>|</code></li>
<li>参数代换 <code>xargs</code>,有的命令不支持管道命令<ul>
<li><code>find . -type f | xargs dos2unix</code>，将当期目录下所有文件转化为unix类型;</li>
</ul>
</li>
<li><p>条件判断： if..then</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if [条件判断试]</div><div class="line">then</div><div class="line">fi #反过来写表示结束</div></pre></td></tr></table></figure>
</li>
<li><p>默认变量（<code>$0</code>,<code>$1</code>…）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/path/scriptname opt1 opt2 opt3</div><div class="line">     $0          $1</div></pre></td></tr></table></figure>
<ul>
<li><code>$0</code> 表示脚本本身文件名，脚本传入的参数为<code>$1,$2...</code></li>
</ul>
</li>
</ol>
<h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h1><ol>
<li><code>su</code>:switch user 切换用户</li>
<li><code>sudo</code>:superuser do,在不需要知晓root密码的情况下，执行root权限的命令操作</li>
<li><code>ps</code>,查看进程，<code>ps aux</code> 查看所有进程,<code>ps aux|grep java</code> 查看java进程</li>
<li><code>kill</code>,关进程</li>
<li><code>dos2unix</code>,dos类型文件转化为unix，如换行符转化</li>
<li><code>ifconfig</code>,查看ip</li>
</ol>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><ol>
<li>概念：shell, 壳。 接收用户的命令，然后调用相应的应用程序；（命令解析器）</li>
</ol>
<h1 id="经典题目练习"><a href="#经典题目练习" class="headerlink" title="经典题目练习"></a>经典题目练习</h1><ol>
<li><a href="https://leetcode.com/problems/valid-phone-numbers/#/description" target="_blank" rel="external">正则表达式|grep|awk</a></li>
<li><a href="https://leetcode.com/problems/tenth-line/#/description" target="_blank" rel="external">文件第几行</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2016华为软件精英挑战赛总结-匈牙利算法和KM算法详解及java实现]]></title>
      <url>http://liuhang.net.cn/2016%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E5%92%8CKM%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8Ajava%E5%AE%9E%E7%8E%B0.html</url>
      <content type="html"><![CDATA[<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>二分图</strong>:二分图又称为二部图.简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、V中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有”含奇数条边的环”的图。<strong>生成子图</strong>:子图包含原图的所有顶点</li>
<li><strong>匹配</strong>: 通俗的说:匹配（matching）是一个边的集合，其中任意两条边都没有公共顶点.定义:对给定二分图G,在G的子图M中,M的边集{E}中的任意两条边不依赖于同一个顶点,则称M为一个匹配</li>
<li><strong>最大匹配</strong>: 图的所有匹配中,含有边数最多的匹配称为最大匹配</li>
<li><strong>完备匹配</strong>: 如果图G的某个匹配M,使G的每个顶点都和匹配M中的某条边相关联,则称M为完全匹配(完备匹配); 完备匹配一定是最大匹配.</li>
<li><img src="../media/graph.png" alt=""></li>
<li>如图: Fig.1为一个二分图,将其改为Fig.2的形式更为直观;Fig.3 红线部分,为一个匹配; Fig.4 为一个最大匹配,也是一个完备匹配</li>
</ul>
<h3 id="求图最大匹配的匈牙利算法"><a href="#求图最大匹配的匈牙利算法" class="headerlink" title="求图最大匹配的匈牙利算法"></a>求图最大匹配的匈牙利算法</h3><ul>
<li>求最大匹配最直接暴力的方法是: 找出全部匹配,然后保留边最多的. 这个方法的复杂度为边数目的指数级函数. 匈牙利算法是效率更高的方法.</li>
<li><strong>增广路径</strong>: 若P是图G一条<strong>连通两个未匹配点的路径,</strong>并且属于匹配M的边和不属于M的边(即已匹配边和未匹配边)在P上交替出现,则称P为相对于M的一条增广路径.</li>
<li><img src="/media/增广路径.png" alt=""></li>
<li>如上图,Fig.5红色为匹配,Fig.6为相对于匹配的一条增广路径</li>
<li>由增广路径的定义,可以推出三个结论:<ol>
<li>P的路径长度必定为奇数,第一条边和最后一条边都不属于M;</li>
<li>P经过取反操作,可以得到一个更大的匹配M1;</li>
<li>M为G的最大匹配当且仅当不存在相对于M的增广路径.</li>
</ol>
</li>
<li>匈牙利算法: 用增广路径求最大匹配(匈牙利科学家Edmonds于1965年提出); 其框架如下:<ol>
<li>置M为空;</li>
<li>找出一条增广路径P,通过取反操作,得到更大的匹配M1;</li>
<li>重复步骤2,直到找不出增广路径为止.</li>
</ol>
</li>
<li><strong>匈牙利算法实现(java)</strong><ul>
<li><img src="../media/14846300394186.jpg" alt=""></li>
<li>增广路径有两种寻径方法，一个是深搜(DFS)，一个是宽搜(BFS)。如上图,蓝色线为第一次匹配子图,现在从x1寻找增广路径,如果是<strong>DFS深搜</strong>:首先:x1找到y0,发现y0已经被x0匹配,于是深入到x0,为x0找新的匹配点,发现x0可以匹配y2,让x0与y2匹配,然后让x1与y0匹配,得到第二次匹配子图(红色).现在,从x2出发,搜寻增广路径,x2找到y0匹配，但发现y0已经被x1匹配了，于是就深入到x1，去为x1找新的匹配节点，结果发现x1没有其他的匹配节点，于是匹配失败，x2接着找y1，发现y1可以匹配，于是就找到了新的增广路径,将x2-y1加入匹配中。</li>
<li>DFS实现代码见<a href="https://github.com/husthang/java-learning/blob/master/java-algorithms/src/main/java/graph/KM.java" target="_blank" rel="external">我的代码java实现|GitHub</a></li>
</ul>
</li>
</ul>
<h2 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h2><h3 id="KM算法原理"><a href="#KM算法原理" class="headerlink" title="KM算法原理"></a>KM算法原理</h3><ul>
<li>对于加权完全二分图,找出权和最大的匹配,叫做求最佳匹配; 直接穷举法:效率为n!;用KM算法.</li>
<li><strong>定理</strong>: 设M是一个带权完全二分图G的一个完备匹配，给每个顶点一个可行顶标(第i个x顶点的可行标用lx[i]表示，第j个y顶点的可行标用ly[j]表示)，如果对所有的边(i,j) in G,都有lx[i]+ly[j]&gt;=w[i,j]成立(w[i,j]表示边的权)，且对所有的边(i,j) in M,都有lx[i]+ly[j]=w[i,j]成立，则M是图G的一个最佳匹配。证明很容易。</li>
<li>对任意的G和M,可行标都是存在的</li>
<li>对二分图G和一组可行标,满足可行标边界条件(lx[i]+ly[j]=w[i,j])的所有边构成的生成子图(<strong>需要包含所有顶点</strong>),称为其<strong>等价子图</strong>(相等子图),在这个等价子图上,寻找其完备匹配,如果完备匹配存在,则这个完备匹配M就是图G的最大权匹配,最大权等于所有可行标的和; 如果完备匹配不存在,则修改可行标,用<strong>贪心</strong>的思想,将最优的边加入等价子图. <strong>KM算法就是一种逐次修改可行顶标的方法,使之对应的等价子图逐次增广(增加边),最后出现完备匹配</strong>.</li>
</ul>
<h3 id="KM算法流程及实例"><a href="#KM算法流程及实例" class="headerlink" title="KM算法流程及实例"></a>KM算法流程及实例</h3><ul>
<li>Kuhn－Munkras<strong>算法流程</strong>：<ol>
<li>初始化可行顶标的值</li>
<li>用匈牙利算法在等价子图中寻找完备匹配</li>
<li>若未找到完备匹配则修改可行顶标的值</li>
<li>重复(2)(3)直到找到相等子图的完备匹配为止</li>
</ol>
</li>
<li><p>实例解释算法过程:</p>
<ul>
<li>带权二分图如下:</li>
<li><img src="../media/14846361640808.jpg" alt=""></li>
<li><p><img src="../media/顶标变换.png" alt=""></p>
</li>
<li><p>从x0找增广路径，找到x0-y4；然后,从x1找不到增广路径,这时,需要修改顶标,加入一条最优的新边到等价子图中:此时搜索过的路径为x1-y4-x0(用匈牙利法DFS),在路径上的X顶点集为S(x0,x1),Y顶点集为T(y4),对所有在S中的点xi及不在T中的点yj，计算d=min{(L(xi)+L(yj)-weight(xiyj))}，S中的点的顶标减去d,T中的点的顶标加上d,保持顶标依然为可行顶标.(这个d计算的意义是<strong>贪心思想</strong>,两种情况:此时让x0与其他点匹配,x1与y4匹配;x0依旧与y4匹配,x1找其他点匹配.d计算的是找到一条新加的边,让x0和x1都搭配后,与x0和x1都同y4搭配的非法搭配这种情况相比,损失的权重值最少).具体来说:此时算出来的最小d=L(X1)+L(Y0)-weight(X1Y0)=2,对顶标进行松弛后,得到的等价子图如上,加了一条边x1-y0,为x1重新找增广路径,找到x1-y0,此时匹配权值和为9+6=15;原来的非法匹配权值和为9+8=17,”损失”的权值最少为2(即加入一条其他的非x1-y0的边如x0-y2,损失的权值为3,比2大,即贪心思想,”损失最小”).</p>
</li>
<li>KM算法原本的时间复杂度为O(n^4),n个节点找n次增广路径,在某次找增光路径之中,顶标最多改变n次,修改顶标的松弛量需n^2; 可改进为O(n^3)时间复杂度:在寻找增广路径时顺便将slack值算出.</li>
</ul>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol>
<li><a href="https://github.com/husthang/java-learning/blob/master/java-algorithms/src/main/java/graph/KM.java" target="_blank" rel="external">我的代码|java实现</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.renfei.org/blog/bipartite-matching.html" target="_blank" rel="external">图基本概念讲解blog</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA%E6%9C%AF%E8%AF%AD" target="_blank" rel="external">图论术语|wiki</a></li>
<li><a href="http://blog.csdn.net/jarily/article/details/8617352" target="_blank" rel="external"> 带权的二分图的最优匹配KM算法|csdn-blog</a></li>
<li><a href="http://blog.csdn.net/x_y_q_/article/details/51927054" target="_blank" rel="external">KM算法实例讲解blog</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95" target="_blank" rel="external">匈牙利算法wiki</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2016华为软件精英挑战赛-TSP问题之分支定界结合匈牙利算法求解]]></title>
      <url>http://liuhang.net.cn/2016%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B-TSP%E9%97%AE%E9%A2%98%E4%B9%8B%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E7%BB%93%E5%90%88%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<h2 id="分支定界法"><a href="#分支定界法" class="headerlink" title="分支定界法"></a>分支定界法</h2><p>2016华为软件精英挑战赛</p>
<h2 id="TSP问题的分支定界法结合匈牙利算法"><a href="#TSP问题的分支定界法结合匈牙利算法" class="headerlink" title="TSP问题的分支定界法结合匈牙利算法"></a>TSP问题的分支定界法结合匈牙利算法</h2><ul>
<li>Example</li>
</ul>
<p><img src="../media/14872967925814.jpg" alt=""><br><img src="../media/14872968645084.jpg" alt=""></p>
<ul>
<li><p>分支策略</p>
<ul>
<li>一次AP(assignment problem指派问题)之后,选取节点数最少的环,进行分支,即进行”破环”;分别对每条边进行破环,破开的边不允许出现在下次AP解得的路径上;为了防止重复搜索,已经分支过(已经破开过的边)要必须出现在当前的字节点中.例如,一个环包括(i1,i2,i3)三个点(即三条边),第一个子节点(i1,i2)被破开(forbidden,禁止出现在下次ap中),第二个子节点(i1,i3) is forbidden,(i1,i2)必须出现(required),第三个子节点(i2,i3) is forbidden,(i1,i2)和(i1,i3) required. 如上面图二,为一次分支定界的示意图.</li>
</ul>
</li>
<li><p>指派模型结合分支定界法求解TSP问题</p>
<ul>
<li><a href="http://liuhang.net.cn/tsp-paper.pdf">本人总结论文</a>,此论文详细介绍了利用分支定界法结合指派问题求解TSP的原理和步骤。</li>
</ul>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li><a href="https://github.com/husthang/future_net2016" target="_blank" rel="external">分支定界结合指派问题km算法|2016华为软件精英挑战赛|Java/c++实现</a></li>
<li><a href="https://github.com/husthang/java-learning/blob/master/java-algorithms/src/main/java/graph/KM.java" target="_blank" rel="external">KM算法Java实现</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.kancloud.cn/digest/mathematicalmodelin/183016" target="_blank" rel="external">分支定界法|看云</a></li>
<li><a href="http://www.ecaa.ntu.edu.tw/weifang/class-or/or-more%E6%8C%87%E6%B4%BE.htm" target="_blank" rel="external">指派问题的特殊解法</a></li>
<li>Miller D L, Pekny J F. Exact solution of large asymmetric traveling salesman problems.[J]. 1991, 251(4995):754-761.</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM-自动内存管理机制]]></title>
      <url>http://liuhang.net.cn/JVM-%08%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%08%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.html</url>
      <content type="html"><![CDATA[<h1 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>强烈推荐，总结的超好。<a href="http://jbutton.iteye.com/blog/1569746" target="_blank" rel="external">深入理解JVM–JVM垃圾回收机制</a></li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Java的自动内存管理核心是自动化的解决了两大问题：给对象分配内存以及回收分配给对象的内存。</li>
<li>程序计数器、虚拟机栈、本地方法栈随线程生灭，不用考虑回收</li>
<li>Java堆和方法区，内存回收的主要区域。</li>
</ul>
<h2 id="确定对象是否存活"><a href="#确定对象是否存活" class="headerlink" title="确定对象是否存活"></a>确定对象是否存活</h2><ol>
<li>引用计数法： 给每个对象一个引用计数器，有地方引用它，计数器加一，引用失效，计数器减一；计数器为0的不再被使用。 缺点：对象间相互循环引用。</li>
<li>可达性分析算法： 主流的实现为可达性分析算法。 从一系列“GC Roots”对象起始点搜索，如果从“GC Roots”到这个对象不可达，证明对象不可用，可回收。<ul>
<li>Java中可作为GC Roots的对象有： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中，静态属性引用的对象； 方法区中常量引用的对象；本地方法栈中native方法引用的对象</li>
</ul>
</li>
<li>可达性分析判断为不可用对象后，还要执行器finalize()方法，筛选一次。</li>
</ol>
<h2 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h2><ul>
<li>永久代，Permanent Generation space。（Hotspot虚拟机中的永久代）。永久代主要回收废弃常量和无用的类</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ol>
<li>分代收集算法： 当前商业虚拟机垃圾回收采用分带收集。根据对象存活周期，把Java堆分为新生代和老年代。新生代：采用<strong>复制算法</strong>，复制少量依旧存活的；老年代：采用<strong>标记清理</strong>或<strong>标记整理</strong></li>
<li>复制算法： <strong>用于新生代</strong>，将存活的对象之间复制到另一块空间，然后清理掉当前。如Eden区和两块Survivor区</li>
<li>标记-清除（Mark-Sweep）</li>
<li>标记-整理(Mark-Compact)</li>
</ol>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><ol>
<li>堆内存被分为<strong>新生代</strong>和<strong>老年代</strong>，默认比例为1：2；新生代又分为<strong>Eden、From Survivor、To Survivor</strong>。</li>
<li>对象优先分配在新生代Eden区</li>
<li>大对象之间进入老年代</li>
<li>长期存活的对象将进入老年代</li>
<li>空间分配担保</li>
</ol>
<h1 id="虚拟机调优"><a href="#虚拟机调优" class="headerlink" title="虚拟机调优"></a>虚拟机调优</h1>]]></content>
    </entry>
    
  
  
</search>
