<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>刘航</title>
    <link>http://liuhang.net.cn/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 13 Sep 2017 09:16:59 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>面试-数据库总结</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Wed, 13 Sep 2017 09:06:59 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;普通索引、唯一索引、主键索引、全文索引&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;数据库引擎&quot;&gt;&lt;a href=&quot;#数据库引擎&quot; c
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul>
<li>普通索引、唯一索引、主键索引、全文索引</li>
</ul>
<h1 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h1><ul>
<li>InnoDB 支持数据库事物，不支持全文搜索</li>
<li>MyISAM  性能高，不支持事物，支持全文本搜索</li>
<li>MEMORY  数据存储在内存中，同MyISAM</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>项目总结-基于Quartz任务调度平台（一）</title>
      <link>http://liuhang.net.cn/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E5%9F%BA%E4%BA%8EQuartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89.html</link>
      <guid>http://liuhang.net.cn/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E5%9F%BA%E4%BA%8EQuartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89.html</guid>
      <pubDate>Sun, 27 Aug 2017 12:49:29 GMT</pubDate>
      <description>
      
        基于Quartz的任务调度框架，通过Web页面对任务进行CRUD操作，调度中心与执行器分离，支持集群式布置。
      
      </description>
      
      <content:encoded><![CDATA[<p># </p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><ol>
<li><p>job-core: 核心</p>
</li>
<li><p>job-admin: 调度中心(含web页面) ： 执行一个任务的粗略逻辑（流程）：<code>JobInfoController(&quot;/trigger&quot;) -  JobService.triggerJob - XxlJobDynamicScheduler.triggerJob  -  scheduler.triggerJob ,RemoteHttpJobBean，继承自QuartzJobBean（新增任务时会调用这个），里面为任务逻辑，然后调用-XxlJobTrigger.trigger  - XxlJobTrigger.runExecutor  -  NetComClientProxy为jetty客户端，里面启动时会发送http请求，分发到执行器执行任务逻辑,注意这里的FactoryBean</code></p>
</li>
<li><p>执行器：</p>
<ul>
<li>ExecutorBiz</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E5%9F%BA%E4%BA%8EQuartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>读书-书单</title>
      <link>http://liuhang.net.cn/%E8%AF%BB%E4%B9%A6-%E4%B9%A6%E5%8D%95.html</link>
      <guid>http://liuhang.net.cn/%E8%AF%BB%E4%B9%A6-%E4%B9%A6%E5%8D%95.html</guid>
      <pubDate>Wed, 23 Aug 2017 12:26:13 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;《Java并发编程的艺术》：粗读了一下，此书不错，Java并发编程入门极好！ 不建议用《Java并发编程实战》一书来入门。&lt;/l
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><ol>
<li>《Java并发编程的艺术》：粗读了一下，此书不错，Java并发编程入门极好！ 不建议用《Java并发编程实战》一书来入门。</li>
<li>《深入理解Java虚拟机》 推荐</li>
<li>《大型网站技术架构-核心原理及技术分析》 推荐</li>
</ol>
<h1 id="杂书"><a href="#杂书" class="headerlink" title="杂书"></a>杂书</h1><ol>
<li>《解忧杂货铺》：宝宝推荐，似乎还不错，<strong>待读</strong>。</li>
<li></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E8%AF%BB%E4%B9%A6-%E4%B9%A6%E5%8D%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>项目总结-异步框架个人实现</title>
      <link>http://liuhang.net.cn/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%AE%9E%E7%8E%B0.html</link>
      <guid>http://liuhang.net.cn/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%AE%9E%E7%8E%B0.html</guid>
      <pubDate>Wed, 23 Aug 2017 08:15:21 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%AE%9E%E7%8E%B0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人计划至9月底</title>
      <link>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B39%E6%9C%88%E5%BA%95.html</link>
      <guid>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B39%E6%9C%88%E5%BA%95.html</guid>
      <pubDate>Wed, 23 Aug 2017 02:18:27 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;8-23&quot;&gt;&lt;a href=&quot;#8-23&quot; class=&quot;headerlink&quot; title=&quot;8.23&quot;&gt;&lt;/a&gt;8.23&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;复习常见算法及数据结构（剑指offer）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;8-24&quot;&gt;&lt;a href=&quot;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="8-23"><a href="#8-23" class="headerlink" title="8.23"></a>8.23</h2><ol>
<li>复习常见算法及数据结构（剑指offer）</li>
</ol>
<h2 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h2><ol>
<li>亚马逊笔试</li>
<li>蘑菇街面试</li>
</ol>
<h2 id="8-25"><a href="#8-25" class="headerlink" title="8.25"></a>8.25</h2>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B39%E6%9C%88%E5%BA%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Quartz详解及源码探究2-quartz调度器scheduler</title>
      <link>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B62-quartz%E8%B0%83%E5%BA%A6%E5%99%A8scheduler.html</link>
      <guid>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B62-quartz%E8%B0%83%E5%BA%A6%E5%99%A8scheduler.html</guid>
      <pubDate>Mon, 14 Aug 2017 11:17:34 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Quartz-Scheduler&quot;&gt;&lt;a href=&quot;#Quartz-Scheduler&quot; class=&quot;headerlink&quot; title=&quot;Quartz Scheduler&quot;&gt;&lt;/a&gt;Quartz Scheduler&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a hr
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>客户端会同两种类型的 Scheduler 交互，如图,它们都实现了 org.quartz.Scheduler 接口</li>
<li><p>Scheduler代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）<br><img src="../images/QuartzFigure4.2.JPG" alt=""></p>
</li>
<li><p>Scheduler 的 API 可以分组成以下三个类别：</p>
<ul>
<li>管理 Scheduler</li>
<li>管理 Job</li>
<li>管理 Trigger 和 Calendar</li>
</ul>
</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="../images/quartz类结构.png" alt=""></p>
<ol>
<li>StdSchedule只是QuartzSchedule的一个包装类，方法更清晰。</li>
<li>QuartzScheduler是整个定时任务框架工作的核心类，上面的类图仅仅展现了QuartzScheduler中几个核心成员。</li>
<li>QuartzSchedulerResources可以认为是存放一切配置以及通过配置初始化出来的一些资源的容器，其中包括了存储job定义的jobStore</li>
<li>QuartzSchedulerThread多线程启动</li>
</ol>
<h1 id="Quartz-SchedulerFactory"><a href="#Quartz-SchedulerFactory" class="headerlink" title="Quartz SchedulerFactory"></a>Quartz SchedulerFactory</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>用工厂方法构造scheuler实例，并使之正确的得到初始化。 所有的 Scheduler 实例应该由 SchedulerFactory 来创建。</li>
<li>　Quartz 框架为这一目的提供了 org.quartz.SchedulerFactory 接口。角色 SchedulerFactory 就是用来产生 Scheduler 实例的。当 Scheduler 实例被创建之后，就会存到一个仓库中(org.quartz.impl.SchedulerRepository)，这个仓库还提供了通过一个 class loader 查询实例的机制。<br><img src="../images/QuartzFigure4.3.JPG" alt=""><ul>
<li>DirectSchedulerFactory 是为那些想绝对控制 Scheduler 实例是如何生产出的人所设计的</li>
<li>与 DirectSchedulerFactory 形成鲜明对比的是，org.quartz.impl.StdSchedulerFactory 依赖于一系列的属性来决定如何生产出 Scheduler 实例</li>
</ul>
</li>
</ul>
<h2 id="StdSchedulerFactory源码分析"><a href="#StdSchedulerFactory源码分析" class="headerlink" title="StdSchedulerFactory源码分析"></a>StdSchedulerFactory源码分析</h2><ol>
<li><p>无参的initialize()方法，StdSchedulerFactory 会执行以下几个步骤去尝试为工厂加载属性：</p>
<ol>
<li>检查 System.getProperty(“org.quartz.properties”) 中是否设置了别的文件名</li>
<li>否则，使用 quartz.properties 作为要加载的文件名</li>
<li>试图从当前工作目录中加载这个文件</li>
<li>试图从系统 classpath 下加载这个文件<br><img src="../images/stdchedulerFactory-initialize.png" alt=""></li>
</ol>
</li>
<li><p>StdSchedulerFactory.getScheduler()源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public Scheduler getScheduler() throws SchedulerException &#123;</div><div class="line">        // 读取quartz配置文件，未指定则顺序遍历各个path下的quartz.properties文件</div><div class="line">        // 解析出quartz配置内容和环境变量，存入PropertiesParser对象</div><div class="line">        // PropertiesParser组合了Properties（继承Hashtable），定义了一系列对Properties的操作方法，比如getPropertyGroup()批量获取相同前缀的配置。配置内容和环境变量存放在Properties成员变量中</div><div class="line">        if (cfg == null) &#123;</div><div class="line">            initialize();</div><div class="line">        &#125;</div><div class="line">        // 获取调度器池，采用了单例模式</div><div class="line">        // 其实，调度器池的核心变量就是一个hashmap，每个元素key是scheduler名，value是scheduler实例</div><div class="line">        // getInstance()用synchronized防止并发创建</div><div class="line">        SchedulerRepository schedRep = SchedulerRepository.getInstance();</div><div class="line"></div><div class="line">        // 从调度器池中取出当前配置所用的调度器</div><div class="line">        Scheduler sched = schedRep.lookup(getSchedulerName());</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">        // 如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：（见实例化源码分析）</div><div class="line">        sched = instantiate();</div><div class="line"></div><div class="line">        return sched;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>instantiate()实例化，源码分析<br>如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：</p>
<ul>
<li>1）初始化threadPool(线程池)：开发者可以通过org.quartz.threadPool.class配置指定使用哪个线程池类，比如SimpleThreadPool。先class load线程池类，接着动态生成线程池实例bean，然后通过反射，使用setXXX()方法将以org.quartz.threadPool开头的配置内容赋值给bean成员变量；</li>
<li>2）初始化jobStore(任务存储方式)：开发者可以通过org.quartz.jobStore.class配置指定使用哪个任务存储类，比如RAMJobStore。先class load任务存储类，接着动态生成实例bean，然后通过反射，使用setXXX()方法将以org.quartz.jobStore开头的配置内容赋值给bean成员变量；</li>
<li>3）初始化dataSource(数据源)：开发者可以通过org.quartz.dataSource配置指定数据源详情，比如哪个数据库、账号、密码等。jobStore要指定为JDBCJobStore，dataSource才会有效；</li>
<li>4）初始化其他配置：包括SchedulerPlugins、JobListeners、TriggerListeners等；</li>
<li>5）初始化threadExecutor(线程执行器)：默认为DefaultThreadExecutor；</li>
<li>6）创建工作线程：根据配置创建N个工作thread，执行start()启动thread，并将N个thread顺序add进threadPool实例的空闲线程列表availWorkers中；</li>
<li>7）创建调度器线程：创建QuartzSchedulerThread实例，并通过threadExecutor.execute(实例)启动调度器线程；</li>
<li>8）创建调度器：创建StdScheduler实例，将上面所有配置和引用组合进实例中，并将实例存入调度器池中</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B62-quartz%E8%B0%83%E5%BA%A6%E5%99%A8scheduler.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Quartz详解及源码探究1-quartz入门及核心概念</title>
      <link>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B61-quartz%E5%85%A5%E9%97%A8%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html</link>
      <guid>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B61-quartz%E5%85%A5%E9%97%A8%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html</guid>
      <pubDate>Mon, 14 Aug 2017 07:16:39 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Quartz核心概念&quot;&gt;&lt;a href=&quot;#Quartz核心概念&quot; class=&quot;headerlink&quot; title=&quot;Quartz核心概念&quot;&gt;&lt;/a&gt;Quartz核心概念&lt;/h1&gt;&lt;h2 id=&quot;Quartz使用入门&quot;&gt;&lt;a href=&quot;#Quartz使用入门&quot;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Quartz核心概念"><a href="#Quartz核心概念" class="headerlink" title="Quartz核心概念"></a>Quartz核心概念</h1><h2 id="Quartz使用入门"><a href="#Quartz使用入门" class="headerlink" title="Quartz使用入门"></a>Quartz使用入门</h2><ul>
<li>首先看一个Quartz入门demo，由此入门demo深入剖析Quartz原理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package quartz;</div><div class="line"></div><div class="line">import org.quartz.*;</div><div class="line">import org.quartz.impl.StdSchedulerFactory;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by liuhang on 2017/8/1.</div><div class="line"> */</div><div class="line">public class QuartzTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            </div><div class="line">            //工程方法模式构造scheduler</div><div class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</div><div class="line"></div><div class="line">            //这里用到Builder模式</div><div class="line">            JobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(&quot;myJob&quot;, &quot;myJobGroup&quot;).build();</div><div class="line"></div><div class="line">            Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;myTrigger&quot;, &quot;myTriggerGroup&quot;).startNow().withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever()).build();</div><div class="line"></div><div class="line">            scheduler.scheduleJob(jobDetail, trigger);</div><div class="line"></div><div class="line">            scheduler.start();</div><div class="line"></div><div class="line"></div><div class="line">        &#125; catch (SchedulerException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package quartz;</div><div class="line"></div><div class="line">import org.quartz.Job;</div><div class="line">import org.quartz.JobExecutionContext;</div><div class="line">import org.quartz.JobExecutionException;</div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by liuhang on 2017/8/1.</div><div class="line"> */</div><div class="line">public class JobImpl implements Job &#123;</div><div class="line">    private static Logger logger = LoggerFactory.getLogger(JobImpl.class);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</div><div class="line">        logger.info(&quot;Hello World! - &quot; + new Date());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>由demo可以看出，quartz的几个核心概念：Job，Trigger，Scheduler，Calendar； 如下图所示<br><img src="../images/quartz核心概念.png" alt=""></p>
<ul>
<li>Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）</li>
<li>Job：是一个接口，只有一个方法void execute(JobExecutionContext context)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中；</li>
<li>JobDetail：Quartz在每次执行Job时，都重新创建一个Job实例，所以它不直接接受一个Job的实例，相反它接收一个Job实现类，以便运行时通过newInstance()的反射机制实例化Job。因此需要通过一个类来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息，JobDetail承担了这一角色。</li>
<li>Trigger：是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当仅需触发一次或者以固定时间间隔周期执行，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如每早晨9:00执行，周一、周三、周五下午5:00执行等；</li>
<li>Calendar：org.quartz.Calendar和java.util.Calendar不同，它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。</li>
</ul>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html" target="_blank" rel="external">官方文档</a></p>
</li>
<li><p><a href="http://www.quartz-scheduler.org/api/2.2.1/index.html" target="_blank" rel="external">官方api</a></p>
</li>
<li><p><a href="https://unmi.cc/category/quartz/" target="_blank" rel="external">quartz详解博客-文档</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/bab8e4e32952" target="_blank" rel="external">quartz原理揭秘和源码解读
</a></p>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B61-quartz%E5%85%A5%E9%97%A8%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>大数据-Hadoop学习1</title>
      <link>http://liuhang.net.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop%E5%AD%A6%E4%B9%A01.html</link>
      <guid>http://liuhang.net.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop%E5%AD%A6%E4%B9%A01.html</guid>
      <pubDate>Mon, 31 Jul 2017 11:24:11 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Hadoop提供了一个稳定的共享存储和分析系统。存储由HDFS实现，分析由MapReduce实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ol>
<li>Hadoop提供了一个稳定的共享存储和分析系统。存储由HDFS实现，分析由MapReduce实现</li>
</ol>
<h1 id="Mac下Hadoop2-7-x配置伪分布环境-wordcount运行"><a href="#Mac下Hadoop2-7-x配置伪分布环境-wordcount运行" class="headerlink" title="Mac下Hadoop2.7.x配置伪分布环境(wordcount运行)"></a>Mac下Hadoop2.7.x配置伪分布环境(wordcount运行)</h1><h2 id="ssh环境配置"><a href="#ssh环境配置" class="headerlink" title="ssh环境配置"></a>ssh环境配置</h2><ol>
<li><code>ssh localhost</code>验证是否能无密码登录<ul>
<li>出现<code>ssh: connect to host localhost port 22: Connection refused</code>，在”系统偏好设置-共享”中打开远程登录选项</li>
</ul>
</li>
<li><code>ssh-keygen -t rsa -f ~/.ssh/id_rsa</code><br> <code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></li>
</ol>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><ol>
<li><code>export HADOOP_INSTALL=/Users/home/liuhang/Java/hadoop/hadoop-2.8.1</code><br> <code>export PATH=$PATH:$HADOOP_INSTALL/bin</code> ；export设置只对当前的bash登陆session有效.</li>
<li>要使得环境变量一直生效，可修改<code>vim ~/.bash_profile</code>,把命令加载进入bash启动脚本中</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://kiritor.github.io/2016/04/24/Hadoop-install/" target="_blank" rel="external">Mac下Hadoop2.7.x配置伪分布环境(wordcount运行)</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop%E5%AD%A6%E4%B9%A01.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>随笔-校招记录</title>
      <link>http://liuhang.net.cn/%E9%9A%8F%E7%AC%94-%E6%A0%A1%E6%8B%9B%E8%AE%B0%E5%BD%95.html</link>
      <guid>http://liuhang.net.cn/%E9%9A%8F%E7%AC%94-%E6%A0%A1%E6%8B%9B%E8%AE%B0%E5%BD%95.html</guid>
      <pubDate>Mon, 31 Jul 2017 07:38:22 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;投递记录&quot;&gt;&lt;a href=&quot;#投递记录&quot; class=&quot;headerlink&quot; title=&quot;投递记录&quot;&gt;&lt;/a&gt;投递记录&lt;/h1&gt;&lt;h2 id=&quot;拼多多-已投&quot;&gt;&lt;a href=&quot;#拼多多-已投&quot; class=&quot;headerlink&quot; title=&quot;拼多多
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="投递记录"><a href="#投递记录" class="headerlink" title="投递记录"></a>投递记录</h1><h2 id="拼多多-已投"><a href="#拼多多-已投" class="headerlink" title="拼多多(已投)"></a>拼多多(已投)</h2><ol>
<li>8.1号晚上，牛客</li>
</ol>
<h2 id="苏宁（已投）"><a href="#苏宁（已投）" class="headerlink" title="苏宁（已投）"></a>苏宁（已投）</h2><ol>
<li>筛选中</li>
</ol>
<h2 id="科大飞讯-已投"><a href="#科大飞讯-已投" class="headerlink" title="科大飞讯(已投)"></a>科大飞讯(已投)</h2><ol>
<li>筛选中</li>
</ol>
<h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><ol>
<li>内推</li>
<li>面试8.10-8.20左右</li>
</ol>
<h2 id="4399（已投）"><a href="#4399（已投）" class="headerlink" title="4399（已投）"></a>4399（已投）</h2><ol>
<li>时间</li>
</ol>
<h2 id="顺丰（已投）"><a href="#顺丰（已投）" class="headerlink" title="顺丰（已投）"></a>顺丰（已投）</h2><h2 id="亚马逊（）"><a href="#亚马逊（）" class="headerlink" title="亚马逊（）"></a>亚马逊（）</h2><ol>
<li>笔试已通知<strong>8.24</strong></li>
</ol>
<h2 id="Thoughtworks-已投"><a href="#Thoughtworks-已投" class="headerlink" title="Thoughtworks(已投)"></a>Thoughtworks(已投)</h2><h2 id="搜狐（已投）"><a href="#搜狐（已投）" class="headerlink" title="搜狐（已投）"></a>搜狐（已投）</h2><h2 id="搜狗（已投）"><a href="#搜狗（已投）" class="headerlink" title="搜狗（已投）"></a>搜狗（已投）</h2><ol>
<li>时间<strong>8月30号</strong></li>
</ol>
<h2 id="唯品会（已投）"><a href="#唯品会（已投）" class="headerlink" title="唯品会（已投）"></a>唯品会（已投）</h2><ol>
<li>笔试时间<strong>9月16日左右</strong></li>
</ol>
<h2 id="中国银联（已投）"><a href="#中国银联（已投）" class="headerlink" title="中国银联（已投）"></a>中国银联（已投）</h2><ol>
<li>笔试时间<strong>8月30号</strong></li>
</ol>
<h2 id="招商银行信用卡中兴（已投）"><a href="#招商银行信用卡中兴（已投）" class="headerlink" title="招商银行信用卡中兴（已投）"></a>招商银行信用卡中兴（已投）</h2><ol>
<li>笔试时间</li>
</ol>
<h2 id="招银网络科技"><a href="#招银网络科技" class="headerlink" title="招银网络科技"></a>招银网络科技</h2><h2 id="美丽联合"><a href="#美丽联合" class="headerlink" title="美丽联合"></a>美丽联合</h2><ol>
<li>内推（投递中）</li>
<li>网申</li>
</ol>
<h2 id="京东（已投）"><a href="#京东（已投）" class="headerlink" title="京东（已投）"></a>京东（已投）</h2><ol>
<li>管培生，在线笔试：<strong>8月25日</strong></li>
<li>Java开发，在线笔试：<strong>9月8日</strong></li>
</ol>
<h2 id="百度（已投）"><a href="#百度（已投）" class="headerlink" title="百度（已投）"></a>百度（已投）</h2><ol>
<li>在线笔试：<strong>9月11日</strong>；</li>
</ol>
<h2 id="滴滴（已投）"><a href="#滴滴（已投）" class="headerlink" title="滴滴（已投）"></a>滴滴（已投）</h2><ol>
<li>笔试时间 <strong>8.26日</strong></li>
</ol>
<h2 id="今日头条（已投）"><a href="#今日头条（已投）" class="headerlink" title="今日头条（已投）"></a>今日头条（已投）</h2><ol>
<li>笔试时间  <strong>已收到笔试通知</strong></li>
</ol>
<h2 id="美团点评"><a href="#美团点评" class="headerlink" title="美团点评"></a>美团点评</h2><ol>
<li>内推 （已投） 笔试时间：<em>**8月31日</em></li>
<li>秋招</li>
</ol>
<h2 id="网易（已投）"><a href="#网易（已投）" class="headerlink" title="网易（已投）"></a>网易（已投）</h2><ol>
<li>笔试时间<strong>9月9日</strong></li>
</ol>
<h2 id="网易游戏"><a href="#网易游戏" class="headerlink" title="网易游戏"></a>网易游戏</h2><ol>
<li>笔试时间<strong>9月中旬</strong></li>
</ol>
<h2 id="腾讯（已投）"><a href="#腾讯（已投）" class="headerlink" title="腾讯（已投）"></a>腾讯（已投）</h2><ol>
<li>笔试时间<strong>9月13日</strong></li>
</ol>
<h2 id="去哪儿-已投"><a href="#去哪儿-已投" class="headerlink" title="去哪儿(已投)"></a>去哪儿(已投)</h2><ol>
<li><h2 id="58同城"><a href="#58同城" class="headerlink" title="58同城"></a>58同城</h2></li>
<li><strong>8月22日</strong>，内推提前批笔试，<strong>已收到笔试通知</strong></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9A%8F%E7%AC%94-%E6%A0%A1%E6%8B%9B%E8%AE%B0%E5%BD%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试-设计模式</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</guid>
      <pubDate>Sun, 30 Jul 2017 13:44:04 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;知道哪些设计模式&quot;&gt;&lt;a href=&quot;#知道哪些设计模式&quot; class=&quot;headerlink&quot; title=&quot;知道哪些设计模式&quot;&gt;&lt;/a&gt;知道哪些设计模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计模式可以分为三大类，分别是&lt;strong&gt;创建型设计模式&lt;/stron
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="知道哪些设计模式"><a href="#知道哪些设计模式" class="headerlink" title="知道哪些设计模式"></a>知道哪些设计模式</h1><ul>
<li><p>设计模式可以分为三大类，分别是<strong>创建型设计模式</strong>、<strong>行为型设计模式</strong>以及<strong>结构型设计模式</strong>。</p>
</li>
<li><p>创建型设计模式： 工厂模式（工厂方法模式，抽象工厂模式，简单工厂模式），构建模式，单例模式。</p>
</li>
<li><p>行为设计模式： <strong>观察者模式</strong>（ 微信公众号，更新消息，关注号的人都可以知道。）<strong>模板方法模式</strong>：定义一个算法的框架，将一些步骤延迟到子类中实现，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。 比如，一个复杂的项目的任务，通常由架构师或者高级工程师用接口或者抽象类，来将主要业务逻辑串联起来，然后根据编码难度，将具体实现分给其他人来完成。</p>
</li>
<li><p>结构型设计模式： <strong>代理模式</strong>:给目标对象提供一个代理对象，并由代理对象控制对目标对象的访问。代理场景：当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现； 访问原对象时，进行一些附加操作；</p>
</li>
</ul>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ol>
<li>懒汉式：</li>
<li>饿汉式</li>
<li>线程安全： 懒汉式：使用静态内部类实现</li>
<li>参考：<a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="external">如何正确地写出单例模式</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 懒汉式，第一次使用时加载，线程不安全；</div><div class="line">public class Singleton&#123;</div><div class="line">    private Singleton()&#123;&#125;</div><div class="line">    private static Singleton instance;</div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        if(instance==null)&#123;</div><div class="line">            instance = new Singleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//线程安全,使用静态内部类,懒汉式</div><div class="line">public class Singleton &#123;</div><div class="line">    private Singleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        //内部类的一切对外部类都是可见的，不管是否是私有成员</div><div class="line">        private static final Singleton instance = new Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        return SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="装饰模式与代理模式"><a href="#装饰模式与代理模式" class="headerlink" title="装饰模式与代理模式"></a>装饰模式与代理模式</h1><h2 id="装饰模式："><a href="#装饰模式：" class="headerlink" title="装饰模式："></a>装饰模式：</h2><ul>
<li>注重为方法添加额外的行为，装饰者一定会调用被装饰对象的方法的，装饰只能新增行为，不能跳过</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ol>
<li><p>注重控制，控制对象方法的访问</p>
</li>
<li><p>静态代理：程序运行前，class文件已经生成</p>
</li>
<li>动态代理：字节码在程序运行时，由Java反射机制，动态生成</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试-JVM相关</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-JVM%E7%9B%B8%E5%85%B3.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-JVM%E7%9B%B8%E5%85%B3.html</guid>
      <pubDate>Sun, 30 Jul 2017 13:41:45 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;参考：&lt;a href=&quot;http://www.importnew.com/23792.html&quot; target=&quot;_blank
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol>
<li>参考：<a href="http://www.importnew.com/23792.html" target="_blank" rel="external">JVM知识点总览-高级Java工程师面试必备</a></li>
<li><p>参考:<a href="http://blog.csdn.net/hsk256/article/details/49104955" target="_blank" rel="external">java常见面试题及答案 11-20（JVM）</a></p>
</li>
<li><p>分四大块</p>
<ul>
<li>类的加载机制</li>
<li>jvm内存结构</li>
<li>GC算法 垃圾回收</li>
<li>GC分析 命令调优</li>
</ul>
</li>
</ol>
<h1 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h1><ol>
<li><p>程序计数器： 线程私有；看作当前线程所执行的字节码的行号指示器，通过计数器的值选取下一条要执行的字节码指令。</p>
</li>
<li><p>虚拟机栈： 线程私有，它的生命周期与线程相同；（即常说的堆内存和栈内存中的栈），栈帧结构，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p>
<ul>
<li>栈帧的结构<ul>
<li>局部变量表： 存放方法参数和方法内部定义的局部变量。存储的是基本数据类型，对象引用等； 通过索引定位的方式访问。</li>
<li>操作数栈：作用主要用来存储运算结果以及运算的操作数；通过压栈和出栈访问。</li>
<li>动态链接</li>
</ul>
</li>
</ul>
</li>
<li><p>本地方法栈： 虚拟机使用到的native方法</p>
</li>
<li><p>Java堆，<strong>线程共享</strong>，所有的对象实例和数组在堆上分配内存。垃圾回收的主要区域。</p>
</li>
<li><p>方法区： 各<strong>线程共享</strong>，存储已经被虚拟机加载的类信息、常量、静态变量等。运行时常量池是方法区的一部分。</p>
</li>
</ol>
<h1 id="GC-垃圾回收算法"><a href="#GC-垃圾回收算法" class="headerlink" title="GC 垃圾回收算法"></a>GC 垃圾回收算法</h1><ol>
<li><p>常用的垃圾回收算法：</p>
<ul>
<li><p>标记-清除算法：这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。</p>
</li>
<li><p>复制算法：为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存为Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区（Survior）上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)</p>
</li>
<li><p>标记-整理算法: 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（解决了内存碎片的问题）</p>
</li>
<li><p>分代回收算法：把Java堆分新生代和老年代，在新生代用复制算法（，由于对象生存期短，每次回收都会有大量对象死去），在老年代（老年代里的对象存活率较高）用标记-清理或标记-整理算法，是现代虚拟机通常采用的算法。</p>
</li>
</ul>
</li>
<li><p>GC的基本过程：</p>
<ul>
<li>堆内存分为新生代和老年代，而新生代又分为Eden区和两个Survivor区。</li>
<li>先将对象放入Eden区，如果空间不足就向其中的一个survivor区上放，如果仍然放不下就会引发一次发生在新生代的minor GC。将存活的对象放入另一个survivor区中，然后清空Eden和之前的那个survivor区的内存。</li>
<li>大对象以及长期存活的对象，进入老年代</li>
<li>空间分配担保，当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。那么执行一次Full GC以尽可能地获得老年区的空间。</li>
</ul>
</li>
<li><p>判断对象是否存活：</p>
<ul>
<li><p>判断对象是否存活有两种方法：引用计数法，可达性算法。</p>
</li>
<li><p>引用计数法：给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. 存在问题：循环引用，A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p>
</li>
<li><p>可达性分析算法：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。</p>
<ul>
<li>在java中可以作为GC Roots的对象有以下几种:<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区类静态属性引用的对象</li>
<li>方法区常量池引用的对象</li>
<li>本地方法栈JNI引用的对象(Native方法引用对象)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ol>
<li>java内存模型(JMM)是线程间通信的控制机制.JMM定义了主内存和线程之间抽象关系。<strong>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）</strong>，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。<br> 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br> 然后，线程B到主内存中去读取线程A之前已更新过的共享变量<br> <img src="../images/jmm.png" alt=""></li>
</ol>
<ol>
<li></li>
</ol>
<h1 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h1><h2 id="Java类加载过程"><a href="#Java类加载过程" class="headerlink" title="Java类加载过程"></a>Java类加载过程</h2><p>java类加载需要经历一下7个过程：</p>
<ol>
<li><p>加载<br>加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p>
<ol>
<li>通过一个类的全限定名获取该类的二进制流。（类加载器作用）</li>
<li>将该二进制流中的静态存储结构转化为方法去运行时数据结构。 </li>
<li>在内存中生成该类的Class对象，作为该类的数据访问入口。</li>
</ol>
</li>
<li><p>验证<br>验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</li>
<li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</li>
<li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</li>
<li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</li>
</ol>
</li>
<li><p>准备<br>准备阶段是为类的静态变量（即 类变量）分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<br> public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。</p>
</li>
<li><p>解析<br>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p>
</li>
<li><p>初始化<br>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p>
</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ol>
<li><p>双亲委派模型</p>
<ul>
<li>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</li>
<li>使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。比如java.lang.Object，最终都是委派顶端的启动类加载器去加载。</li>
</ul>
</li>
<li><p>什么是类加载器，类加载器有哪些<br> 实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。<br>主要有一下四种类加载器:</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li>
<li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li>
</ol>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-JVM%E7%9B%B8%E5%85%B3.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程11-Fork/Join框架</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11-Fork-Join%E6%A1%86%E6%9E%B6.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11-Fork-Join%E6%A1%86%E6%9E%B6.html</guid>
      <pubDate>Mon, 24 Jul 2017 12:23:35 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11-Fork-Join%E6%A1%86%E6%9E%B6.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试-Java多线程/JVM等</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;&amp;JVM%E7%AD%89.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;&amp;JVM%E7%AD%89.html</guid>
      <pubDate>Sun, 23 Jul 2017 08:55:09 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.importnew.com/12773.html&quot; target=&quot;_blank&quot; re
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.importnew.com/12773.html" target="_blank" rel="external">多线程面试问题收集</a></li>
</ol>
<h1 id="并发-多线程"><a href="#并发-多线程" class="headerlink" title="并发/多线程"></a>并发/多线程</h1><ul>
<li><p>什么是进程和线程</p>
<ul>
<li>进程可以被看做是一个程序或者一个应用，是系统进行资源分配一个独立单位。</li>
<li>线程包含在进程之中，是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。</li>
</ul>
</li>
<li><p>进程和线程有什么区别</p>
<ul>
<li>进程是资源分配的基本单位，一个进程可以包含多个线程，进程间切换开销大；</li>
<li>多线程好处：在进程内，创建、终止线程快，线程切换快。</li>
<li>多进程好处：每个进程相互独立，子进程崩溃没有关系，隔离性好；如果不需要很多通信，数据共享，多进程实现更加简单，高效。</li>
</ul>
</li>
<li><p>Java实现多线程的方法</p>
<ul>
<li>继承Thread类，重写其run方法</li>
<li>实现Runnable接口（查看源码，发现Thread类也实现了Runnable接口）</li>
<li>实现Callable接口,Future,线程池框架</li>
</ul>
</li>
<li><p>线程的几种状态</p>
<ol>
<li>新建(new)  ：新创建了一个线程对象。</li>
<li>可运行(runnable)  ：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</li>
<li>运行(running)  ：可运行状态(  runnable) 的线程获得了cpu 时间片（timeslice） ，执行程序代码。</li>
<li>阻塞(block)  ：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入  可运行(runnable) 状态，才有机会再次获得cpu timeslice 转到 运行(running) 状态。阻塞的情况分三种： <ul>
<li>(一). 等待阻塞： 运行(running) 的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中,wait方法会释放锁对象。</li>
<li>(二). 同步阻塞： 运行(running) 的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>
<li>(三). 其他阻塞： 运行(running) 的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入 可运行(runnable) 状态。</li>
</ul>
</li>
<li>死亡(dead)  ：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ol>
</li>
<li><p>Java多线程同步的方法</p>
<ol>
<li>synchronized 同步方法，同步代码块</li>
<li>Volatile关键字</li>
<li>使用Java并发包中的锁，ReentrantLock同步</li>
</ol>
</li>
<li><p>用Runnable还是Thread</p>
<ul>
<li>Java不支持多继承，允许实现多个接口，如果要继承其他类，用Runable更好</li>
</ul>
</li>
<li><p>Java中Runnable和Callable有什么不同？</p>
<ul>
<li>主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象</li>
</ul>
</li>
<li><p>Volatile变量</p>
<ul>
<li><strong>可见性</strong>：每次使用v之前，从主内存刷新最新的值(read,load,use操作连在一起)； 每次修改V之后，立马同步回主内存(assign,store,write操作连在一起)；</li>
<li><strong>有序性</strong>：保证代码执行顺序，与程序顺序相同;下一个读取操作会在前一个写操作之后发生。volatile写之前的所有操作都不会被重排序到volatile之后;保volatile读之后的所有操作都不会被重排序到volatile之前;第一个操作是volatile写操作时,第二个操作是volatile读操作,不能进行重排序.</li>
</ul>
</li>
<li><p>Java内存模型，并发过程中的三大特性</p>
<ul>
<li>原子性</li>
<li>可见性：volatile和 synchronized保证可见性，final</li>
<li>有序性：volatile和synchronized保证有序性</li>
</ul>
</li>
<li><p>什么是竞态条件。</p>
<ul>
<li>当多个线程竞争同一资源时，程序的结果依赖于线程执行的顺序。由于不恰当的执行顺序，而出现不正确的结果，即出现”竞态条件“</li>
<li>举例： 单例模式，延迟加载。</li>
</ul>
</li>
<li><p>wait与sleep</p>
<ul>
<li>wait会释放锁</li>
<li>sleep()保持对象锁，仍然占有该锁</li>
</ul>
</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ol>
<li><p>线程池作用</p>
<ul>
<li>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理</li>
<li>好处：<ul>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗<ul>
<li>为什么使用线程池，线程池好处</li>
</ul>
</li>
<li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池原理</p>
<ul>
<li>有两个核心参数corePoolSize,maximumPool； 用到了阻塞队列。</li>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤<br>需要获取全局锁）。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执<br>行这一步骤需要获取全局锁）。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用<br>RejectedExecutionHandler.rejectedExecution()方法。</li>
<li>ThreadPoolExecutor完成预热之后<br>（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而<br>步骤2不需要获取全局锁</li>
</ul>
</li>
</ol>
<ol>
<li><p>ThreadLocal变量</p>
<ul>
<li>线程局部变量</li>
<li>用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。采用的是空间换时间的策略</li>
<li>底层原理：ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本</li>
<li>与同步机制的比较：synchronized同步机制，仅提供一份变量，让不同的线程排队访问，后者为每个线程都提供了一份变量，互相不影响的访问。</li>
<li>应用：Spirng中，有状态的Bean，用ThreadLocal封装，可以申明为Singleton作用域，变成无状态的</li>
</ul>
</li>
<li><p>Java中interrupted 和 isInterruptedd方法的区别</p>
<ul>
<li>interrupted方法，静态方法，Thread.interrupted，测试当前线程是否中断；调用之后，中断状态会被清除为false</li>
<li>isInterrupted，非静态方法，查询这个线程是否中断</li>
</ul>
</li>
</ol>
<ol>
<li><p>死锁</p>
<ul>
<li>产生死锁的四个必要条件<ul>
<li>互斥（ Mutual exclusion ）条件：一个资源一次只能被一个进程所使用，即是排它性使用。</li>
<li>不可抢占（ No preemption ）条件：一个资源仅能被占有它的进程所释放，而不能被别的进程强占。</li>
<li>请求和保持（ Hold-and-wait ）条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放。</li>
<li>环路等待（ Circular wait ）条件：当每类资源只有一个时，在发生死锁时，必然存在一个进程-资源的环形链。如一系统状态的资源分配图所示，P1正在等待一个P2 占用的资源R2，P2正在等待一个P1占用的资源R1。</li>
</ul>
</li>
<li>死锁的预防： 破坏四个条件之一</li>
<li>死锁的避免：在资源分配之前，计算分配是否安全。 如：银行家算法</li>
</ul>
</li>
<li><p>阻塞队列</p>
<ul>
<li>阻塞队列（BlockingQueue），支持阻塞的插入和移除方法<ul>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空</li>
</ul>
</li>
<li>Java里的阻塞队列(Java里的阻塞队列)<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
</ul>
</li>
<li>阻塞队列原理：</li>
</ul>
</li>
<li><p>Fork/join框架</p>
<ul>
<li>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干<br>个小任务，最终汇总每个小任务结果后得到大任务结果的框架</li>
<li>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行</li>
<li>ForkJoinTask：分隔任务；RecursiveTask：用于有返回结果的任务。RecursiveAction：用于没有返回结果的任务。</li>
<li>ForkJoinPool：执行任务</li>
</ul>
</li>
</ol>
<ol>
<li><p>CountDownLatch计数门闩与同步屏障CyclicBarrier</p>
<ul>
<li>CountDownLatch允许一个或多个线程等待其他线程完成操作（跟join类似）</li>
<li>CyclicBarrier让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</li>
<li>区别：CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置</li>
</ul>
</li>
<li><p>控制并发线程数的Semaphore</p>
<ul>
<li>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</li>
</ul>
</li>
</ol>
<ol>
<li><p>ConcurrentHashMap</p>
<ul>
<li>使用了锁分段技术技术来保证线程安全的，锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</li>
<li>put和get操作是原子操作，是线程安全</li>
</ul>
</li>
<li><p>Java线程间通信方式</p>
<ul>
<li>同步（即共享内存），synchronized</li>
<li>wait/notify机制；</li>
<li>while轮询</li>
</ul>
</li>
</ol>
<h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><ol>
<li><p>读写锁</p>
<ul>
<li>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。</li>
<li>应用场景：多读少写。</li>
<li>读写锁维护了一对锁，一个读锁，一个写锁</li>
</ul>
</li>
<li><p>可重入锁</p>
<ul>
<li>对资源的重复加锁。同一个线程再次进入同步代码的时候.可以再次获取自己已经获取到的锁。</li>
</ul>
</li>
<li><p>乐观锁与悲观锁</p>
<ul>
<li>悲观锁</li>
<li>乐观锁： 比较并交换。 直接读取使用，在准备赋值时，检查值是否跟原来一样（是否被其他线程修改）。解决aba问题，带参数版本的方法，在比较时，看版本是否一样。</li>
</ul>
</li>
<li><p>公平锁与非公平锁</p>
<ul>
<li>多个线程再等待同一个锁时，必须按照申请锁的实际顺序来依次获得锁</li>
</ul>
</li>
<li><p>自旋锁</p>
</li>
<li>偏向锁</li>
</ol>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol>
<li>参考：<a href="http://www.importnew.com/23792.html" target="_blank" rel="external">JVM知识点总览-高级Java工程师面试必备</a></li>
<li><p>参考:<a href="http://blog.csdn.net/hsk256/article/details/49104955" target="_blank" rel="external">java常见面试题及答案 11-20（JVM）</a></p>
</li>
<li><p>分四大块</p>
<ul>
<li>类的加载机制</li>
<li>jvm内存结构</li>
<li>GC算法 垃圾回收</li>
<li>GC分析 命令调优</li>
</ul>
</li>
</ol>
<h1 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h1><ol>
<li><p>程序计数器： 线程私有；看作当前线程所执行的字节码的行号指示器，通过计数器的值选取下一条要执行的字节码指令。</p>
</li>
<li><p>虚拟机栈： 线程私有，它的生命周期与线程相同；（即常说的堆内存和栈内存中的栈），栈帧结构，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p>
<ul>
<li>栈帧的结构<ul>
<li>局部变量表： 存放方法参数和方法内部定义的局部变量。存储的是基本数据类型，对象引用等； 通过索引定位的方式访问。</li>
<li>操作数栈：作用主要用来存储运算结果以及运算的操作数；通过压栈和出栈访问。</li>
<li>动态链接</li>
</ul>
</li>
</ul>
</li>
<li><p>本地方法栈： 虚拟机使用到的native方法</p>
</li>
<li><p>Java堆，<strong>线程共享</strong>，所有的对象实例和数组在堆上分配内存。垃圾回收的主要区域。</p>
</li>
<li><p>方法区： 各<strong>线程共享</strong>，存储已经被虚拟机加载的类信息、常量、静态变量等。运行时常量池是方法区的一部分。</p>
</li>
</ol>
<h1 id="GC-垃圾回收算法"><a href="#GC-垃圾回收算法" class="headerlink" title="GC 垃圾回收算法"></a>GC 垃圾回收算法</h1><ol>
<li><p>常用的垃圾回收算法：</p>
<ul>
<li><p>标记-清除算法：这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。</p>
</li>
<li><p>复制算法：为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存为Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区（Survior）上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)</p>
</li>
<li><p>标记-整理算法: 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（解决了内存碎片的问题）</p>
</li>
<li><p>分代回收算法：把Java堆分新生代和老年代，在新生代用复制算法（，由于对象生存期短，每次回收都会有大量对象死去），在老年代（老年代里的对象存活率较高）用标记-清理或标记-整理算法，是现代虚拟机通常采用的算法。</p>
</li>
</ul>
</li>
<li><p>GC的基本过程：</p>
<ul>
<li>堆内存分为新生代和老年代（-XX:NewRatio， 默认为1比2），而新生代又分为Eden区和两个Survivor区(-XX:SurvivorRatio)。</li>
<li>先将对象放入Eden区，如果空间不足就向其中的一个survivor区上放，如果仍然放不下就会引发一次发生在新生代的minor GC。将存活的对象放入另一个survivor区中，然后清空Eden和之前的那个survivor区的内存。</li>
<li>大对象以及长期存活的对象，进入老年代</li>
<li>空间分配担保，当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。那么执行一次Full GC以尽可能地获得老年区的空间。</li>
</ul>
</li>
<li><p>判断对象是否存活：</p>
<ul>
<li><p>判断对象是否存活有两种方法：引用计数法，可达性算法。</p>
</li>
<li><p>引用计数法：给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. 存在问题：循环引用，A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p>
</li>
<li><p>可达性分析算法：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。</p>
<ul>
<li>在java中可以作为GC Roots的对象有以下几种:<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区类静态属性引用的对象</li>
<li>方法区常量池引用的对象</li>
<li>本地方法栈JNI引用的对象(Native方法引用对象)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ol>
<li>java内存模型(JMM)是线程间通信的控制机制.JMM定义了主内存和线程之间抽象关系。<strong>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）</strong>，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。<br> 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br> 然后，线程B到主内存中去读取线程A之前已更新过的共享变量<br> <img src="../images/jmm.png" alt=""></li>
</ol>
<h1 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h1><h2 id="Java类加载过程"><a href="#Java类加载过程" class="headerlink" title="Java类加载过程"></a>Java类加载过程</h2><p>java类加载需要经历一下7个过程：</p>
<ol>
<li><p>加载<br>加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p>
<ol>
<li>通过一个类的全限定名获取该类的二进制流。（类加载器作用）</li>
<li>将该二进制流中的静态存储结构转化为方法去运行时数据结构。 </li>
<li>在内存中生成该类的Class对象，作为该类的数据访问入口。</li>
</ol>
</li>
<li><p>验证<br>验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</li>
<li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</li>
<li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</li>
<li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</li>
</ol>
</li>
<li><p>准备<br>准备阶段是为类的静态变量（即 类变量）分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<br> public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。</p>
</li>
<li><p>解析<br>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p>
</li>
<li><p>初始化<br>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p>
</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ol>
<li><p>双亲委派模型</p>
<ul>
<li>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</li>
<li>使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。比如java.lang.Object，最终都是委派顶端的启动类加载器去加载。</li>
</ul>
</li>
<li><p>什么是类加载器，类加载器有哪些<br> 实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。<br>主要有一下四种类加载器:</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li>
<li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li>
</ol>
</li>
</ol>
<h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><ol>
<li>分代内存默认分配<ul>
<li>堆大小 = 新生代 + 老年代</li>
<li>新生代 = Eden + 两个 Survivor</li>
</ul>
</li>
</ol>
<h2 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h2><ol>
<li>Serial（串行）收集器：垃圾回收时，会停掉用户线程，进行垃圾回收。</li>
<li>ParNew收集器：Serial收集器的多线程版本，并发收集器</li>
<li>Parallel(并行) Scavenge(清除)： 关注吞吐量</li>
<li>Parallel old老年代版本</li>
<li>CMS老年代</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;&amp;JVM%E7%AD%89.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程10-定时器Timer</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B10-%E5%AE%9A%E6%97%B6%E5%99%A8Timer.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B10-%E5%AE%9A%E6%97%B6%E5%99%A8Timer.html</guid>
      <pubDate>Sat, 22 Jul 2017 09:07:51 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B10-%E5%AE%9A%E6%97%B6%E5%99%A8Timer.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring-源码研究2-AOP实现</title>
      <link>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B62-AOP%E5%AE%9E%E7%8E%B0.html</link>
      <guid>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B62-AOP%E5%AE%9E%E7%8E%B0.html</guid>
      <pubDate>Tue, 18 Jul 2017 08:33:04 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B62-AOP%E5%AE%9E%E7%8E%B0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring-源码研究3-SpringMVC实现</title>
      <link>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B63-SpringMVC%E5%AE%9E%E7%8E%B0.html</link>
      <guid>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B63-SpringMVC%E5%AE%9E%E7%8E%B0.html</guid>
      <pubDate>Tue, 18 Jul 2017 08:32:32 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B63-SpringMVC%E5%AE%9E%E7%8E%B0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试-项目及其他</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E4%BB%96.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E4%BB%96.html</guid>
      <pubDate>Tue, 18 Jul 2017 02:05:59 GMT</pubDate>
      <description>
      
        面试项目
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><ul>
<li>英文： Good morning, my name is liuhang. I am glad to have a chance for this interview.  and i hope i can make a good performance today.  i am 24 years old,born in hubei xiaogao.I majored in Electronic Information Engineering in HuaZhong University of science and technology from 2011 to 2015. I am a postgraduate student now. In my spare time, I like running，especially long distance running。 Running makes me strong, and  understand the importance of sticking to the end.</li>
</ul>
<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><h2 id="TCP与UDP特点"><a href="#TCP与UDP特点" class="headerlink" title="TCP与UDP特点"></a>TCP与UDP特点</h2><ul>
<li><p>TCP</p>
<ul>
<li>TCP面向连接，先建立连接，传送数据完毕后，释放连接</li>
<li>TCP是点对点，一对一</li>
<li>可靠传输，无差错，不丢失，不重复</li>
<li>全双工</li>
<li>面向字节流,要传送的数据看成字节流</li>
</ul>
</li>
<li><p>UDP</p>
<ul>
<li>无连接的，传送是不需要连接</li>
<li>支持一对一，一对多，多对一</li>
<li>不可靠传输</li>
<li>面向报文的，直接把要传送的数据变成报文，交给ip层<br>-UDP首部开销小</li>
</ul>
</li>
</ul>
<h2 id="三次握手与四次分手"><a href="#三次握手与四次分手" class="headerlink" title="三次握手与四次分手"></a>三次握手与四次分手</h2><ul>
<li><p>三次握手</p>
<ul>
<li>客户端：SYN发送，消耗序列号x，变SYN-sent状态</li>
<li>服务的： ACK+SYN确认，消耗序列号y，ack=x+1; 边SYN-RCVD</li>
<li>客户端：ACK确认，ack=y+1; 下个报文数据的序列号为x+1</li>
</ul>
</li>
<li><p>为何要三次握手</p>
<ul>
<li></li>
</ul>
</li>
<li><p>四次分手</p>
<ul>
<li>A发送FIN,消耗序列号u  FIN-Wait1状态</li>
<li><p>B确认ACK,消耗序列号v，ack=u+1,close-wait状态； A收到确认，进入FIn-wait2状态。</p>
</li>
<li><p>B发送FIN+ACK ; 消耗序列号， 进入Last-ack最后确认状态</p>
</li>
<li>A发送ACK，序列号u+1; 进入time-wait状态； 2msl后关闭</li>
</ul>
<ul>
<li>相当于两个两次握手，第一次，A表明自己不发送数据了； 第二次，B表明自己不发送数据。</li>
</ul>
</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li><p>设计模式可以分为三大类，分别是<strong>创建型设计模式</strong>、<strong>行为型设计模式</strong>以及<strong>结构型设计模式</strong>。</p>
</li>
<li><p>创建型设计模式： 工厂模式（工厂方法模式，抽象工厂模式，简单工厂模式），构建模式，单例模式。</p>
</li>
<li><p>行为设计模式： <strong>观察者模式</strong>（ 微信公众号，更新消息，关注号的人都可以知道。）<strong>模板方法模式</strong>：定义一个算法的框架，将一些步骤延迟到子类中实现，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。 比如，一个复杂的项目的任务，通常由架构师或者高级工程师用接口或者抽象类，来将主要业务逻辑串联起来，然后根据编码难度，将具体实现分给其他人来完成。</p>
</li>
<li><p>结构型设计模式： <strong>代理模式</strong>:给目标对象提供一个代理对象，并由代理对象控制对目标对象的访问。代理场景：当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现； 访问原对象时，进行一些附加操作；</p>
</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul>
<li>三次握手：A发送连接，SYN同步为1，序号x，SYN sent; 然后B同意连接，ACK和SYN都变1，序号y，确认号为x+1,B为SYN  received;第三次，A发送确认号y+1,建立连接。</li>
<li>为何三次：防止已经失效的链接突然又到了.A发送连接，没收到确认。A重发，然后建立了连接，过了会A上次发的又到了B。</li>
</ul>
<h1 id="重点手写代码（算法）"><a href="#重点手写代码（算法）" class="headerlink" title="重点手写代码（算法）"></a>重点手写代码（算法）</h1><h2 id="单例模式（多线程）"><a href="#单例模式（多线程）" class="headerlink" title="单例模式（多线程）"></a>单例模式（多线程）</h2><ul>
<li>线程安全，使用静态内部类：饿汉式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private Singleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        //内部类的一切对外部类都是可见的，不管是否是私有成员</div><div class="line">        private static final Singleton instance = new Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        return SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">## 二分查找</div><div class="line"></div><div class="line"></div><div class="line">## 快排</div><div class="line">- 思路：以某个记录为标准，对序列进行划分，比记录小的在支点前，比记录大的，在支点后。一次划分的过程：以第一个为基准，一个头指针，一个尾指针，从后往前遍历，比基准小的，与基准换位，然后从前往后，比基准大的，同基准换位；直到头尾指针相碰。</div><div class="line"></div><div class="line"></div><div class="line">```java</div><div class="line">public class QuickSort &#123;</div><div class="line">    public static void quickSort(int[] arr) &#123;</div><div class="line">        partition(arr, 0, arr.length - 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void partition(int[] arr, int start, int end) &#123;</div><div class="line">        if (start &gt;= end) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        int key = arr[start];//基准</div><div class="line">        int left = start;</div><div class="line">        int right = end;</div><div class="line">        while (left &lt; right) &#123;</div><div class="line">            while (arr[right] &gt;= key &amp;&amp; right &gt; left) &#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            arr[left] = arr[right];//比基准小的，换到左端</div><div class="line">            arr[right] = key;//基准换到了右边</div><div class="line"></div><div class="line">            while (arr[left] &lt;= key &amp;&amp; left &lt; right) &#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            arr[right] = arr[left];//比基准大的，换到右端</div><div class="line">            arr[left] = key;//基准换到了左边</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        partition(arr, start, left - 1);</div><div class="line">        partition(arr, right + 1, end);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] arr = new int[]&#123;6, 5, 3, 1, 8, 7, 2, 9, 4, -2&#125;;</div><div class="line">        quickSort(arr);</div><div class="line">        for (int i : arr) &#123;</div><div class="line">            System.out.println(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><ul>
<li>least recently used.最近最少使用算法。</li>
<li>思路：<ol>
<li>需要的数据结构：双向链表保存数据；hashMap实现O(1)访问；</li>
<li>插入新的数据项： 如果该数据项存在，则将该节点移动到链表头部； 如果不存在，则先判断缓存是否已经满了，如果满了，则删除最后一个节点，然后，新建一个节点，放在链表头部；</li>
</ol>
</li>
</ul>
<h1 id="关于你的缺点"><a href="#关于你的缺点" class="headerlink" title="关于你的缺点"></a>关于你的缺点</h1><ol>
<li>不懂得如何拒绝别人，导致影响自己的工作进度。比如，在实验室做的项目，经常是同学碰到一个问题不会，让我帮忙，我就去帮他搞定，导致自己的东西没做完，或者做到很晚。 改进方向是，首先告诉他，自己在什么时候可以给予帮助，而不是立马放下手头的事情去帮忙，让他决定是否继续求助。 其次，在帮助他解决问题的时候，不是一手包办，而是指明一个方向，告诉他查找什么资料可以解决，或者大体是什么思路，让他尽量自己解决。</li>
<li>喜欢刨根问底的钻一些细节，导致做的一些事情不能按期完成。比如说，使用一些开源框架，就想去看看到底咋回事，导致太发散，没有聚焦点。通过时间管理，改变工作方式。</li>
</ol>
<h1 id="JDK源码阅读"><a href="#JDK源码阅读" class="headerlink" title="JDK源码阅读"></a>JDK源码阅读</h1><h2 id="HashMap原理及在JDK1-8中的优化"><a href="#HashMap原理及在JDK1-8中的优化" class="headerlink" title="HashMap原理及在JDK1.8中的优化"></a>HashMap原理及在JDK1.8中的优化</h2><ol>
<li><p>参考</p>
<ul>
<li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="external">红黑树(一)之 原理和算法详细介绍</a></li>
<li><a href="http://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="external"> HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></li>
</ul>
</li>
<li><p>hashmap数据结构</p>
<ul>
<li>hashmap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的</li>
<li>hash桶数组，table(默认长度length为16);loadFactor为负载因子(默认0.75)；hashmap能容纳的最大的键值对个数为threshold=length*loadFactor;负载因子因子可以大于1；</li>
<li>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方； 好处：在取模运算和扩容运算时可以优化。</li>
<li>hashmap解决hash冲突的办法：链地址法。拉链过长时，会严重影响性能。在JDK1.8版本中，引入了红黑树，链表长度太长（默认超过8）时，链表就转换为红黑树。（红黑树查找、增加、删除的复杂度均为O(lgN)）.</li>
</ul>
</li>
<li><p>具体功能实现</p>
<ul>
<li><strong>确定索引位置</strong>: 取key的hashcode值，高位参与运算；取模运算。 <strong>这里取模运算很巧妙</strong>，利用了table长度为2的n次方进行优化，<code>hash&amp;(length-1)</code>等价于hash对length取模运算，提高了取模运算的效率。</li>
<li><strong>put方法</strong>：键值key计算hash值得到插入的数组索引i，如果table[i]为空，则直接新建插入；否则遍历，进行插入操作。在链表或者红黑树进行插入操作。</li>
<li><strong>扩容机制</strong>:键值对数量超过threshold就要进行扩容，扩容后HashMap容量是之前容量的两倍。扩容机制非常巧妙，利用table长度为2的n次方进行优化。看hash值，新增的一位为1还是0，如果是0，索引没变，是1，索引变成“原索引+oldCap”。<ul>
<li><strong>初始化时保证table长度为2的n次方</strong>：tableSizeFor方法，找到大于等于initialCapacity的最小的2的幂。用位操作的方法，极为巧妙。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>与hashtable区别</p>
<ol>
<li>HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。</li>
<li>HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行</li>
</ol>
</li>
</ol>
<h1 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h1><h2 id="2016华为软件精英挑战赛"><a href="#2016华为软件精英挑战赛" class="headerlink" title="2016华为软件精英挑战赛"></a>2016华为软件精英挑战赛</h2><ul>
<li><p>比赛规模：    全国八个赛区，赛区32强，赛区4强进决赛，人数大概5000+</p>
</li>
<li><p>描述：在有向图中求最短路径的问题，约束是：给定了起点和终点，同时给定了一系列必经节点，必经边，求经过所有必经节点的最短路径。</p>
</li>
<li><p>求解问题的几个基本算法：</p>
<ul>
<li>Dijkstra算法：求单源最短路径，求出源点到所有点的最短路。<ul>
<li>基本思想：采用广度优先搜索。维持一个数组dist[n],表示所有顶点到源点的最短距离。初始化dist[ ]=INF,dist[start]=0;循环：找出所有dist[]中最小的点x，更新从这个点连接的所有点y:dist[y] = min( dist[y] ,dist[x] + weight[x][y]); 用到了贪心的思想。复杂度O(n^2+e).当图是稀疏图时，效果好。</li>
<li>优化：采用优先队列进行优化，O(nlgn)复杂度。</li>
</ul>
</li>
<li>Floyd算法:解决任意两点间的最短路径的一种算法<ul>
<li>基本思想：动态规划的思想，Dij=min(Dij,Dik+Dkj),三层循环，可得到结果。O(n^3)</li>
</ul>
</li>
</ul>
</li>
<li><p>最终解决思路： 指派问题结合分支定界来结局，可以把这个看成一个指派问题，根据有向图信息，得到一个费用矩阵(即邻接矩阵)，求一个最小指派，每个节点都要连接另一个节点，这样会形成一系列的环，然后用分支定界来破开环，最后形成一个环  即可。求指派问题： 用匈牙利算法，km算法（效率更高）。</p>
</li>
</ul>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><ol>
<li>统一网元采集器平台；项目描述：后端开发，对分布在各个地方的网元设备的信息进行采集，用于对网元设备的维护。系统分为：网元信息管理、采集模板管理、采集脚本管理、采集任务管理等模块。</li>
<li>贡献</li>
</ol>
<h2 id="项目中的重难点"><a href="#项目中的重难点" class="headerlink" title="项目中的重难点"></a>项目中的重难点</h2><ol>
<li><p>敏感词检测问题： 使用<strong>字典树（前缀树）-数据结构</strong>，实现敏感词检测替换</p>
<ul>
<li>字典树的结构：一个树的结构，比如字符串，有公共前缀的部分，路径相同。 通常会在节点设置一个标志位，表示该节点是不是末尾。</li>
<li>效率： 核心思想是空间换时间，用字符串的公共前缀，来减少无谓的比较。</li>
<li>用于字符串检索：沿路径比较，O(n)复杂度；</li>
</ul>
</li>
<li><p>异步事件框架，个人实现；使用生产者消费者模式，自己实现一个简单的异步事件框架。</p>
<ul>
<li>应用场景：学术论坛中，增加提问；人员管理，excel表导入导出，解析；</li>
<li>生产者消费者模式,生产者激发事件，将事件存放在阻塞队列中，消费者从阻塞队列中取出事件，然后执行事件；</li>
<li>涉及到阻塞队列：支持阻塞的插入和移除方法。队列满时，队列会阻塞插入元素的线程；队列为空时，获取元素的线程会等待队列为空。</li>
</ul>
</li>
</ol>
<h2 id="项目改成分布式"><a href="#项目改成分布式" class="headerlink" title="项目改成分布式"></a>项目改成分布式</h2><ol>
<li><p>把数据库和应用从一台服务器，分到两台服务器。</p>
</li>
<li><p>使用集群</p>
<ul>
<li>引入负载均衡，部署多台应该服务器。<ul>
<li>会用session共享问题，session应该保存在哪个机器上。</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式缓存 ”读多写少“的场景</p>
<ul>
<li>缓存的数据更新的算法，LRU(最近最久未使用算法)</li>
<li>缓存命中率</li>
<li>缓存服务器扩容：尽量平滑，一致hash算法</li>
</ul>
</li>
<li><p><strong>异步操作</strong></p>
<ul>
<li>使用消息队列，进行异步处理。生产者消费者模式。通过异步处理，将短时间高并发的事件，存储在消息队列中，从而削平高并发时期的任务。</li>
</ul>
</li>
</ol>
<h2 id="项目中任务调度多任务依赖"><a href="#项目中任务调度多任务依赖" class="headerlink" title="项目中任务调度多任务依赖"></a>项目中任务调度多任务依赖</h2><ol>
<li>一个任务节点成功执行完之后，查看是否有子任务，有则并发执行所有子节点任务。</li>
<li>一个任务被触发执行，先查看自己又哪些父任务，如果几个父任务都成功执行，则此任务触发执行，否则跳过。</li>
</ol>
<h2 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h2><ol>
<li>体系结构<ul>
<li>Job</li>
<li>JobDetail 时执行的Job(任务)</li>
<li>Trigger 是一个类，描述触发Job执行的时间触发规则</li>
<li>Scheduler： 代表一个Quartz的独立运行容器， Trigger和JobDetail可以注册到Scheduler中</li>
</ul>
</li>
</ol>
<p>## </p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h2><ol>
<li><p>应注意的问题：</p>
<ul>
<li>如果和网站原有业务部署在一起，会对现有业务造成冲击</li>
<li>直接下单：如果下单页面是个确定的普通的URL，可以直接下单。下单页面的url在服务的应该加入随机数，url动态化</li>
</ul>
</li>
<li><p>后端如何优化</p>
<ul>
<li>web层，控制useId访问频率，比如同一个用户，某个时间内访问返回同一个页面。</li>
<li>服务层，用消息队列，对秒杀请求(下单)，做异步处理，</li>
<li>缓存，对秒杀的商品，典型的 读多写少，进行缓存处理</li>
</ul>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="hash索引B-索引"><a href="#hash索引B-索引" class="headerlink" title="hash索引B+索引"></a>hash索引B+索引</h2><h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ol>
<li>布隆过滤器：数据是否在集合中,</li>
<li>Bitmap:</li>
<li>堆:海量数据前n大</li>
<li></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E4%BB%96.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring-源码研究1-IOC容器实现</title>
      <link>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B61-ioc%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0.html</link>
      <guid>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B61-ioc%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0.html</guid>
      <pubDate>Mon, 17 Jul 2017 07:28:05 GMT</pubDate>
      <description>
      
        研究Spring源码！
      
      </description>
      
      <comments>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B61-ioc%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring-面试问题总结</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Spring-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Spring-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Sun, 16 Jul 2017 02:30:21 GMT</pubDate>
      <description>
      
        Spring总结，面试问题总结
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.importnew.com/15851.html" target="_blank" rel="external">Spring面试问答Top 25</a></li>
</ol>
<h1 id="Spring是什么，简单说下Spring"><a href="#Spring是什么，简单说下Spring" class="headerlink" title="Spring是什么，简单说下Spring"></a>Spring是什么，简单说下Spring</h1><ol>
<li>Spring是分层的Java EE/SE一站式开源框架，它以IoC控制反转和AOP（面向切面编程）为核心。</li>
</ol>
<h1 id="Spring优点"><a href="#Spring优点" class="headerlink" title="Spring优点"></a>Spring优点</h1><ul>
<li>IoC支持方便解耦，简化开发</li>
<li>AOP编程的支持</li>
<li>声明式事务的支持</li>
<li>方便程序的测试</li>
<li>方便集成各种优秀框架</li>
<li>降低JavaEE API的使用难度</li>
</ul>
<h1 id="控制反转IoC和依赖注入DI"><a href="#控制反转IoC和依赖注入DI" class="headerlink" title="控制反转IoC和依赖注入DI"></a>控制反转IoC和依赖注入DI</h1><ul>
<li>控制反转：借助第三方（即容器），把新建对象的控制权，交给了容器，由容器负责对象新建装配</li>
<li>依赖注入：实现控制反转的方式有依赖注入和依赖查找</li>
<li>Spring中依赖注入DI的类型：构造函数注入，属性注入；</li>
</ul>
<h1 id="Spring中装配Bean的几种方式"><a href="#Spring中装配Bean的几种方式" class="headerlink" title="Spring中装配Bean的几种方式"></a>Spring中装配Bean的几种方式</h1><ul>
<li>现在有四种方式<ul>
<li>基于XML配置</li>
<li>基于注解配置</li>
<li>基于Java配置</li>
<li>基于Groovy 动态语言配置</li>
</ul>
</li>
</ul>
<h1 id="Spring中用到了哪些设计模式"><a href="#Spring中用到了哪些设计模式" class="headerlink" title="Spring中用到了哪些设计模式"></a>Spring中用到了哪些设计模式</h1><ol>
<li>代理模式,</li>
<li>工厂模式</li>
<li>单例模式</li>
<li>模板方法模式：用来解决代码重复的问题</li>
<li>策略模式：Resource与ResourceLoader</li>
</ol>
<h1 id="描述一下-Spring-Bean的生命周期"><a href="#描述一下-Spring-Bean的生命周期" class="headerlink" title="描述一下 Spring Bean的生命周期"></a>描述一下 Spring Bean的生命周期</h1><ul>
<li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li>
<li>Spring根据bean的定义填充所有的属性。</li>
<li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li>
<li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li>
<li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li>
<li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li>
<li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li>
<li>如果bean实现了 DisposableBean，它将调用destroy()方法。<br>关键节点</li>
</ul>
<ol>
<li>实例化，前后InstantiationAwareBeanPostProcessor接口的方法；</li>
<li>设置属性值， 后 BeanNameAware和BeanFactoryAware，感知BeanName和BeanFactory</li>
<li>初始化方法（init-method） 前后 BeanPostProcessor接口方法，对Bean进行处理，前nitializingBean处理</li>
<li>销毁方法(destory-method)，前DisposeBean处理</li>
</ol>
<p>三类方法调用</p>
<ol>
<li>Bean自身的方法调用，构造函数来实例化Bean,Setter方法设置Bean的属性，init_method和destory_method方法</li>
<li>Bean级生命周期接口方法（Bean自己实现的接口），BeanNameAware和BeanFactoryAware,InitializingBean和DisposeBean</li>
<li>容器及生命周期接口方法，InstantiationAwareBeanPostProcessor和BeanPostProcessor接口，分别在实例化和初始化前后，对Bean进行处理</li>
</ol>
<h1 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h1><ol>
<li>BeanFactory是Spring最核心的接口，它是工厂模式的实现，来负责实例化Bean并建立Bean之间的依赖关系，控制Bean的生命周期；</li>
<li>ApplicationContext应用上下文，它是建立在BeanFactory基础上（ApplicationContext接口继承ListableBeanFactory接口，ListableBeanFactory继承BeanFactory接口）；BeanFactory更加底层，它面对Spring本身；而ApplicationContext面向使用Spring的开发者；它的主要实现者有ClassPathXmlApplicationContext，FileSystemXmlApplicationContext等</li>
<li>ApplicationContext提供了更多面向实际应用的功能<ul>
<li>国际化消息访问功能</li>
<li>统一的资源读取方式</li>
<li>能够发布事件，并允许注册相应的事件监听器；</li>
</ul>
</li>
</ol>
<h1 id="FactoryBean和BeanFactory"><a href="#FactoryBean和BeanFactory" class="headerlink" title="FactoryBean和BeanFactory"></a>FactoryBean和BeanFactory</h1><ol>
<li>FactoryBean，顾名思义，工厂Bean（像工厂一样的Bean）,是一个能产生或者修饰对象的Bean，可以在ioc容器中被管理,用户通过实现FacatoryBean接口定制实例化Bean的逻辑,使用“&amp;”前缀，获取FactoryBean产生的对象（getObject方法）；</li>
<li>BeanFactory，ioc容器，对Bean进行管理；</li>
</ol>
<h1 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h1><ol>
<li>singleton 仅存在一个Bean实例</li>
<li>prototype 每次调用Bean时，都返回一个新实例</li>
<li>request 每次http请求，创建一个新的Bean</li>
<li>session 同一个Http Session，共享一个Bean</li>
<li>globalSession global-session和Portlet应用相关；</li>
</ol>
<h1 id="Spring内部Bean"><a href="#Spring内部Bean" class="headerlink" title="Spring内部Bean"></a>Spring内部Bean</h1><ol>
<li>内部bean和Java匿名内部类相似，仅仅被某一个bean调用</li>
</ol>
<h1 id="基于注解配置，说说所知道的注解"><a href="#基于注解配置，说说所知道的注解" class="headerlink" title="基于注解配置，说说所知道的注解"></a>基于注解配置，说说所知道的注解</h1><ol>
<li>@Component注解，定义Bean； 对应的在分层结构中，DAO层，@Repository；Service层：@Service； Web层：@Controller</li>
<li>@Autowired注解，自动装配（required= false），@Lazy注解，延迟注入</li>
<li>@Configuration注解，基于Java类配置；@Bean注解； </li>
<li>Spring MVC注解，@RequestMapping</li>
<li>Spring Cache, @Cacheable注解</li>
</ol>
<h1 id="Spring的单例Bean是线程安全的吗"><a href="#Spring的单例Bean是线程安全的吗" class="headerlink" title="Spring的单例Bean是线程安全的吗"></a>Spring的单例Bean是线程安全的吗</h1><ol>
<li>并没有对单例bean进行任何多线程的封装处理；自行去保证线程安全</li>
</ol>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="Spring-MVC过程"><a href="#Spring-MVC过程" class="headerlink" title="Spring MVC过程"></a>Spring MVC过程</h2><ol>
<li>DispatcherServlet接收请求</li>
<li>HanddlerMappig来寻找对应的处理器(Controller)</li>
<li>DispatcherServlet根据查找到的处理器，通过HandlerAdapter处理器适配器，调用处理器的方法，</li>
<li>处理器完成业务逻辑后，返回ModelAndView</li>
<li>DispatcherServlet调用试图解析器解析视图，视图渲染，得到最后的页面</li>
<li>返回。</li>
</ol>
<h1 id="SpringBoot是什么，对SpringBoot的理解"><a href="#SpringBoot是什么，对SpringBoot的理解" class="headerlink" title="SpringBoot是什么，对SpringBoot的理解"></a>SpringBoot是什么，对SpringBoot的理解</h1><ul>
<li>从命名，boot有启动器的含义，SpirngBott由一系列启动器组成，快速构建基于Spirng的应用，简化开发过程。</li>
<li>举例：直接从一个Application主类启动，@SpringBootApplication注解</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Spring-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式7-策略模式</title>
      <link>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</link>
      <guid>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</guid>
      <pubDate>Tue, 11 Jul 2017 16:00:03 GMT</pubDate>
      <description>
      
        策略模式，策略模式在Spring中的使用
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="策略模式在Spring中的使用"><a href="#策略模式在Spring中的使用" class="headerlink" title="策略模式在Spring中的使用"></a>策略模式在Spring中的使用</h1><ul>
<li>Resource与ResourceLoader配合使用,来访问资源，读取配置文件信息等。</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程7-Future与Callable,FutureTask</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B7-Future%E4%B8%8ECallable-FutureTask.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B7-Future%E4%B8%8ECallable-FutureTask.html</guid>
      <pubDate>Mon, 03 Jul 2017 13:07:08 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/ghsau/article/details/7451464&quot; tar
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.csdn.net/ghsau/article/details/7451464" target="_blank" rel="external">Java线程(七)：Callable和Future|csdn博客</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B7-Future%E4%B8%8ECallable-FutureTask.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程7-线程池</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B9-%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B9-%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</guid>
      <pubDate>Mon, 03 Jul 2017 12:44:25 GMT</pubDate>
      <description>
      
        线程池原理，线程池框架源码分析
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p><img src="../images/threadpool.png" alt=""></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><ul>
<li>线程池核心代码<br><img src="../images/线程池源码.png" alt=""></li>
</ul>
<ul>
<li>工作线程<ul>
<li>工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，<strong>还会循环获取工作队列里的任务来执行</strong><br><img src="../images/多线程worker.png" alt=""></li>
</ul>
</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B9-%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程8-信号量</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8-%E4%BF%A1%E5%8F%B7%E9%87%8F.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8-%E4%BF%A1%E5%8F%B7%E9%87%8F.html</guid>
      <pubDate>Mon, 03 Jul 2017 12:43:22 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8-%E4%BF%A1%E5%8F%B7%E9%87%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程6-阻塞队列</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html</guid>
      <pubDate>Mon, 03 Jul 2017 11:59:22 GMT</pubDate>
      <description>
      
        阻塞队列，非阻塞队列，待详细总结
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.importnew.com/6695.html" target="_blank" rel="external">阻塞队列实现生产者消费者模式</a></li>
<li><a href="http://www.cnblogs.com/yzlpersonal/p/5231649.html" target="_blank" rel="external">生产者-消费者 用非阻塞队列、Object.wait()、Object.notify()实现</a></li>
<li><a href="http://www.chongchonggou.com/g_645129056.html" target="_blank" rel="external">高并发:阻塞队列 实现生产者-消费者模式</a></li>
</ol>
<h1 id="阻塞队列实现原理"><a href="#阻塞队列实现原理" class="headerlink" title="阻塞队列实现原理"></a>阻塞队列实现原理</h1>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程5-设计线程安全的类</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B5-%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B5-%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB.html</guid>
      <pubDate>Sat, 01 Jul 2017 12:55:04 GMT</pubDate>
      <description>
      
        介绍如何设计线程安全的类
      
      </description>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B5-%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程4-ThreadLocal</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-ThreadLocal.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-ThreadLocal.html</guid>
      <pubDate>Sat, 01 Jul 2017 09:47:42 GMT</pubDate>
      <description>
      
        ThreadLocal
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h1><ol>
<li>线程局部变量</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="http://blog.zhangjikai.com/2017/03/29/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-ThreadLocal/" target="_blank" rel="external">ThreadLocal详解</a></p>
</li>
<li><p>ThreadLocal(线程变量副本)</p>
<ul>
<li>Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。</li>
<li>采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。</li>
<li>ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。</li>
<li>ThreadLocal在spring中发挥着巨大的作用，在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影。</li>
<li>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-ThreadLocal.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程1-线程安全概述</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.html</guid>
      <pubDate>Thu, 29 Jun 2017 15:09:02 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;什么是线程安全性&quot;&gt;&lt;a href=&quot;#什么是线程安全性&quot; class=&quot;headerlink&quot; title=&quot;什么是线程安全性&quot;&gt;&lt;/a&gt;什么是线程安全性&lt;/h1&gt;&lt;h2 id=&quot;线程安全类：&quot;&gt;&lt;a href=&quot;#线程安全类：&quot; class=&quot;headerli
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h1><h2 id="线程安全类："><a href="#线程安全类：" class="headerlink" title="线程安全类："></a>线程安全类：</h2><ul>
<li>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么久称这个类是线程安全的</li>
<li>在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程3-Java内存模型</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</guid>
      <pubDate>Wed, 28 Jun 2017 15:17:34 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Java内存模型参考&quot;&gt;&lt;a href=&quot;#Java内存模型参考&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型参考&quot;&gt;&lt;/a&gt;Java内存模型参考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://ifeve.com/java
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Java内存模型参考"><a href="#Java内存模型参考" class="headerlink" title="Java内存模型参考"></a>Java内存模型参考</h1><ol>
<li><a href="http://ifeve.com/java-memory-model-6/" target="_blank" rel="external">Java内存模型|讲的非常详细</a></li>
</ol>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="两个关键方面"><a href="#两个关键方面" class="headerlink" title="两个关键方面"></a>两个关键方面</h2><ol>
<li>可见性 Memory Visibility</li>
<li>竞态条件（Race Condition）</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ol>
<li>可见性： assign store </li>
<li>防止指令重排</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人计划至8.5</title>
      <link>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B37%E6%9C%88%E5%BA%95.html</link>
      <guid>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B37%E6%9C%88%E5%BA%95.html</guid>
      <pubDate>Wed, 28 Jun 2017 11:11:57 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;总体：Spring-JVM，多线程&quot;&gt;&lt;a href=&quot;#总体：Spring-JVM，多线程&quot; class=&quot;headerlink&quot; title=&quot;总体：Spring,JVM，多线程&quot;&gt;&lt;/a&gt;总体：Spring,JVM，多线程&lt;/h1&gt;&lt;h2 id=&quot;书&quot;&gt;&lt;a
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="总体：Spring-JVM，多线程"><a href="#总体：Spring-JVM，多线程" class="headerlink" title="总体：Spring,JVM，多线程"></a>总体：Spring,JVM，多线程</h1><h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><ol>
<li>《深入理解Java虚拟机》</li>
<li>《Java并发编程实战》</li>
<li>《精通Spring4.x 企业应用开发实战》</li>
<li>《Java多线程编程核心技术》</li>
</ol>
<h2 id="核心提升"><a href="#核心提升" class="headerlink" title="核心提升"></a>核心提升</h2><ol>
<li>Java并发编程学习 </li>
<li>Quartz</li>
<li>消息中间件知识，KafKa复习</li>
</ol>
<h1 id="每日计划"><a href="#每日计划" class="headerlink" title="每日计划"></a>每日计划</h1><pre><code>- 阶段1到阶段6（8.3号），每日一个编程真题（公司笔试真题）
- 阶段7开始，每日刷公司真题和编程题，自由复习阶段，查漏补缺
</code></pre><h2 id="阶段一：Spring复习巩固，完成小项目一个7天"><a href="#阶段一：Spring复习巩固，完成小项目一个7天" class="headerlink" title="阶段一：Spring复习巩固，完成小项目一个7天"></a>阶段一：Spring复习巩固，完成小项目一个7天</h2><ol>
<li><p>7.14看书</p>
<ul>
<li>《Spring4.x》7.8.9三章看完（Spring aop内容），结合18论坛项目的代码</li>
</ul>
</li>
<li><p>7.15总结</p>
<ul>
<li>总结Spirng ioc、aop、事物</li>
<li>自己实现简单ioc与aop，研究ioc与aop的源码(结合深入解析那本书)</li>
</ul>
</li>
<li><p>7.16看书</p>
<ul>
<li>《Spring4.x》10.11.12.13.14 Spring数据篇</li>
</ul>
</li>
<li><p>7.17看书</p>
<ul>
<li>《Spring4.x》15 Spring缓存，memchched与redis复习</li>
</ul>
</li>
<li><p>7.18总结</p>
<ul>
<li>总结Spirng数据库操作，Hibernate与Mybatis相关，缓存相关，数据库常见问题</li>
</ul>
</li>
<li><p>7.19看书</p>
<ul>
<li>《Spring4.x》17 SpringMvc复习总结完毕，结合18论坛代码，写完跑通</li>
</ul>
</li>
<li><p>7.20总结</p>
<ul>
<li>Spring mvc总结</li>
<li><strong>Spring面经总结，项目中的Spring遇到的问题及解决方法：包括Spirng ioc,aop,事物，数据库，spring mvc,spring boot</strong></li>
</ul>
</li>
</ol>
<h2 id="阶段二：多线程复习巩固5天"><a href="#阶段二：多线程复习巩固5天" class="headerlink" title="阶段二：多线程复习巩固5天"></a>阶段二：多线程复习巩固5天</h2><ol>
<li><p>7.21看书</p>
<ul>
<li>《Java多线程编程核心技术》1-3章</li>
</ul>
</li>
<li><p>7.22看书</p>
<ul>
<li>《Java多线程编程核心技术》4-6章</li>
</ul>
</li>
<li><p>7.23看书</p>
<ul>
<li>《Spring4.x》16 Spirng任务调度，exectue框架  Quatrz复习</li>
</ul>
</li>
<li><p>7.24看书</p>
<ul>
<li>Quatrz学习总结</li>
</ul>
</li>
<li><p>7.25 </p>
<ul>
<li><strong>多线程面试总结</strong></li>
<li><strong>整理项目中遇到的多线程问题，及解决方法</strong></li>
</ul>
</li>
</ol>
<h2 id="阶段三-消息中间件突击复习，kafka学习4天"><a href="#阶段三-消息中间件突击复习，kafka学习4天" class="headerlink" title="阶段三: 消息中间件突击复习，kafka学习4天"></a>阶段三: 消息中间件突击复习，kafka学习4天</h2><ol>
<li>7.26</li>
<li>7.27</li>
<li>7.28</li>
<li>7.29</li>
</ol>
<h2 id="阶段四：JVM复习总结3天"><a href="#阶段四：JVM复习总结3天" class="headerlink" title="阶段四：JVM复习总结3天"></a>阶段四：JVM复习总结3天</h2><ol>
<li><p>7.30看书</p>
<ul>
<li>JVM书</li>
</ul>
</li>
<li><p>7.31看书</p>
<ul>
<li>JVM书</li>
</ul>
</li>
<li><p>8.1总结<br>-JVM面经总结</p>
<ul>
<li><strong>项目中遇到的JVM调优问题及解决方法</strong></li>
</ul>
</li>
</ol>
<h2 id="阶段五：-设计模式总结1天"><a href="#阶段五：-设计模式总结1天" class="headerlink" title="阶段五： 设计模式总结1天"></a>阶段五： 设计模式总结1天</h2><ol>
<li>8.2号<ul>
<li><strong>设计模式常见面试问题总结</strong></li>
<li>手写单例模式准备（多线程情况）</li>
</ul>
</li>
</ol>
<h2 id="阶段六：-Sql基础复习1天"><a href="#阶段六：-Sql基础复习1天" class="headerlink" title="阶段六： Sql基础复习1天"></a>阶段六： Sql基础复习1天</h2><ol>
<li>8.3号<ul>
<li>mysql必知必会</li>
<li>刷Sql题目6+</li>
</ul>
</li>
</ol>
<h2 id="阶段七：刷公司真题，剑指offer及查漏补缺复习"><a href="#阶段七：刷公司真题，剑指offer及查漏补缺复习" class="headerlink" title="阶段七：刷公司真题，剑指offer及查漏补缺复习"></a>阶段七：刷公司真题，剑指offer及查漏补缺复习</h2><ol>
<li><p>8.4号</p>
<ul>
<li>排序算法复习巩固（手写排序算法）</li>
<li>排序的选择题巩固</li>
</ul>
</li>
<li><p>8.5号</p>
<ul>
<li>公司真题之阿里</li>
</ul>
</li>
<li><p>8.</p>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B37%E6%9C%88%E5%BA%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程2-Java多线程基础</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</guid>
      <pubDate>Wed, 28 Jun 2017 09:16:17 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;多线程与并发参考资料&quot;&gt;&lt;a href=&quot;#多线程与并发参考资料&quot; class=&quot;headerlink&quot; title=&quot;多线程与并发参考资料&quot;&gt;&lt;/a&gt;多线程与并发参考资料&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://ifeve.com/java-c
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="多线程与并发参考资料"><a href="#多线程与并发参考资料" class="headerlink" title="多线程与并发参考资料"></a>多线程与并发参考资料</h1><ol>
<li><a href="http://ifeve.com/java-concurrency-thread-directory/" target="_blank" rel="external">Java并发性和多线程</a></li>
</ol>
<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="管理线程的几种方法"><a href="#管理线程的几种方法" class="headerlink" title="管理线程的几种方法"></a>管理线程的几种方法</h2><p><img src="../images/管理线程的几种方法.png" alt=""></p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ol>
<li>实现Runnable接口</li>
<li>继承Thread类</li>
<li>都通过start方法，启动线程。优先runnable接口，可实现多个接口</li>
</ol>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ol>
<li>每一个对象都隐含着一个锁对象，这个锁对象就是用来解决并发问题的互斥量（mutex）。要调用一个对象的synchronized方法的线程，必须持有这个对象的锁对象，在执行完毕之后，必须释放这个锁对象，以让别的线程得到这个锁对象。</li>
<li><a href="http://ifeve.com/synchronized-blocks/" target="_blank" rel="external">同步</a></li>
</ol>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ul>
<li>以下三个方法，仅在synchronized方法中可以调用</li>
<li>wait,告知被调用的线程，放弃锁，直到其他线程进入并调用notify唤醒</li>
<li>notify</li>
<li>notifyAll</li>
<li><a href="http://ifeve.com/thread-signaling/#wait_notify" target="_blank" rel="external">notify|wait详解</a></li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM-程序编译与代码优化</title>
      <link>http://liuhang.net.cn/JVM-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html</link>
      <guid>http://liuhang.net.cn/JVM-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html</guid>
      <pubDate>Wed, 28 Jun 2017 08:06:04 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Java语法糖&quot;&gt;&lt;a href=&quot;#Java语法糖&quot; class=&quot;headerlink&quot; title=&quot;Java语法糖&quot;&gt;&lt;/a&gt;Java语法糖&lt;/h1&gt;&lt;h2 id=&quot;泛型与类型擦除&quot;&gt;&lt;a href=&quot;#泛型与类型擦除&quot; class=&quot;headerlink
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h1><h2 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h2><h2 id="自动拆箱与装箱"><a href="#自动拆箱与装箱" class="headerlink" title="自动拆箱与装箱"></a>自动拆箱与装箱</h2>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/JVM-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM-Java内存区域与内存溢出异常</title>
      <link>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html</link>
      <guid>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html</guid>
      <pubDate>Wed, 28 Jun 2017 08:01:39 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;内存空间（运行时数据区）&quot;&gt;&lt;a href=&quot;#内存空间（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;内存空间（运行时数据区）&quot;&gt;&lt;/a&gt;内存空间（运行时数据区）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../images/jvmneicun.
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="内存空间（运行时数据区）"><a href="#内存空间（运行时数据区）" class="headerlink" title="内存空间（运行时数据区）"></a>内存空间（运行时数据区）</h1><p><img src="../images/jvmneicun.png" alt=""> </p>
<ol>
<li>程序计数器： 线程私有；看作当前线程所执行的字节码的行号指示器</li>
<li>虚拟机栈： 线程私有；（即常说的堆内存和栈内存中的栈），栈帧结构，存储局部变量表，操作数等</li>
<li>本地方法栈： 虚拟机使用到的native方法</li>
<li>Java堆，<strong>线程共享</strong>，所有的对象实例和数组在堆上分配内存。垃圾回收的主要区域。</li>
<li>方法区： 各<strong>线程共享</strong>，存储已经被虚拟机加载的类信息、常量、静态变量等。运行时常量池是方法区的一部分。</li>
</ol>
<h1 id="虚拟机参数"><a href="#虚拟机参数" class="headerlink" title="虚拟机参数"></a>虚拟机参数</h1><ol>
<li>JVM启动参数分为三类：<ul>
<li>标准参数(-):所有的JVM实现都必须实现这些参数的功能，而且向后兼容; 命令行 java -? 查看参数</li>
<li>非标准参数(-X):默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容；命令行 java -X 查看参数</li>
<li>非稳定参数(-XX):此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用；</li>
</ul>
</li>
<li>常用参数设置<ul>
<li>最大堆和初始堆<code>-Xms</code>初始堆内存大小，<code>-Xmx</code>最大堆内存大小</li>
<li>新生代配置<code>-Xmn</code>新生代内存大小，<code>-XX:SurvivorRatio</code>设置新生代eden空间和from/to空间比例；<code>-XX:NewRatio</code>老年代和新生代比例</li>
<li>系统参数查看：<code>-XX:+PrintVMOptions</code>打印虚拟机接收到的显示参数</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM-线程安全与锁优化</title>
      <link>http://liuhang.net.cn/JVM-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html</link>
      <guid>http://liuhang.net.cn/JVM-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html</guid>
      <pubDate>Wed, 28 Jun 2017 07:59:27 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JVM-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM-Java内存模型与线程</title>
      <link>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</link>
      <guid>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</guid>
      <pubDate>Wed, 28 Jun 2017 07:58:05 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaWeb基础-Session与Cookie</title>
      <link>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-Session%E4%B8%8ECookie.html</link>
      <guid>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-Session%E4%B8%8ECookie.html</guid>
      <pubDate>Wed, 28 Jun 2017 02:21:42 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-Session%E4%B8%8ECookie.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaWeb基础-JDBC</title>
      <link>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-JDBC.html</link>
      <guid>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-JDBC.html</guid>
      <pubDate>Wed, 28 Jun 2017 02:18:41 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-JDBC.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaWeb基础-servlet</title>
      <link>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-servlet.html</link>
      <guid>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-servlet.html</guid>
      <pubDate>Wed, 28 Jun 2017 02:16:56 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-servlet.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java基础增强-Lambda 表达式</title>
      <link>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</link>
      <guid>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</guid>
      <pubDate>Tue, 27 Jun 2017 07:29:06 GMT</pubDate>
      <description>
      
        Java8 Lambda 表达式，函数式编程
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="external">深入浅出 Java 8 Lambda 表达式</a></li>
</ol>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="语法糖的概念"><a href="#语法糖的概念" class="headerlink" title="语法糖的概念"></a>语法糖的概念</h2><ul>
<li>指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础算法-迪杰斯特拉算法</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html</guid>
      <pubDate>Wed, 21 Jun 2017 12:27:15 GMT</pubDate>
      <description>
      
        Dijkstra算法，Dijkstra算法堆优化（队列）,未详细总结，给出参考的博文。
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Dijkstra算法详细介绍"><a href="#Dijkstra算法详细介绍" class="headerlink" title="Dijkstra算法详细介绍"></a>Dijkstra算法详细介绍</h1><ol>
<li>参考：<a href="http://www.it165.net/pro/html/201407/16957.html" target="_blank" rel="external">图算法单源最短路径Dijkstra算法</a></li>
</ol>
<h1 id="Dijkstra算法优化"><a href="#Dijkstra算法优化" class="headerlink" title="Dijkstra算法优化"></a>Dijkstra算法优化</h1><ol>
<li>参考：<a href="http://blog.leanote.com/post/coolboy/duiyouhu" target="_blank" rel="external">带堆优化的Dijkstra</a></li>
</ol>
<h1 id="Dijkstra实现（java）"><a href="#Dijkstra实现（java）" class="headerlink" title="Dijkstra实现（java）"></a>Dijkstra实现（java）</h1><ol>
<li><a href="https://github.com/husthang/zte2017/blob/master/tsp/code/src/main/java/route/Dijkstra.java" target="_blank" rel="external">我的实现|java|邻接表</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>2017中兴捧月杯-初赛总结</title>
      <link>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%88%9D%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%88%9D%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Mon, 19 Jun 2017 08:56:24 GMT</pubDate>
      <description>
      
        2017中兴捧月杯,初赛总结，迪杰斯特拉派
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="赛题描述"><a href="#赛题描述" class="headerlink" title="赛题描述"></a>赛题描述</h1><ol>
<li>赛题链接：<a href="http://challenge.zte.net/index.php" target="_blank" rel="external">迪杰斯特拉派赛题</a></li>
<li>赛题抽象，给定一个无向图G，已知起点s、终点e、必经点集R、必经边集B、禁忌边集F和访问节点数限制k，要求寻找一条从起点s到终点e的最短路径，同时满足以下几个限制条件：（1）不能经过禁忌边集F中的任意边（2）必须经过必经点R集中的所有顶点（3）必须经过必经边集B中的所有边（4）路径访问的节点数量不超过k。</li>
<li>赛题说明文档</li>
</ol>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><a href="http://liuhang.net.cn/paper.pdf">paper|版权归中兴公司所有</a></li>
<li><a href="https://github.com/husthang/zte2017" target="_blank" rel="external">代码|版权归中兴公司所有</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%88%9D%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>2017中兴捧月杯-决赛总结</title>
      <link>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%86%B3%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%86%B3%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Mon, 19 Jun 2017 08:55:53 GMT</pubDate>
      <description>
      
        vector bin packing,向量装箱问题,二维向量装箱问题分支定界法,2017中兴捧月杯决赛，网络优化问题，线性规划
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="向量装箱问题"><a href="#向量装箱问题" class="headerlink" title="向量装箱问题"></a>向量装箱问题</h1><h2 id="装箱问题介绍"><a href="#装箱问题介绍" class="headerlink" title="装箱问题介绍"></a>装箱问题介绍</h2><ol>
<li><a href="https://people.math.gatech.edu/~tetali/PUBLIS/CKPT.pdf" target="_blank" rel="external">对装箱问题的详细介绍|Multidimensional Bin Packing and Other Related Problems: A Survey ∗</a></li>
<li><a href="http://www.or.deis.unibo.it/knapsack.html" target="_blank" rel="external">背包问题及装箱问题|各种算法及详细介绍</a></li>
<li><a href="http://vpsolver.dcc.fc.up.pt/" target="_blank" rel="external">向量装箱问题求解器</a>，这个是针对多维向量装箱问题的求解器，功能非常强大。</li>
</ol>
<h2 id="二维向量装箱问题"><a href="#二维向量装箱问题" class="headerlink" title="二维向量装箱问题"></a>二维向量装箱问题</h2><ol>
<li>参考一：A BRANCH-AND-BOUND ALGORITHM FOR THE TWO-DIMENSIONAL VECTOR PACKING PROBLEM</li>
<li>参考二：<a href="http://www.or.deis.unibo.it/kp/Chapter8.pdf" target="_blank" rel="external">Knapsack Problems|Chapter8,bin packing problems</a></li>
<li><a href="https://github.com/husthang/zte2017" target="_blank" rel="external">二维向量装箱问题代码|包含基本的FFD|包含分支定界精确求解方法</a></li>
</ol>
<h1 id="网络优化问题"><a href="#网络优化问题" class="headerlink" title="网络优化问题"></a>网络优化问题</h1>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%86%B3%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础算法-贪心法</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E6%B3%95.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E6%B3%95.html</guid>
      <pubDate>Mon, 05 Jun 2017 02:10:30 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;贪心思想概念&quot;&gt;&lt;a href=&quot;#贪心思想概念&quot; class=&quot;headerlink&quot; title=&quot;贪心思想概念&quot;&gt;&lt;/a&gt;贪心思想概念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="贪心思想概念"><a href="#贪心思想概念" class="headerlink" title="贪心思想概念"></a>贪心思想概念</h1><ol>
<li>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</li>
</ol>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="../images/贪心法.png" alt=""></p>
<ol>
<li>落单的数<ul>
<li><a href="http://www.lintcode.com/zh-cn/problem/single-number/" target="_blank" rel="external">落单的数</a></li>
<li>思路：按位或运算</li>
</ul>
</li>
<li>主元素</li>
<li><p>加油站</p>
<ul>
<li><a href="http://www.lintcode.com/zh-cn/problem/gas-station/#" target="_blank" rel="external">加油站</a></li>
<li>思路： 只要汽油量大于等于总的消耗，那么肯定有解。排除汽油量小于消耗量的点即可。</li>
</ul>
</li>
<li><p>下一个排列（难）</p>
<ul>
<li><a href="http://www.lintcode.com/zh-cn/problem/next-permutation/#" target="_blank" rel="external">下一个排列|lintcode</a></li>
<li><p>思路： 从后往前，先找到按字典排序，将要交换位置的点；再找该位置下一个排列应该是什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextPermutation(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> len = nums.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;<span class="number">0</span>; i--)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>])&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len-<span class="number">1</span>; j&gt;=i;j--)&#123;</div><div class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i-<span class="number">1</span>])&#123;</div><div class="line">                    <span class="keyword">int</span> temp = nums[j];</div><div class="line">                    nums[j] = nums[i-<span class="number">1</span>];</div><div class="line">                    nums[i-<span class="number">1</span>]=temp;</div><div class="line">                    Arrays.sort(nums,i,len);</div><div class="line">                    <span class="keyword">return</span> nums;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">     Arrays.sort(nums);</div><div class="line">     <span class="keyword">return</span> nums;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E6%B3%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础算法-数学和位操作</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E5%92%8C%E4%BD%8D%E6%93%8D%E4%BD%9C.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E5%92%8C%E4%BD%8D%E6%93%8D%E4%BD%9C.html</guid>
      <pubDate>Wed, 31 May 2017 08:18:45 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;最大公约数-最小公倍数&quot;&gt;&lt;a href=&quot;#最大公约数-最小公倍数&quot; class=&quot;headerlink&quot; title=&quot;最大公约数/最小公倍数&quot;&gt;&lt;/a&gt;最大公约数/最小公倍数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最大公约数:greatest common diviso
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="最大公约数-最小公倍数"><a href="#最大公约数-最小公倍数" class="headerlink" title="最大公约数/最小公倍数"></a>最大公约数/最小公倍数</h2><ul>
<li>最大公约数:greatest common divisor</li>
<li>欧几里得法(辗转相除法):设<code>a&gt;b</code>,<code>a=b*p+q</code>,b与q的最大公约也就是a与b的最大公约数,直到q为0,直接返回;</li>
<li>最小公倍数:lowest common multiple; <code>lcm(a,b)*gcd(a,b)=a*b</code>;</li>
<li>求两个数或n个数的最小公倍数或最大公约数:<br><img src="../images/gcd.png" alt=""></li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><ul>
<li>素数: 只有1和本身两个约数;判断是否为素数,只需要对前根号n个数进行判断<br><img src="../images/prime.png" alt=""></li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位操作有按位与、或、非、左移n位和右移n位等操作。</p>
<ol>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1): 可以把最右边的一个1变成0;</li>
<li>常见位操作：获取，设置，清除及更新位操作<br><img src="../images/位-获取.png" alt=""><br><img src="../images/位-更新.png" alt=""><br><img src="../images/位-清零.png" alt=""></li>
</ol>
<h3 id="二进制中的1的个数"><a href="#二进制中的1的个数" class="headerlink" title="二进制中的1的个数"></a>二进制中的1的个数</h3><ul>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1)</li>
</ul>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><ul>
<li>卡特兰数递推关系:<img src="../images/卡特兰.png" alt=""></li>
<li>卡特兰数通项式:<img src="../images/catalan.png" alt=""><img src="../images/catalan1.png" alt=""></li>
<li>前几项为1，1，2，5，14，42…</li>
<li>应用:<ul>
<li>栈的出栈序列:1到n的序列,依次进栈,有多少种不同的出栈序列；根据乘法原理和加法原理，设最后一个出栈的元素为k，则该情况为f(k-1)f(n-k)，所以递推关系满足；<code>f(n) = f(n-1)f(0) + f(n-2)f(1) + f(n-3)f(2) + ... + f(1)f(n-2) + f(0)f(n-1)</code></li>
<li>不同的二叉查找树： <a href="http://www.lintcode.com/zh-cn/problem/unique-binary-search-trees/" target="_blank" rel="external">lintcode|不同二叉查找树</a>；<code>f(n) = f(n-1)f(0) + f(n-2)f(1) + f(n-3)f(2) + ... + f(1)f(n-2) + f(0)f(n-1)</code></li>
</ul>
</li>
</ul>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><h2 id="全排列和全组合"><a href="#全排列和全组合" class="headerlink" title="全排列和全组合"></a>全排列和全组合</h2><ul>
<li>思路: 从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理；</li>
<li>参考:<a href="https://segmentfault.com/a/1190000002710424" target="_blank" rel="external">全排列/全组合</a></li>
</ul>
<h2 id="lintCode阶梯训练"><a href="#lintCode阶梯训练" class="headerlink" title="lintCode阶梯训练"></a>lintCode阶梯训练</h2><ul>
<li><a href="http://www.lintcode.com/zh-cn/ladder/" target="_blank" rel="external">lintcode阶梯训练|数学与二进制运算</a></li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E5%92%8C%E4%BD%8D%E6%93%8D%E4%BD%9C.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>操作系统总结</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Wed, 24 May 2017 08:38:07 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;操作系统概念&quot;&gt;&lt;a href=&quot;#操作系统概念&quot; class=&quot;headerlink&quot; title=&quot;操作系统概念&quot;&gt;&lt;/a&gt;操作系统概念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;基本概念：管理计算机硬件和软件资源，方便用户使用计算机的程序集合；&lt;/li&gt;
&lt;li&gt;操作系统提
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><ol>
<li>基本概念：管理计算机硬件和软件资源，方便用户使用计算机的程序集合；</li>
<li>操作系统提供的服务和功能：<ul>
<li>提供用户的<ul>
<li>用户界面</li>
<li>程序执行</li>
<li>I/O操作</li>
<li>文件系统操作</li>
<li>通信</li>
<li>错误检测</li>
</ul>
</li>
</ul>
</li>
<li>计算机系统<br><img src="../images/计算机要素.png" alt=""></li>
</ol>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><ol>
<li>进程的概念： 进程是具有一定独立功能的程序关于某个数据集合的一次运行活动。进程是程序的执行，动态概念，一次运行过程，有生命过程。</li>
<li>进程控制块（process control block, PCB）:记录进程的属性信息，进程标识信息，处理器状态信息，进程控制信息</li>
<li>进程间通信的两种基本模式： 1）共享内存， 2）消息传递<br><img src="../images/进程通信模型.png" alt="进程通信模型"></li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ol>
<li>多处理器系统带来的物理并行称为<strong>并行性</strong>，用编程技术达到的虚拟并行性，称为并发性</li>
<li>线程是CPU调度的基本单元，由线程ID,程序计数器，寄存器集合，栈组成。</li>
</ol>
<h1 id="互斥和同步"><a href="#互斥和同步" class="headerlink" title="互斥和同步"></a>互斥和同步</h1><ol>
<li>互斥（对资源的独用），同步（进程/线程之间的通信）</li>
<li>生产者和消费者问题：有限缓冲问题，用于多线程同步；多生产者消费者算法：用二元信号量保证互斥<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">semaphore mutex = 1;//二元信号量</div><div class="line">semaphore fillCount = 0;// 满缓存信号量</div><div class="line">semaphore emptyCount = BUFFER_SIZE;//空缓存信号量</div><div class="line"></div><div class="line"></div><div class="line">procedure producer() &#123;</div><div class="line">    while (true) &#123;</div><div class="line">        item = produceItem();//生产者生产数据</div><div class="line">        down(emptyCount);</div><div class="line">            down(mutex);//互斥，申请使用权</div><div class="line">                putItemIntoBuffer(item);//将数据放入缓存区</div><div class="line">            up(mutex);//释放使用权</div><div class="line">        up(fillCount);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">procedure consumer() &#123;</div><div class="line">    while (true) &#123;</div><div class="line">        down(fillCount);</div><div class="line">            down(mutex);</div><div class="line">                item = removeItemFromBuffer();//从缓存区中读取数据</div><div class="line">            up(mutex);</div><div class="line">        up(emptyCount);</div><div class="line">        consumeItem(item);//消费者使用数据</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="external">参考</a></li>
</ul>
<h1 id="进程调用"><a href="#进程调用" class="headerlink" title="进程调用"></a>进程调用</h1><h1 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h1><ol>
<li>先进先出调度算法（不可抢占）：按进入顺序执行</li>
<li>最短进程优先调度（事先知道要运行的时间）<ul>
<li>非抢占式</li>
<li>抢占式（最短剩余时间优先调度）</li>
</ul>
</li>
<li>时间片轮转法：每个进程轮流使用一段时间</li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul>
<li>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进</li>
</ul>
<ol>
<li><p>产生死锁的原因 </p>
<ul>
<li><strong>竞争资源引起死锁</strong><ul>
<li>在多道程序系统，多个进程共享系统的资源。系统资源分为二类:<br>一类是不可抢占的资源，如打印机、磁带机等。当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自动释放。<br>另一类是可抢占的资源，如CPU、内存等。由于系统拥有的不可抢占的资源有限，多个进程共享竞争不可抢占的资源就可能引起死锁。</li>
</ul>
</li>
<li><strong>进程推进顺序不当引起死锁</strong><ul>
<li>在多道程序系统中，并发执行的进程推进序列不可予测，有些推进顺序，进程可以顺利完成，这些推进顺序是合法的；而有的推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成了死锁。</li>
</ul>
</li>
</ul>
</li>
<li><p>产生死锁的必要条件</p>
<ul>
<li>互斥（ Mutual exclusion ）条件：一个资源一次只能被一个进程所使用，即是排它性使用。</li>
<li>不可抢占（ No preemption ）条件：一个资源仅能被占有它的进程所释放，而不能被别的进程强占。</li>
<li>请求和保持（ Hold-and-wait ）条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放。</li>
<li>环路等待（ Circular wait ）条件：当每类资源只有一个时，在发生死锁时，必然存在一个进程-资源的环形链。如一系统状态的资源分配图所示，P1正在等待一个P2 占用的资源R2，P2正在等待一个P1占用的资源R1。</li>
</ul>
</li>
<li><p>死锁的预防</p>
<ul>
<li><strong>预防死锁的方法是破坏四个产生死锁的必要条件之一</strong>。</li>
</ul>
<ol>
<li>破坏互斥条件: 互斥使用是资源本身特征所决定的。使用硬软件结合可改变资源本身特性，例如采用SPOOLing技术可将“独享” 打印机改变为“共享”的打印机。</li>
<li>破坏不可抢占条件:如果一个进程的申请没有实现，它要释放所有占有的资源</li>
<li>破坏请求和保持条件（也叫部分分配条件）: 采用<strong>资源预先静态分配法</strong>，运行前，一次性分配所需要的全部资源</li>
<li>破坏循环等待条件： <strong>有序资源使用法</strong>，对资源编号，进程只能按照编号递增的顺序申请资源。</li>
</ol>
</li>
<li><p>死锁的避免</p>
<ol>
<li>概念： 死锁的预防是严格破坏四个必要条件之一，死锁避免是方法允许进程动态地申请资源，系统在进行资源分配之前，先计算资源分配的安全性。若安全，则分配。避免死锁：确保系统永远不会进入死锁状态</li>
<li><strong>银行家算法</strong>避免死锁，不足：进程难以预先知道它的最大资源需求</li>
</ol>
</li>
<li><p>死锁的检测和恢复</p>
</li>
</ol>
<h1 id="主存储器管理"><a href="#主存储器管理" class="headerlink" title="主存储器管理"></a>主存储器管理</h1><ol>
<li>页式存储管理</li>
<li>段式存储管理</li>
<li>页的置换算法<ul>
<li>最佳置换算法</li>
<li>最佳未使用置换算法(NUR)</li>
<li>先进先出</li>
<li>最近最少使用置换算法（LRU），实现：用链表+hashmap：链表头部是最近使用的，尾部是最久的，缓存满了时，删除尾部；新增数据项时，如果存在（利用hash命中）则，则删除这个节点，放到链表头部，满了，则删除末尾的，直接在头部新增一个节点。</li>
</ul>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://jpkc.scezju.com/czxtyl/redir.php?catalog_id=109249" target="_blank" rel="external">操作系统ppt</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算机网络总结</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Wed, 24 May 2017 07:32:11 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;h2 id=&quot;OSI七层模型与TCP-IP四层模型&quot;&gt;&lt;a href=&quot;#OSI七层模型与TCP-IP四层模型&quot; cla
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层模型与TCP-IP四层模型"><a href="#OSI七层模型与TCP-IP四层模型" class="headerlink" title="OSI七层模型与TCP/IP四层模型"></a>OSI七层模型与TCP/IP四层模型</h2><p><img src="../images/osi七层模型.gif" alt=""></p>
<ul>
<li>实际应用的tcp/ip四层: 连接层,网络层,传输层,应用层</li>
<li>各层的作用<ol>
<li>物理层：通过媒介传输比特,确定机械及电气规范</li>
<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ol>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="../images/ip.png" alt=""><br><img src="../images/ip1.png" alt=""></p>
<ul>
<li>A类地址,<ul>
<li>可指派的网络号126个(2^7-2),见2的原因是: 网络号全0为保留地址,表示本网络;网络号127(0111 1111)保留为回环测试(如127.0.0.1)</li>
<li>可指派的主机号: 2^24-2; 减去全0的主机号,减去全1主机号</li>
</ul>
</li>
<li>B类地址<ul>
<li>可指派网络号2^14-1:128.0不指派,最小可指派的网络号是128.1</li>
<li>主机号减2,2^16-2;</li>
</ul>
</li>
<li>C类地址<ul>
<li>可指派网络号2^21-1:192.0.0不指派,最小可指派的网络号192.0.1</li>
<li>主机号减2: 2^8-2;</li>
</ul>
</li>
</ul>
<h2 id="TCP-UDP协议"><a href="#TCP-UDP协议" class="headerlink" title="TCP/UDP协议"></a>TCP/UDP协议</h2><ul>
<li>运输层协议和网络层协议的主要区别<br><img src="../images/运输层网络层.png" alt=""></li>
<li><p>运输层的协议端口号</p>
<ul>
<li>协议端口号(protocol port number),简称端口;使不同的操作系统中的进程可以相互通信,用统一的方法对TCP/IP体系中的应用进程进行标识;16位的端口号(65535个)</li>
<li>通信的终点是应用进程,但我们只需把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成</li>
</ul>
</li>
<li><p>tcp字段含义<br><img src="../images/tcp字段.png" alt=""></p>
</li>
<li><p>传输层定义两种传输协议：TCP（传输控制协议）和 UDP（或用户数据报协议）<br><img src="../images/tcp-udp.png" alt=""></p>
</li>
<li>TCP协议和UDP协议特性区别总结：<ol>
<li>TCP协议在传送数据段的时候要给段标号；UDP协议不</li>
<li>TCP协议可靠；UDP协议不可靠</li>
<li>TCP协议是面向连接；UDP协议采用无连接</li>
<li>TCP协议负载较高，采用虚电路；UDP采用无连接</li>
<li>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</li>
<li>TCP协议采用窗口技术和流控制</li>
</ol>
</li>
</ul>
<h2 id="TCP三次握手与四次分手"><a href="#TCP三次握手与四次分手" class="headerlink" title="TCP三次握手与四次分手"></a>TCP三次握手与四次分手</h2><p><img src="../images/tcp.jpg" alt=""></p>
<ol>
<li>三次握手和四次分手的过程</li>
<li>为什么要三次握手和四次分手</li>
<li>参考:<a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>http状态码<br><img src="../images/http状态码.png" alt=""><ul>
<li>404  未找到，服务器找不到所请求的网页。</li>
<li>302  临时移动，服务器从不同位置的网页响应请求，请求者应继续使用原有位置进行以后的请求。</li>
<li>500  （服务器内部错误），服务器遇到错误，无法完成请求。</li>
<li>403  （禁止）服务器拒绝请求</li>
</ul>
</li>
<li>http与https区别<ul>
<li>http协议</li>
<li>简单理解: https是安全版的http,</li>
<li>HTTP的端口号是80，https的端口号是443</li>
</ul>
</li>
</ul>
<h2 id="SNMP简单网络管理协议"><a href="#SNMP简单网络管理协议" class="headerlink" title="SNMP简单网络管理协议"></a>SNMP简单网络管理协议</h2><ul>
<li>simple network management protocol 简单网络管理协议</li>
<li>是一个网络管理员用来管理的工具相当于  一个app 所以是<strong>应用层</strong></li>
</ul>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul>
<li>Internet Control Message Protocol 互联网控制消息协议</li>
<li>网络层协议</li>
<li>用ping命令,检查一台主机的网络层是否连通;</li>
</ul>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ul>
<li>IEEE 802.3—CSMA/CD网络，定义CSMA/CD总线网的MAC子层和物理层的规范,人们习惯将<strong>IEEE 802.3称为”以太网</strong>;</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础数据结构-字符串和数组</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84.html</guid>
      <pubDate>Tue, 23 May 2017 14:12:47 GMT</pubDate>
      <description>
      
        字符串总结，字符串相关面试题总结
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>重难点是: <strong>模式匹配(kmp算法)</strong>和<strong>正则表达式匹配</strong>; 在选择题中,可能会出现问next数组的题目</p>
<h2 id="Java字符串API"><a href="#Java字符串API" class="headerlink" title="Java字符串API"></a>Java字符串API</h2><ul>
<li>toCharArray();</li>
<li><strong>StringBuilder</strong>常用,线程不安全,效率高; StringBuffer  线程安全,效率低;</li>
<li>matches()字符串是否匹配给定的正则表达式。</li>
<li>indexOf()返回指定子字符串在此字符串中第一次出现处的索引。(模式匹配api)</li>
<li>trim()返回字符串的副本，忽略前导空白和尾部空白。</li>
<li>valueOf()返回…字符串形式</li>
<li>split()按给定的正则表达式拆分字符串</li>
<li>replace/replaceAll/replaceFirst 替换字符串</li>
<li>reverse() 逆序</li>
</ul>
<h2 id="String对象经典问题"><a href="#String对象经典问题" class="headerlink" title="String对象经典问题"></a>String对象经典问题</h2><ul>
<li><a href="http://sarin.iteye.com/blog/603684" target="_blank" rel="external">参考</a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"abc"</span>;</div><div class="line">String str1 = <span class="string">"abc"</span>;</div><div class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</div><div class="line">System.out.println(str == str1);<span class="comment">//true</span></div><div class="line">System.out.println(str1 == <span class="string">"abc"</span>);<span class="comment">//true</span></div><div class="line">System.out.println(str2 == <span class="string">"abc"</span>);<span class="comment">//false</span></div><div class="line">System.out.println(str1 == str2);<span class="comment">//fasle</span></div><div class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></div><div class="line">System.out.println(str1 == str2.intern());<span class="comment">//true</span></div><div class="line">System.out.println(str2 == str2.intern());<span class="comment">//false</span></div><div class="line">System.out.println(str1.hashCode() == str2.hashCode());<span class="comment">//true equals相同,hashcode必然相同</span></div><div class="line">System.out.println(str + <span class="string">"d"</span> == str1 + <span class="string">"d"</span>);<span class="comment">//false 用+连接是在堆内存上进行, 得到两个新对象</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul>
<li>定义:s和t为给定的两个字符串,在主串s中查找子串t的过程称为模式匹配,返回t在s中第一次出现的位置</li>
<li>OJ题目:<a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">LeetCode|字符串匹配,子串第一次出现的位置</a></li>
<li>三种方法:<ol>
<li>java api: indexOf;</li>
<li>暴力搜</li>
<li>KMP算法</li>
</ol>
</li>
<li>kmp算法选择题:next数组<ul>
<li><a href="https://www.nowcoder.com/questionTerminal/57bdf294407c4477969fc7b4d56c7be7" target="_blank" rel="external">next数组</a></li>
</ul>
</li>
<li>求next数组的方法（递归法）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String source, String pattern)</span></span>&#123;</div><div class="line">       <span class="keyword">char</span>[] src = source.toCharArray();</div><div class="line">       <span class="keyword">char</span>[] pat = pattern.toCharArray();</div><div class="line">       <span class="keyword">int</span>[] next = getNext(pat);</div><div class="line">       <span class="keyword">int</span> sLen = src.length;</div><div class="line">       <span class="keyword">int</span> pLen = pat.length;</div><div class="line">       <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</div><div class="line">           <span class="keyword">if</span>(j== -<span class="number">1</span> || src[i] == pat[j])&#123;</div><div class="line">               i++;</div><div class="line">               j++;</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               j = next[j];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span>(j == pLen)&#123;</div><div class="line">           <span class="keyword">return</span> i - pLen;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] p)&#123;</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 求next数组的方法</div><div class="line">        * 已知next[j]=k,求next[j+1];</div><div class="line">        * 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1;</div><div class="line">        * 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1,</div><div class="line">        *    如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止</div><div class="line">        */</div><div class="line">       <span class="keyword">int</span> pLen = p.length;</div><div class="line">       <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</div><div class="line">       next[<span class="number">0</span>] = -<span class="number">1</span>;</div><div class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> k = -<span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span>(j &lt; pLen-<span class="number">1</span>)&#123;</div><div class="line">           <span class="keyword">if</span>(k == -<span class="number">1</span> || p[k] == p[j])&#123;</div><div class="line">               j++;</div><div class="line">               k++;</div><div class="line">               next[j] = k;</div><div class="line">           &#125;<span class="keyword">else</span> &#123;</div><div class="line">               k = next[k];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><ul>
<li>OJ题目:剑指offer第52题,Solution52;</li>
<li><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer|正则表达式匹配</a> ;<a href="https://leetcode.com/problems/regular-expression-matching/#/description" target="_blank" rel="external">LeetCode|正则表达式匹配</a></li>
<li>解题思路<ul>
<li>字符串 正则表达式匹配<ol>
<li>模式中,当前字符的下一个字符不是<code>*</code><ul>
<li>如果当前字符匹配,则字符串和模式串都下移一位</li>
<li>如果当前字符不匹配,则直接返回false</li>
</ul>
</li>
<li>模式中,当前字符的下一个字符是<code>*</code><ul>
<li>如果当前字符不匹配,则<code>*</code>匹配0个前位字符,模式串后移两位(前位字符,<code>*</code>前面的那个字符)</li>
<li>如果当前字符匹配,分两组<ul>
<li><code>*</code>匹配0个前位字符,模式串后移两位</li>
<li><code>*</code>匹配一个或者多个前位字符,字符串后移以为,模式串不变</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="字符串平移-String-shift"><a href="#字符串平移-String-shift" class="headerlink" title="字符串平移(String shift)"></a>字符串平移(String shift)</h2><ul>
<li>题目描述<ul>
<li>我们规定对一个字符串的shift操作如下： shift(“ABCD”, 0) = “ABCD” shift(“ABCD”, 1) = “BCDA” shift(“ABCD”, 2) = “CDAB” 换言之, 我们把最左侧的N个字符剪切下来, 按序附加到了右侧。给定一个长度为n的字符串，我们规定最多可以进行n次向左的循环shift操作。如果shift(string, x) = string (0＜= x ＜n), 我们称其为一次匹配(match)。求在shift过程中出现匹配的次数。</li>
</ul>
</li>
<li>解决： 字符串必为周期字符串，计算出最短周期（用kmp算法中的next数组计算）</li>
</ul>
<h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-substring/" target="_blank" rel="external">最长公共子串</a></li>
<li>思路: 暴力法和<strong>动态规划法</strong>.</li>
</ol>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-subsequence/" target="_blank" rel="external">最长公共子序列</a></li>
<li><p>解决： 用动态规划的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lenA+<span class="number">1</span>][lenB+<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++)&#123;</div><div class="line">                dp[i][j] = (A.charAt(i-<span class="number">1</span>) == B.charAt(j-<span class="number">1</span>))?dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>:Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[lenA][lenB];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>应用（变形），求一个字符串删除几个字符可以变成最长的回文字符串，求原字符串与逆串的最长公共子序列。</p>
</li>
</ol>
<h2 id="字符串与整数-数组的互相转换"><a href="#字符串与整数-数组的互相转换" class="headerlink" title="字符串与整数,数组的互相转换"></a>字符串与整数,数组的互相转换</h2><p>1.</p>
<h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><ul>
<li>StringBuilder.reverse方法;</li>
<li><a href="https://leetcode.com/problems/reverse-words-in-a-string/#/description" target="_blank" rel="external">leetcode|字符串反转</a></li>
</ul>
<h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/adc291e7e79f452c8b59243a5ce68d3a?orderByHotValue=1&amp;page=1&amp;onlyReference=false" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/adc291e7e79f452c8b59243a5ce68d3a?orderByHotValue=1&amp;page=1&amp;onlyReference=false</a><br>来源：牛客网</p>
<p>n = int(raw_input())<br>nums = map(int, raw_input().split())<br>index = sorted(range(len(nums)), key = lambda i: nums[i])<br>count = 1<br>for i in range(1, len(index)):<br>    if index[i] &gt; index[i-1]:<br>        count += 1<br>    else:<br>        break<br>print len(index) - count</p>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础数据结构-字典树</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91.html</guid>
      <pubDate>Wed, 17 May 2017 13:16:50 GMT</pubDate>
      <description>
      
        tire,前缀树，字典树
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="external">trie|字典树</a></li>
<li>用字典树实现敏感词过滤（深挖）</li>
</ol>
<h1 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h1><ol>
<li>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。（来自今日头条笔试题）</li>
<li>解答<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/5/17.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> n = in.nextInt();</div><div class="line">        <span class="keyword">int</span> m = in.nextInt();</div><div class="line">        TrieNode root = <span class="keyword">new</span> TrieNode(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            array[i] = in.nextInt();</div><div class="line">            insert(root, array[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</div><div class="line">            result += query(root, i, m);</div><div class="line">        &#125;</div><div class="line">        System.out.println(result / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据二进制位，构建字典数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode trieNode, <span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">        TrieNode pre = trieNode;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> digit = (number &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (pre.next[digit] == <span class="keyword">null</span>) &#123;</div><div class="line">                pre.next[digit] = <span class="keyword">new</span> TrieNode(digit);</div><div class="line">            &#125;</div><div class="line">            pre = pre.next[digit];</div><div class="line">            pre.count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(TrieNode root, <span class="keyword">int</span> a, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        TrieNode pre = root;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (mDigit == <span class="number">1</span>) &#123;</div><div class="line">                pre = pre.next[aDigit ^ <span class="number">1</span>];<span class="comment">//此处技巧！ 与aDigit不同 aDigit ^ 1;</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (pre.next[aDigit ^ <span class="number">1</span>] != <span class="keyword">null</span>) &#123;</div><div class="line">                    result += pre.next[aDigit ^ <span class="number">1</span>].count;</div><div class="line">                &#125;</div><div class="line">                pre = pre.next[aDigit];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span>) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    TrieNode[] next = <span class="keyword">new</span> TrieNode[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.digit = digit;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>参考<a href="http://youjq.cn/2017/04/09/2017jin-ri-tou-tiao-bi-shi-ti-yi-huo/" target="_blank" rel="external">2017今日头条笔试题：异或</a></li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL/数据库总结</title>
      <link>http://liuhang.net.cn/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Wed, 17 May 2017 07:42:17 GMT</pubDate>
      <description>
      
        mysql必知必会一书
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="MySQL必知必会笔记"><a href="#MySQL必知必会笔记" class="headerlink" title="MySQL必知必会笔记"></a>MySQL必知必会笔记</h1><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use database_name;</div><div class="line">show databases;</div><div class="line">show tables;</div><div class="line">show columns from table_name;</div><div class="line">show create database;</div><div class="line">show create table;</div><div class="line">select * from table_name;</div><div class="line">select distince id from table_name;</div><div class="line">select naem from table_name limit 1,1;</div><div class="line">select id from table_name order by id desc;//降序</div></pre></td></tr></table></figure>
<ul>
<li>顺序： select, from, where, group by, having,order by, limit;</li>
</ul>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul>
<li>like操作符<ul>
<li>%表示任何字符出现任意次数</li>
<li>_表示任何字符出现一次</li>
</ul>
</li>
</ul>
<h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><ul>
<li>avg();min();max();count();sum();</li>
<li>count(*) 对表中行的数目进行计数</li>
</ul>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><ul>
<li>Group by </li>
<li>Having： where 过滤行； having 过滤分组</li>
</ul>
<h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><ul>
<li>联结多个表，返回同一个输出</li>
<li>理解笛卡尔乘积： 表一的每一行同表二的每一行进行匹配，where语句进行过滤</li>
<li>内联结  inner join on</li>
<li>外联结  left outer join on; right outer join on;</li>
</ul>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul>
<li>提供对select语句的一层封装</li>
</ul>
<h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><ul>
<li>是一个操作序列，这些操作要么都执行，要么都不执行</li>
<li><p>事物的四大特性</p>
<ul>
<li>一致性</li>
<li>原子性</li>
<li><p>隔离性</p>
</li>
<li><p>持久性</p>
</li>
</ul>
</li>
</ul>
<h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><ul>
<li>InnoDB 支持数据库事物，不支持全文搜索</li>
<li>MyISAM  性能高，不支持事物，支持全文本搜索</li>
<li>MEMORY  数据存储在内存中，同MyISAM</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h1 id="经典题目练习"><a href="#经典题目练习" class="headerlink" title="经典题目练习"></a>经典题目练习</h1><h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h2><ol>
<li><a href="https://leetcode.com/problems/duplicate-emails/#/description" target="_blank" rel="external">找出重复的记录|leetcode|重点</a></li>
<li><a href="https://leetcode.com/problems/combine-two-tables/#/description" target="_blank" rel="external">两个表联结查询|leetcode</a></li>
<li><a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/#/description" target="_blank" rel="external">表自联结|leetcode</a></li>
<li><a href="https://leetcode.com/problems/customers-who-never-order/#/description" target="_blank" rel="external">leetcode练习1</a></li>
<li><a href="https://leetcode.com/problems/rising-temperature/#/description" target="_blank" rel="external">leetcode练习2</a></li>
<li><a href="https://leetcode.com/problems/delete-duplicate-emails/#/description" target="_blank" rel="external">删除重复记录，只保留一个）|leetcode|重点</a></li>
<li><a href="https://leetcode.com/problems/second-highest-salary/#/description" target="_blank" rel="external">选择排名第二大的|limit使用|leetcode|重点</a></li>
<li><a href="https://leetcode.com/problems/big-countries/#/description" target="_blank" rel="external">单间检索数据|leetcode</a></li>
</ol>
<h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><ol>
<li><a href="https://leetcode.com/problems/rank-scores/#/description" target="_blank" rel="external">对分数进行排名，并显示名次|leetcode|难</a></li>
<li><a href="https://leetcode.com/problems/consecutive-numbers/#/description" target="_blank" rel="external">选址连续出现的|leetcode</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础算法-日历计算</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%97%A5%E5%8E%86%E8%AE%A1%E7%AE%97.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%97%A5%E5%8E%86%E8%AE%A1%E7%AE%97.html</guid>
      <pubDate>Wed, 17 May 2017 04:38:02 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;公历计算&quot;&gt;&lt;a href=&quot;#公历计算&quot; class=&quot;headerlink&quot; title=&quot;公历计算&quot;&gt;&lt;/a&gt;公历计算&lt;/h1&gt;&lt;h2 id=&quot;使用java类库GregorianCalendar&quot;&gt;&lt;a href=&quot;#使用java类库GregorianCal
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="公历计算"><a href="#公历计算" class="headerlink" title="公历计算"></a>公历计算</h1><h2 id="使用java类库GregorianCalendar"><a href="#使用java类库GregorianCalendar" class="headerlink" title="使用java类库GregorianCalendar"></a>使用java类库GregorianCalendar</h2><h2 id="不使用java类库"><a href="#不使用java类库" class="headerlink" title="不使用java类库"></a>不使用java类库</h2><ol>
<li>参考:<a href="https://github.com/hotoo/nong/wiki/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%81%E4%B8%83%EF%BC%9A%E6%97%A5%E5%8E%86%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95-%E4%B8%AD%E5%9B%BD%E5%85%AC%E5%8E%86%EF%BC%88%E6%A0%BC%E9%87%8C%E5%8E%86%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89" target="_blank" rel="external">日历生成算法</a></li>
<li>公元元年（1年）1.1号星期一，据此计算y年<ul>
<li><code>w=(L*366+N*365+D)%7</code>,前y-1年闰年和平年的年数,D为y年的第几天</li>
<li><code>w=(365(y-1)+L+D)%7</code>,<code>L=(y-1)/4-(y-1)/100+(y-1)/400</code></li>
<li>计算星期几的公式：<code>w=((y-1)+(y-1)/4-(y-1)/100+(y-1)/400+D)%7</code></li>
</ul>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.DateFormatSymbols;</div><div class="line"><span class="keyword">import</span> java.util.Calendar;</div><div class="line"><span class="keyword">import</span> java.util.Locale;</div><div class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 打印指定月份的日历</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//        printCalendar(2017, 5);</span></div><div class="line">        printCalendar1(<span class="number">2017</span>, <span class="number">6</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//使用java类库</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCalendar</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month)</span> </span>&#123;</div><div class="line">        GregorianCalendar d = <span class="keyword">new</span> GregorianCalendar();</div><div class="line">        Locale.setDefault(Locale.US);</div><div class="line">        <span class="keyword">int</span> today = d.get(Calendar.DAY_OF_MONTH);</div><div class="line">        d.set(Calendar.YEAR, year);</div><div class="line">        d.set(Calendar.MONTH, month - <span class="number">1</span>);</div><div class="line">        d.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">int</span> weekday = d.get(Calendar.DAY_OF_WEEK);</div><div class="line">        <span class="keyword">int</span> firstDayOfWeek = d.getFirstDayOfWeek();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> indent = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (weekday != firstDayOfWeek) &#123;</div><div class="line">            indent++;</div><div class="line">            d.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</div><div class="line">            weekday = d.get(Calendar.DAY_OF_WEEK);</div><div class="line">        &#125;</div><div class="line">        String[] weekdaysName = <span class="keyword">new</span> DateFormatSymbols().getShortWeekdays();</div><div class="line">        do &#123;</div><div class="line">            System.out.printf(<span class="string">"%4s"</span>, weekdaysName[weekday]);</div><div class="line">            d.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">            weekday = d.get(Calendar.DAY_OF_WEEK);</div><div class="line">        &#125; <span class="keyword">while</span> (weekday != firstDayOfWeek);</div><div class="line">        System.out.println();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indent; i++) &#123;</div><div class="line">            System.out.print(<span class="string">"    "</span>);</div><div class="line">        &#125;</div><div class="line">        d.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">        <span class="keyword">while</span> (d.get(Calendar.MONTH) == month - <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> day = d.get(Calendar.DAY_OF_MONTH);</div><div class="line">            System.out.printf(<span class="string">"%3d"</span>, day);</div><div class="line">            <span class="keyword">if</span> (day == today) &#123;</div><div class="line">                System.out.print(<span class="string">"*"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.print(<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            d.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (d.get(Calendar.DAY_OF_WEEK) == firstDayOfWeek) &#123;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//不适用java类库</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCalendar1</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">" Sun Mon Tue Wed Thu Fri Sat "</span>);</div><div class="line">        <span class="keyword">int</span> today = <span class="number">16</span>;</div><div class="line">        <span class="keyword">int</span> weekday = day(year, month, <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weekday; i++) &#123;</div><div class="line">            System.out.print(<span class="string">"    "</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= month(year, month); i++) &#123;</div><div class="line">            System.out.printf(<span class="string">"%3d"</span>, i);</div><div class="line">            <span class="keyword">if</span> (i == today) &#123;</div><div class="line">                System.out.print(<span class="string">"*"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.print(<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (day(year, month, i) == <span class="number">6</span>) &#123;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//判断闰年</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">year</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> y % <span class="number">400</span> == <span class="number">0</span> || (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>);<span class="comment">//闰年规则，4的倍数，如果年份整百，必须为400的倍数</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//计算y年 m月有多少天</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">month</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (m == <span class="number">1</span> || m == <span class="number">3</span> || m == <span class="number">5</span> || m == <span class="number">7</span> || m == <span class="number">8</span> || m == <span class="number">10</span> || m == <span class="number">12</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">31</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">4</span> || m == <span class="number">6</span> || m == <span class="number">9</span> || m == <span class="number">11</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">30</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (year(y)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">29</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">28</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据公式，计算y年，m月 ，d日星期w  w = ([Y-1] + [(Y-1)/4] - [(Y-1)/100] + [(Y-1)/400] + D)mod 7</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">day</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</div><div class="line">            count = count + month(y, i);</div><div class="line">        &#125;</div><div class="line">        count = count + d;<span class="comment">//count 表示是y年的第几天</span></div><div class="line">        <span class="keyword">int</span> w = ((y - <span class="number">1</span>) + (y - <span class="number">1</span>) / <span class="number">4</span> - (y - <span class="number">1</span>) / <span class="number">100</span> + (y - <span class="number">1</span>) / <span class="number">400</span> + count) % <span class="number">7</span>;<span class="comment">//计算公式，公元元年1.1号星期1</span></div><div class="line">        <span class="keyword">return</span> w;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%97%A5%E5%8E%86%E8%AE%A1%E7%AE%97.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人计划至6月底</title>
      <link>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B36%E6%9C%88%E5%BA%95.html</link>
      <guid>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B36%E6%9C%88%E5%BA%95.html</guid>
      <pubDate>Mon, 15 May 2017 13:29:21 GMT</pubDate>
      <description>
      
        复习基础，巩固基础
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="本月总体"><a href="#本月总体" class="headerlink" title="本月总体"></a>本月总体</h1><ol>
<li>看书:mysql/shell两本书看完，python简明教程看完,shell书看完前四章<strong>基本完成</strong></li>
<li>看书:java高并发一书，java虚拟机一书看完（附带看完操作系统）</li>
<li>操作系统，计算机网络，数据库，linux shell复习完</li>
<li>编程练习，每日1-2题（只有周六除外）,《程序员面试经典》84个题刷(java和python，熟悉，练习语法)</li>
<li>每早8：30-9：30看一小时书</li>
<li>网络编程小项目： 聊天室/文件共享 python/java实现，练手（java做成网页版）</li>
<li>每周日一整天编程真题</li>
</ol>
<h2 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h2><ol>
<li>计算机网络</li>
<li>操作系统</li>
<li>mysql必知必会</li>
<li>linux shell脚本攻略</li>
<li>python简明教程</li>
<li>程序员面试金典</li>
<li>分布式Java应用-基础与实践/大型网站系统与Java中间件实践</li>
<li>Java高并发编程实战/深入理解Java虚拟机</li>
</ol>
<ul>
<li><strong><em>注意：1和2必须完成，并完成总结；7.8结合看，总结一波，巩固其中的基础</em></strong></li>
</ul>
<h1 id="完成python基础学习"><a href="#完成python基础学习" class="headerlink" title="完成python基础学习"></a>完成python基础学习</h1><ol>
<li>任务一：用python编写一个批量测试脚本（测试zte代码）</li>
<li>任务二：学习完简明python教程一书<strong>完成</strong></li>
<li>时间： 一周完成（5.15号-5.20号）</li>
</ol>
<h1 id="完成linux-shell学习"><a href="#完成linux-shell学习" class="headerlink" title="完成linux shell学习"></a>完成linux shell学习</h1><ol>
<li>任务一： 学习完linux shell 脚本攻略一书</li>
<li>任务二： 完成leetcode 上shell题目</li>
<li>时间：两周完成（5.21号-6.1号）</li>
</ol>
<h1 id="完成数据库学习"><a href="#完成数据库学习" class="headerlink" title="完成数据库学习"></a>完成数据库学习</h1><ol>
<li>任务一：学习完mysql必知必会一书<strong>mysql必知必会1-22章基本看完</strong></li>
<li>任务二：完成leetcode 上database题目,总计13题，并总结<strong>已总结10题</strong></li>
<li>时间： 一周完成（5.21-5.26号）</li>
<li>任务三：牛客网上mysql习题 50%完成(<strong>取消</strong>)</li>
</ol>
<h1 id="完成Java并发编程学习"><a href="#完成Java并发编程学习" class="headerlink" title="完成Java并发编程学习"></a>完成Java并发编程学习</h1><ol>
<li>任务一： 学习完java并发编程实战一书</li>
<li>任务二：深入理解java虚拟机一书</li>
</ol>
<h1 id="完成操作系统复习"><a href="#完成操作系统复习" class="headerlink" title="完成操作系统复习"></a>完成操作系统复习</h1><ol>
<li>操作系统概念，第七版一书</li>
</ol>
<h1 id="完成计算机网络复习"><a href="#完成计算机网络复习" class="headerlink" title="完成计算机网络复习"></a>完成计算机网络复习</h1><ol>
<li>计算机网络（谢版），一书 </li>
</ol>
<h1 id="日程记录"><a href="#日程记录" class="headerlink" title="日程记录"></a>日程记录</h1><h2 id="5-15-5-24（10天任务）"><a href="#5-15-5-24（10天任务）" class="headerlink" title="5.15-5.24（10天任务）"></a>5.15-5.24（10天任务）</h2><ul>
<li>总结<ol>
<li>完成数据库（mysql）基础学习</li>
<li>完成linux shell基础xuex</li>
<li>完成python基础学习</li>
<li>今日头条2017四个编程题完成</li>
</ol>
</li>
</ul>
<h3 id="5-15"><a href="#5-15" class="headerlink" title="5.15"></a>5.15</h3><ol>
<li>学习了python基础</li>
</ol>
<h3 id="5-16"><a href="#5-16" class="headerlink" title="5.16"></a>5.16</h3><ol>
<li>学习完python基础-<strong>完成</strong></li>
<li>完成批量测试代码-<strong>完成</strong></li>
<li>编程练习： 显示日历；<strong>完成</strong></li>
</ol>
<h3 id="5-17"><a href="#5-17" class="headerlink" title="5.17"></a>5.17</h3><ol>
<li>编程练习：2题;<strong>完成,今日头条真题2个</strong></li>
<li>简明python教程一书例题做完- 未完成</li>
<li>完善zte测试代码 - 未完成</li>
<li>看mysql必知必会1-8章<strong>完成,见mysql总结</strong>，刷了2个leetcode数据库题目</li>
</ol>
<h3 id="5-18"><a href="#5-18" class="headerlink" title="5.18"></a>5.18</h3><ol>
<li>实验室804项目报告<strong>完成</strong></li>
<li>编程练习：1题<strong>完成</strong></li>
<li>看书：mysql必知必会9-16章-未完成</li>
</ol>
<h3 id="5-19"><a href="#5-19" class="headerlink" title="5.19"></a>5.19</h3><ol>
<li>String kmp算法总结完毕，编程练习刷题1 未完成</li>
<li>看书：mysql必知必会9-16章<strong>完成,刷数据库题目3个</strong></li>
<li>看书：python简明教程看完；（刷题2）未完成</li>
</ol>
<h3 id="5-20"><a href="#5-20" class="headerlink" title="5.20"></a>5.20</h3><ol>
<li>看书： linux私房菜看完bash和shell script两章<strong>完成</strong></li>
<li>编程练习： 1题 <strong>字典序，重点看</strong></li>
</ol>
<h3 id="5-21"><a href="#5-21" class="headerlink" title="5.21"></a>5.21</h3><ol>
<li>看书: python简明教程后面内容看完<strong>延后</strong></li>
<li>编程练习：1题，今日头条的四题总结完，kmp算法总结完成<strong>未完成</strong></li>
<li>python编程练习，剑指offer题目练习（3）</li>
</ol>
<h3 id="5-22"><a href="#5-22" class="headerlink" title="5.22"></a>5.22</h3><ol>
<li>python简明教程后面看完<strong>完成</strong></li>
</ol>
<h3 id="5-23"><a href="#5-23" class="headerlink" title="5.23"></a>5.23</h3><ol>
<li>早上看书：mysql必知必会17-22章看完<strong>完成,并刷了三个leetcode数据库题目</strong></li>
<li>下午编码：编程题练习，2题<strong>修改，完成KMP算法总结</strong></li>
<li>晚上看书：看linxu shell脚本攻略<strong>完成，看完第一章，并编写一测试脚本</strong></li>
</ol>
<h3 id="5-24"><a href="#5-24" class="headerlink" title="5.24"></a>5.24</h3><ol>
<li>早上看书：linux shell脚本攻略第二章过完<strong>完成</strong></li>
<li>下午编码： 编程练习，2题，总结完字符串与整数部分（面试经典）</li>
<li>晚上看书：操作系统第一章过一遍<strong>完成</strong></li>
</ol>
<h2 id="5-25-6-04（10天任务）"><a href="#5-25-6-04（10天任务）" class="headerlink" title="5.25-6.04（10天任务）"></a>5.25-6.04（10天任务）</h2><ul>
<li>计划<ol>
<li>复习完操作系统，总结完成（操作系统概念一书）</li>
<li>复习完计算机网络，总结完成（计算机网络-谢仁希一书）</li>
<li>编程真题8道<a href="https://www.nowcoder.com/contestRoom?orderByHotValue=1&amp;filter=0&amp;mutiTagIds=672_139_138" target="_blank" rel="external">链接</a>；总共需要三小时做完；三小时总结；</li>
<li>每日一小题/周日4个真题 code!</li>
</ol>
</li>
<li>总结<ol>
<li>操作系统部分看完</li>
<li>编程练习完成</li>
<li>计算机网络总结未完成</li>
</ol>
</li>
</ul>
<h3 id="5-25"><a href="#5-25" class="headerlink" title="5.25"></a>5.25</h3><ol>
<li>早上看书：复习完操作系统（未完成）</li>
<li>当日1编程题,总结完字符串和数组（未完成）</li>
</ol>
<p>##￥ 5.29</p>
<ol>
<li>刷编程题，见计划链接（一整天做完，总结完），用java和Python两种搞完，熟悉Python语法。<strong>基本完成</strong></li>
</ol>
<h3 id="5-30"><a href="#5-30" class="headerlink" title="5.30"></a>5.30</h3><ol>
<li>空</li>
</ol>
<h3 id="6-1号"><a href="#6-1号" class="headerlink" title="6.1号"></a>6.1号</h3><ol>
<li>看书：《大型网站系统与Java中间件实践》</li>
</ol>
<h3 id="6-2号"><a href="#6-2号" class="headerlink" title="6.2号"></a>6.2号</h3><ol>
<li>复习操作系统<strong>看完cpu调度和死锁</strong></li>
</ol>
<h3 id="6-3号"><a href="#6-3号" class="headerlink" title="6.3号"></a>6.3号</h3><ol>
<li>复习计算机网络，完成总结（延后）</li>
<li>复习操作系统，看内存管理<strong>未完成</strong></li>
</ol>
<h2 id="6-5号-6-10号"><a href="#6-5号-6-10号" class="headerlink" title="6.5号-6.10号"></a>6.5号-6.10号</h2><h3 id="6-5号"><a href="#6-5号" class="headerlink" title="6.5号"></a>6.5号</h3><ol>
<li>早上：刷阶梯训练，看程序员面试金典（<strong>总结完数学及位运算</strong>）</li>
<li>下午：认真看书，总结。操作系统/内存管理章节</li>
<li>晚上：单车锻炼； 看Java深入部分与总结（分布式，中间件）</li>
</ol>
<h3 id="6-7-6-9号"><a href="#6-7-6-9号" class="headerlink" title="6.7-6.9号"></a>6.7-6.9号</h3><ol>
<li>学习装箱问题相关算法，并总结</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B36%E6%9C%88%E5%BA%95.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
