<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>刘航</title>
    <link>http://liuhang.net.cn/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 16 Aug 2017 02:54:13 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Quartz详解及源码探究2-quartz调度器scheduler</title>
      <link>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B62-quartz%E8%B0%83%E5%BA%A6%E5%99%A8scheduler.html</link>
      <guid>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B62-quartz%E8%B0%83%E5%BA%A6%E5%99%A8scheduler.html</guid>
      <pubDate>Mon, 14 Aug 2017 11:17:34 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Quartz-Scheduler&quot;&gt;&lt;a href=&quot;#Quartz-Scheduler&quot; class=&quot;headerlink&quot; title=&quot;Quartz Scheduler&quot;&gt;&lt;/a&gt;Quartz Scheduler&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a hr
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>客户端会同两种类型的 Scheduler 交互，如图,它们都实现了 org.quartz.Scheduler 接口</li>
<li><p>Scheduler代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）<br><img src="../images/QuartzFigure4.2.JPG" alt=""></p>
</li>
<li><p>Scheduler 的 API 可以分组成以下三个类别：</p>
<ul>
<li>管理 Scheduler</li>
<li>管理 Job</li>
<li>管理 Trigger 和 Calendar</li>
</ul>
</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="../images/quartz类结构.png" alt=""></p>
<ol>
<li>StdSchedule只是QuartzSchedule的一个包装类，方法更清晰。</li>
<li>QuartzScheduler是整个定时任务框架工作的核心类，上面的类图仅仅展现了QuartzScheduler中几个核心成员。</li>
<li>QuartzSchedulerResources可以认为是存放一切配置以及通过配置初始化出来的一些资源的容器，其中包括了存储job定义的jobStore</li>
<li>QuartzSchedulerThread多线程启动</li>
</ol>
<h1 id="Quartz-SchedulerFactory"><a href="#Quartz-SchedulerFactory" class="headerlink" title="Quartz SchedulerFactory"></a>Quartz SchedulerFactory</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>用工厂方法构造scheuler实例，并使之正确的得到初始化。 所有的 Scheduler 实例应该由 SchedulerFactory 来创建。</li>
<li>　Quartz 框架为这一目的提供了 org.quartz.SchedulerFactory 接口。角色 SchedulerFactory 就是用来产生 Scheduler 实例的。当 Scheduler 实例被创建之后，就会存到一个仓库中(org.quartz.impl.SchedulerRepository)，这个仓库还提供了通过一个 class loader 查询实例的机制。<br><img src="../images/QuartzFigure4.3.JPG" alt=""><ul>
<li>DirectSchedulerFactory 是为那些想绝对控制 Scheduler 实例是如何生产出的人所设计的</li>
<li>与 DirectSchedulerFactory 形成鲜明对比的是，org.quartz.impl.StdSchedulerFactory 依赖于一系列的属性来决定如何生产出 Scheduler 实例</li>
</ul>
</li>
</ul>
<h2 id="StdSchedulerFactory源码分析"><a href="#StdSchedulerFactory源码分析" class="headerlink" title="StdSchedulerFactory源码分析"></a>StdSchedulerFactory源码分析</h2><ol>
<li><p>无参的initialize()方法，StdSchedulerFactory 会执行以下几个步骤去尝试为工厂加载属性：</p>
<ol>
<li>检查 System.getProperty(“org.quartz.properties”) 中是否设置了别的文件名</li>
<li>否则，使用 quartz.properties 作为要加载的文件名</li>
<li>试图从当前工作目录中加载这个文件</li>
<li>试图从系统 classpath 下加载这个文件<br><img src="../images/stdchedulerFactory-initialize.png" alt=""></li>
</ol>
</li>
<li><p>StdSchedulerFactory.getScheduler()源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public Scheduler getScheduler() throws SchedulerException &#123;</div><div class="line">        // 读取quartz配置文件，未指定则顺序遍历各个path下的quartz.properties文件</div><div class="line">        // 解析出quartz配置内容和环境变量，存入PropertiesParser对象</div><div class="line">        // PropertiesParser组合了Properties（继承Hashtable），定义了一系列对Properties的操作方法，比如getPropertyGroup()批量获取相同前缀的配置。配置内容和环境变量存放在Properties成员变量中</div><div class="line">        if (cfg == null) &#123;</div><div class="line">            initialize();</div><div class="line">        &#125;</div><div class="line">        // 获取调度器池，采用了单例模式</div><div class="line">        // 其实，调度器池的核心变量就是一个hashmap，每个元素key是scheduler名，value是scheduler实例</div><div class="line">        // getInstance()用synchronized防止并发创建</div><div class="line">        SchedulerRepository schedRep = SchedulerRepository.getInstance();</div><div class="line"></div><div class="line">        // 从调度器池中取出当前配置所用的调度器</div><div class="line">        Scheduler sched = schedRep.lookup(getSchedulerName());</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">        // 如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：（见实例化源码分析）</div><div class="line">        sched = instantiate();</div><div class="line"></div><div class="line">        return sched;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>instantiate()实例化，源码分析<br>如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：</p>
<ul>
<li>1）初始化threadPool(线程池)：开发者可以通过org.quartz.threadPool.class配置指定使用哪个线程池类，比如SimpleThreadPool。先class load线程池类，接着动态生成线程池实例bean，然后通过反射，使用setXXX()方法将以org.quartz.threadPool开头的配置内容赋值给bean成员变量；</li>
<li>2）初始化jobStore(任务存储方式)：开发者可以通过org.quartz.jobStore.class配置指定使用哪个任务存储类，比如RAMJobStore。先class load任务存储类，接着动态生成实例bean，然后通过反射，使用setXXX()方法将以org.quartz.jobStore开头的配置内容赋值给bean成员变量；</li>
<li>3）初始化dataSource(数据源)：开发者可以通过org.quartz.dataSource配置指定数据源详情，比如哪个数据库、账号、密码等。jobStore要指定为JDBCJobStore，dataSource才会有效；</li>
<li>4）初始化其他配置：包括SchedulerPlugins、JobListeners、TriggerListeners等；</li>
<li>5）初始化threadExecutor(线程执行器)：默认为DefaultThreadExecutor；</li>
<li>6）创建工作线程：根据配置创建N个工作thread，执行start()启动thread，并将N个thread顺序add进threadPool实例的空闲线程列表availWorkers中；</li>
<li>7）创建调度器线程：创建QuartzSchedulerThread实例，并通过threadExecutor.execute(实例)启动调度器线程；</li>
<li>8）创建调度器：创建StdScheduler实例，将上面所有配置和引用组合进实例中，并将实例存入调度器池中</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B62-quartz%E8%B0%83%E5%BA%A6%E5%99%A8scheduler.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Quartz详解及源码探究1-quartz入门及核心概念</title>
      <link>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B61-quartz%E5%85%A5%E9%97%A8%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html</link>
      <guid>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B61-quartz%E5%85%A5%E9%97%A8%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html</guid>
      <pubDate>Mon, 14 Aug 2017 07:16:39 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Quartz核心概念&quot;&gt;&lt;a href=&quot;#Quartz核心概念&quot; class=&quot;headerlink&quot; title=&quot;Quartz核心概念&quot;&gt;&lt;/a&gt;Quartz核心概念&lt;/h1&gt;&lt;h2 id=&quot;Quartz使用入门&quot;&gt;&lt;a href=&quot;#Quartz使用入门&quot;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Quartz核心概念"><a href="#Quartz核心概念" class="headerlink" title="Quartz核心概念"></a>Quartz核心概念</h1><h2 id="Quartz使用入门"><a href="#Quartz使用入门" class="headerlink" title="Quartz使用入门"></a>Quartz使用入门</h2><ul>
<li>首先看一个Quartz入门demo，由此入门demo深入剖析Quartz原理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package quartz;</div><div class="line"></div><div class="line">import org.quartz.*;</div><div class="line">import org.quartz.impl.StdSchedulerFactory;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by liuhang on 2017/8/1.</div><div class="line"> */</div><div class="line">public class QuartzTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            </div><div class="line">            //工程方法模式构造scheduler</div><div class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</div><div class="line"></div><div class="line">            //这里用到Builder模式</div><div class="line">            JobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(&quot;myJob&quot;, &quot;myJobGroup&quot;).build();</div><div class="line"></div><div class="line">            Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;myTrigger&quot;, &quot;myTriggerGroup&quot;).startNow().withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever()).build();</div><div class="line"></div><div class="line">            scheduler.scheduleJob(jobDetail, trigger);</div><div class="line"></div><div class="line">            scheduler.start();</div><div class="line"></div><div class="line"></div><div class="line">        &#125; catch (SchedulerException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package quartz;</div><div class="line"></div><div class="line">import org.quartz.Job;</div><div class="line">import org.quartz.JobExecutionContext;</div><div class="line">import org.quartz.JobExecutionException;</div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by liuhang on 2017/8/1.</div><div class="line"> */</div><div class="line">public class JobImpl implements Job &#123;</div><div class="line">    private static Logger logger = LoggerFactory.getLogger(JobImpl.class);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</div><div class="line">        logger.info(&quot;Hello World! - &quot; + new Date());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>由demo可以看出，quartz的几个核心概念：Job，Trigger，Scheduler，Calendar； 如下图所示<br><img src="../images/quartz核心概念.png" alt=""></p>
<ul>
<li>Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）</li>
<li>Job：是一个接口，只有一个方法void execute(JobExecutionContext context)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中；</li>
<li>JobDetail：Quartz在每次执行Job时，都重新创建一个Job实例，所以它不直接接受一个Job的实例，相反它接收一个Job实现类，以便运行时通过newInstance()的反射机制实例化Job。因此需要通过一个类来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息，JobDetail承担了这一角色。</li>
<li>Trigger：是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当仅需触发一次或者以固定时间间隔周期执行，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如每早晨9:00执行，周一、周三、周五下午5:00执行等；</li>
<li>Calendar：org.quartz.Calendar和java.util.Calendar不同，它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。</li>
</ul>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html" target="_blank" rel="external">官方文档</a></p>
</li>
<li><p><a href="http://www.quartz-scheduler.org/api/2.2.1/index.html" target="_blank" rel="external">官方api</a></p>
</li>
<li><p><a href="https://unmi.cc/category/quartz/" target="_blank" rel="external">quartz详解博客-文档</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/bab8e4e32952" target="_blank" rel="external">quartz原理揭秘和源码解读
</a></p>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Quartz%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B61-quartz%E5%85%A5%E9%97%A8%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>大数据-Hadoop学习1</title>
      <link>http://liuhang.net.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop%E5%AD%A6%E4%B9%A01.html</link>
      <guid>http://liuhang.net.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop%E5%AD%A6%E4%B9%A01.html</guid>
      <pubDate>Mon, 31 Jul 2017 11:24:11 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Hadoop提供了一个稳定的共享存储和分析系统。存储由HDFS实现，分析由MapReduce实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ol>
<li>Hadoop提供了一个稳定的共享存储和分析系统。存储由HDFS实现，分析由MapReduce实现</li>
</ol>
<h1 id="Mac下Hadoop2-7-x配置伪分布环境-wordcount运行"><a href="#Mac下Hadoop2-7-x配置伪分布环境-wordcount运行" class="headerlink" title="Mac下Hadoop2.7.x配置伪分布环境(wordcount运行)"></a>Mac下Hadoop2.7.x配置伪分布环境(wordcount运行)</h1><h2 id="ssh环境配置"><a href="#ssh环境配置" class="headerlink" title="ssh环境配置"></a>ssh环境配置</h2><ol>
<li><code>ssh localhost</code>验证是否能无密码登录<ul>
<li>出现<code>ssh: connect to host localhost port 22: Connection refused</code>，在”系统偏好设置-共享”中打开远程登录选项</li>
</ul>
</li>
<li><code>ssh-keygen -t rsa -f ~/.ssh/id_rsa</code><br> <code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></li>
</ol>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><ol>
<li><code>export HADOOP_INSTALL=/Users/home/liuhang/Java/hadoop/hadoop-2.8.1</code><br> <code>export PATH=$PATH:$HADOOP_INSTALL/bin</code> ；export设置只对当前的bash登陆session有效.</li>
<li>要使得环境变量一直生效，可修改<code>vim ~/.bash_profile</code>,把命令加载进入bash启动脚本中</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://kiritor.github.io/2016/04/24/Hadoop-install/" target="_blank" rel="external">Mac下Hadoop2.7.x配置伪分布环境(wordcount运行)</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop%E5%AD%A6%E4%B9%A01.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>随笔-校招记录</title>
      <link>http://liuhang.net.cn/%E9%9A%8F%E7%AC%94-%E6%A0%A1%E6%8B%9B%E8%AE%B0%E5%BD%95.html</link>
      <guid>http://liuhang.net.cn/%E9%9A%8F%E7%AC%94-%E6%A0%A1%E6%8B%9B%E8%AE%B0%E5%BD%95.html</guid>
      <pubDate>Mon, 31 Jul 2017 07:38:22 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;练手的&quot;&gt;&lt;a href=&quot;#练手的&quot; class=&quot;headerlink&quot; title=&quot;练手的&quot;&gt;&lt;/a&gt;练手的&lt;/h1&gt;&lt;h2 id=&quot;拼多多-已投&quot;&gt;&lt;a href=&quot;#拼多多-已投&quot; class=&quot;headerlink&quot; title=&quot;拼多多(已投)&quot;&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="练手的"><a href="#练手的" class="headerlink" title="练手的"></a>练手的</h1><h2 id="拼多多-已投"><a href="#拼多多-已投" class="headerlink" title="拼多多(已投)"></a>拼多多(已投)</h2><ol>
<li>8.1号晚上，牛客</li>
</ol>
<h2 id="苏宁（已投）"><a href="#苏宁（已投）" class="headerlink" title="苏宁（已投）"></a>苏宁（已投）</h2><ol>
<li>筛选中</li>
</ol>
<h2 id="科大飞讯-已投"><a href="#科大飞讯-已投" class="headerlink" title="科大飞讯(已投)"></a>科大飞讯(已投)</h2><ol>
<li>筛选中</li>
</ol>
<h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><ol>
<li>内推</li>
<li>面试8.10-8.20左右</li>
</ol>
<h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><h2 id="京东（已投）"><a href="#京东（已投）" class="headerlink" title="京东（已投）"></a>京东（已投）</h2><ol>
<li>管培生，在线笔试：<strong>8月25日</strong></li>
<li>Java开发，在线笔试：<strong>9月8日</strong></li>
</ol>
<h2 id="百度（已投）"><a href="#百度（已投）" class="headerlink" title="百度（已投）"></a>百度（已投）</h2><ol>
<li>在线笔试：<strong>9月11日</strong>；</li>
</ol>
<h2 id="滴滴（已投）"><a href="#滴滴（已投）" class="headerlink" title="滴滴（已投）"></a>滴滴（已投）</h2><ol>
<li>笔试时间 <strong>8.26日</strong></li>
</ol>
<h2 id="今日头条（已投）"><a href="#今日头条（已投）" class="headerlink" title="今日头条（已投）"></a>今日头条（已投）</h2><ol>
<li>笔试时间未定</li>
</ol>
<h2 id="美团点评"><a href="#美团点评" class="headerlink" title="美团点评"></a>美团点评</h2><ol>
<li>内推 （已投）</li>
<li>秋招</li>
</ol>
<h2 id="网易（已投）"><a href="#网易（已投）" class="headerlink" title="网易（已投）"></a>网易（已投）</h2><ol>
<li>笔试时间<strong>9月9日</strong></li>
</ol>
<h2 id="腾讯（已投）"><a href="#腾讯（已投）" class="headerlink" title="腾讯（已投）"></a>腾讯（已投）</h2><ol>
<li>笔试时间<strong>9月13日</strong></li>
</ol>
<h2 id="去哪儿-已投"><a href="#去哪儿-已投" class="headerlink" title="去哪儿(已投)"></a>去哪儿(已投)</h2>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9A%8F%E7%AC%94-%E6%A0%A1%E6%8B%9B%E8%AE%B0%E5%BD%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试-设计模式</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</guid>
      <pubDate>Sun, 30 Jul 2017 13:44:04 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试-JVM相关</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-JVM%E7%9B%B8%E5%85%B3.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-JVM%E7%9B%B8%E5%85%B3.html</guid>
      <pubDate>Sun, 30 Jul 2017 13:41:45 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-JVM%E7%9B%B8%E5%85%B3.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程11-Fork/Join框架</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11-Fork-Join%E6%A1%86%E6%9E%B6.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11-Fork-Join%E6%A1%86%E6%9E%B6.html</guid>
      <pubDate>Mon, 24 Jul 2017 12:23:35 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11-Fork-Join%E6%A1%86%E6%9E%B6.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程0-Java多线程面试总结</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B0-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B0-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Sun, 23 Jul 2017 08:55:09 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.importnew.com/12773.html&quot; target=&quot;_blank&quot; re
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.importnew.com/12773.html" target="_blank" rel="external">面试问题收集</a></li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li><p>什么是线程</p>
<ul>
<li>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位</li>
</ul>
</li>
<li><p>进程和线程有什么区别</p>
<ul>
<li>进程是资源分配的基本单位，一个进程可以包含多个线程，进程间切换开销大；</li>
<li>引入线程的好处：创建进程开销小，易于调度，提高并发性</li>
</ul>
</li>
<li><p>Java实现多线程的方法</p>
<ul>
<li>继承Thread类，重写其run方法</li>
<li>实现Runnable接口（查看源码，发现Thread类也实现了Runnable接口）</li>
<li>实现Callable接口,Future,线程池框架</li>
</ul>
</li>
<li><p>用Runnable还是Thread</p>
<ul>
<li>Java不支持多继承，允许实现多个接口，如果要继承其他类，用Runable更好</li>
</ul>
</li>
<li><p>Java中Runnable和Callable有什么不同？</p>
<ul>
<li>主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象</li>
</ul>
</li>
<li><p>Volatile变量</p>
<ul>
<li><strong>可见性</strong>：每次使用v之前，从主内存刷新最新的值(read,load,use操作连在一起)； 每次修改V之后，立马同步回主内存(assign,store,write操作连在一起)；</li>
<li><strong>防止指令重排</strong>：保证代码执行顺序，与程序顺序相同;下一个读取操作会在前一个写操作之后发生。volatile写之前的所有操作都不会被重排序到volatile之后;保volatile读之后的所有操作都不会被重排序到volatile之前;第一个操作是volatile写操作时,第二个操作是volatile读操作,不能进行重排序.</li>
</ul>
</li>
<li><p>Java内存模型</p>
<ul>
<li>规定Java程序在不同硬件平台下，达到一致的内存访问效果。屏蔽掉硬件和操作系统的差异</li>
</ul>
</li>
<li><p>什么是竞态条件。</p>
<ul>
<li>当多个线程竞争同一资源时，程序的结果依赖于线程执行的顺序。由于不恰当的执行顺序，而出现不正确的结果，即出现”竞态条件“</li>
<li>举例： 单例模式，延迟加载。</li>
</ul>
</li>
<li><p>线程池，为什么要用线程池</p>
<ul>
<li>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理</li>
<li>好处：<ul>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadLocal变量</p>
<ul>
<li>线程局部变量</li>
<li>用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。采用的是空间换时间的策略</li>
<li>底层原理：ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本</li>
<li>与同步机制的比较：synchronized同步机制，仅提供一份变量，让不同的线程排队访问，后者为每个线程都提供了一份变量，互相不影响的访问。</li>
<li>应用：Spirng中，有状态的Bean，用ThreadLocal封装，可以申明为Singleton作用域，变成无状态的</li>
</ul>
</li>
<li><p>Java中interrupted 和 isInterruptedd方法的区别</p>
<ul>
<li>interrupted方法，静态方法，Thread.interrupted，测试当前线程是否中断；调用之后，中断状态会被清除为false</li>
<li>isInterrupted，非静态方法，查询这个线程是否中断</li>
</ul>
</li>
<li><p>读写锁</p>
<ul>
<li>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞；</li>
<li>读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升；</li>
<li>应用场景：读多于写的情况</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li>产生死锁的四个必要条件<ul>
<li>互斥（ Mutual exclusion ）条件：一个资源一次只能被一个进程所使用，即是排它性使用。</li>
<li>不可抢占（ No preemption ）条件：一个资源仅能被占有它的进程所释放，而不能被别的进程强占。</li>
<li>请求和保持（ Hold-and-wait ）条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放。</li>
<li>环路等待（ Circular wait ）条件：当每类资源只有一个时，在发生死锁时，必然存在一个进程-资源的环形链。如一系统状态的资源分配图所示，P1正在等待一个P2 占用的资源R2，P2正在等待一个P1占用的资源R1。</li>
</ul>
</li>
<li>死锁的预防： 破坏四个条件之一</li>
<li>死锁的避免：在资源分配之前，计算分配是否安全。 如：银行家算法</li>
</ul>
</li>
<li><p>阻塞队列</p>
<ul>
<li>阻塞队列（BlockingQueue），支持阻塞的插入和移除方法<ul>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空</li>
</ul>
</li>
<li>Java里的阻塞队列(Java里的阻塞队列)<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
</ul>
</li>
</ul>
</li>
<li><p>Fork/join框架</p>
<ul>
<li>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干<br>个小任务，最终汇总每个小任务结果后得到大任务结果的框架</li>
<li>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行</li>
<li>ForkJoinTask：分隔任务；RecursiveTask：用于有返回结果的任务。RecursiveAction：用于没有返回结果的任务。</li>
<li>ForkJoinPool：执行任务</li>
</ul>
</li>
<li><p>重入锁，公平锁</p>
<ul>
<li>重入锁：同一个线程再次进入同步代码的时候.可以再次获取自己已经获取到的锁。</li>
<li>公平锁：多个线程再等待同一个锁时，必须按照申请锁的实际顺序来依次获得锁</li>
</ul>
</li>
<li><p>CountDownLatch计数门闩与同步屏障CyclicBarrier</p>
<ul>
<li>CountDownLatch允许一个或多个线程等待其他线程完成操作（跟join类似）</li>
<li>CyclicBarrier让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</li>
<li>区别：CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置</li>
</ul>
</li>
<li><p>控制并发线程数的Semaphore</p>
<ul>
<li>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</li>
</ul>
</li>
<li><p>线程池原理</p>
<ul>
<li>为什么使用线程池，线程池好处<ul>
<li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，<br>还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>
</ul>
</li>
</ul>
</li>
<li><p>ConcurrentHashMap</p>
<ul>
<li>使用了锁分段技术技术来保证线程安全的，锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</li>
<li>put和get操作是原子操作，是线程安全</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B0-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程10-定时器Timer</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B10-%E5%AE%9A%E6%97%B6%E5%99%A8Timer.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B10-%E5%AE%9A%E6%97%B6%E5%99%A8Timer.html</guid>
      <pubDate>Sat, 22 Jul 2017 09:07:51 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B10-%E5%AE%9A%E6%97%B6%E5%99%A8Timer.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring-源码研究2-AOP实现</title>
      <link>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B62-AOP%E5%AE%9E%E7%8E%B0.html</link>
      <guid>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B62-AOP%E5%AE%9E%E7%8E%B0.html</guid>
      <pubDate>Tue, 18 Jul 2017 08:33:04 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B62-AOP%E5%AE%9E%E7%8E%B0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring-源码研究3-SpringMVC实现</title>
      <link>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B63-SpringMVC%E5%AE%9E%E7%8E%B0.html</link>
      <guid>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B63-SpringMVC%E5%AE%9E%E7%8E%B0.html</guid>
      <pubDate>Tue, 18 Jul 2017 08:32:32 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B63-SpringMVC%E5%AE%9E%E7%8E%B0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring-源码研究1-ioc容器实现</title>
      <link>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B61-ioc%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0.html</link>
      <guid>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B61-ioc%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0.html</guid>
      <pubDate>Mon, 17 Jul 2017 07:28:05 GMT</pubDate>
      <description>
      
        研究Spring源码！
      
      </description>
      
      <comments>http://liuhang.net.cn/Spring-%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B61-ioc%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring-面试问题总结</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Spring-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Spring-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Sun, 16 Jul 2017 02:30:21 GMT</pubDate>
      <description>
      
        Spring总结，面试问题总结
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Spring是什么，简单说下Spring"><a href="#Spring是什么，简单说下Spring" class="headerlink" title="Spring是什么，简单说下Spring"></a>Spring是什么，简单说下Spring</h1><ol>
<li>Spring是分层的Java EE/SE一站式开源框架，它以IoC控制反转和AOP（面向切面编程）为核心。</li>
</ol>
<h1 id="Spring优点"><a href="#Spring优点" class="headerlink" title="Spring优点"></a>Spring优点</h1><ul>
<li>IoC支持方便解耦，简化开发</li>
<li>AOP编程的支持</li>
<li>声明式事务的支持</li>
<li>方便程序的测试</li>
<li>方便集成各种优秀框架</li>
<li>降低JavaEE API的使用难度</li>
</ul>
<h1 id="控制反转IoC和依赖注入DI"><a href="#控制反转IoC和依赖注入DI" class="headerlink" title="控制反转IoC和依赖注入DI"></a>控制反转IoC和依赖注入DI</h1><ul>
<li>控制反转：借助第三方（即容器），把新建对象的控制权，交给了容器，由容器负责对象新建装配</li>
<li>依赖注入：实现控制反转的方式有依赖注入和依赖查找</li>
<li>Spring中依赖注入DI的类型：构造函数注入，属性注入；</li>
</ul>
<h1 id="Spring中装配Bean的几种方式"><a href="#Spring中装配Bean的几种方式" class="headerlink" title="Spring中装配Bean的几种方式"></a>Spring中装配Bean的几种方式</h1><ul>
<li>现在有四种方式<ul>
<li>基于XML配置</li>
<li>基于注解配置</li>
<li>基于Java配置</li>
<li>基于Groovy 动态语言配置</li>
</ul>
</li>
</ul>
<h1 id="Spring中用到了哪些设计模式"><a href="#Spring中用到了哪些设计模式" class="headerlink" title="Spring中用到了哪些设计模式"></a>Spring中用到了哪些设计模式</h1><ol>
<li>代理模式,</li>
<li>工厂模式</li>
<li>单例模式</li>
<li>模板方法模式：用来解决代码重复的问题</li>
<li>策略模式：Resource与ResourceLoader</li>
</ol>
<h1 id="描述一下-Spring-Bean的生命周期"><a href="#描述一下-Spring-Bean的生命周期" class="headerlink" title="描述一下 Spring Bean的生命周期"></a>描述一下 Spring Bean的生命周期</h1><p>关键节点</p>
<ol>
<li>实例化，前后InstantiationAwareBeanPostProcessor接口的方法；</li>
<li>设置属性值， 后 BeanNameAware和BeanFactoryAware，感知BeanName和BeanFactory</li>
<li>初始化方法（init-method） 前后 BeanPostProcessor接口方法，对Bean进行处理，前nitializingBean处理</li>
<li>销毁方法(destory-method)，前DisposeBean处理</li>
</ol>
<p>三类方法调用</p>
<ol>
<li>Bean自身的方法调用，构造函数来实例化Bean,Setter方法设置Bean的属性，init_method和destory_method方法</li>
<li>Bean级生命周期接口方法（Bean自己实现的接口），BeanNameAware和BeanFactoryAware,InitializingBean和DisposeBean</li>
<li>容器及生命周期接口方法，InstantiationAwareBeanPostProcessor和BeanPostProcessor接口，分别在实例化和初始化前后，对Bean进行处理</li>
</ol>
<h1 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h1><ol>
<li>BeanFactory是Spring最核心的接口，它是工厂模式的实现，来负责实例化Bean并建立Bean之间的依赖关系，控制Bean的生命周期；</li>
<li>ApplicationContext应用上下文，它是建立在BeanFactory基础上（ApplicationContext接口继承ListableBeanFactory接口，ListableBeanFactory继承BeanFactory接口）；BeanFactory更加底层，它面对Spring本身；而ApplicationContext面向使用Spring的开发者；它的主要实现者有ClassPathXmlApplicationContext，FileSystemXmlApplicationContext等</li>
<li>ApplicationContext提供了更多面向实际应用的功能<ul>
<li>国际化消息访问功能</li>
<li>统一的资源读取方式</li>
<li>能够发布事件，并允许注册相应的事件监听器；</li>
</ul>
</li>
</ol>
<h1 id="FactoryBean和BeanFactory"><a href="#FactoryBean和BeanFactory" class="headerlink" title="FactoryBean和BeanFactory"></a>FactoryBean和BeanFactory</h1><ol>
<li>FactoryBean，顾名思义，工厂Bean（像工厂一样的Bean）,是一个能产生或者修饰对象的Bean，可以在ioc容器中被管理,用户通过实现FacatoryBean接口定制实例化Bean的逻辑,使用“&amp;”前缀，获取FactoryBean产生的对象（getObject方法）；</li>
<li>BeanFactory，ioc容器，对Bean进行管理；</li>
</ol>
<h1 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h1><ol>
<li>singleton 仅存在一个Bean实例</li>
<li>prototype 每次调用Bean时，都返回一个新实例</li>
<li>request 每次http请求，创建一个新的Bean</li>
<li>session 同一个Http Session，共享一个Bean</li>
<li>globalSession global-session和Portlet应用相关；</li>
</ol>
<h1 id="Spring内部Bean"><a href="#Spring内部Bean" class="headerlink" title="Spring内部Bean"></a>Spring内部Bean</h1><ol>
<li>内部bean和Java匿名内部类相似，仅仅被某一个bean调用</li>
</ol>
<h1 id="基于注解配置，说说所知道的注解"><a href="#基于注解配置，说说所知道的注解" class="headerlink" title="基于注解配置，说说所知道的注解"></a>基于注解配置，说说所知道的注解</h1><ol>
<li>@Component注解，定义Bean； 对应的在分层结构中，DAO层，@Repository；Service层：@Service； Web层：@Controller</li>
<li>@Autowired注解，自动装配（required= false），@Lazy注解，延迟注入</li>
<li>@Configuration注解，基于Java类配置；@Bean注解； </li>
<li>Spring MVC注解，@RequestMapping</li>
<li>Spring Cache, @Cacheable注解</li>
</ol>
<h1 id="Spring的单例Bean是线程安全的吗"><a href="#Spring的单例Bean是线程安全的吗" class="headerlink" title="Spring的单例Bean是线程安全的吗"></a>Spring的单例Bean是线程安全的吗</h1><ol>
<li>并没有对单例bean进行任何多线程的封装处理；自行去保证线程安全</li>
</ol>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="Spring-MVC过程"><a href="#Spring-MVC过程" class="headerlink" title="Spring MVC过程"></a>Spring MVC过程</h2><ol>
<li>DispatcherServlet接收请求</li>
<li>HanddlerMappig来寻找对应的处理器(Controller)</li>
<li>DispatcherServlet根据查找到的处理器，通过HandlerAdapter处理器适配器，调用处理器的方法，</li>
<li>处理器完成业务逻辑后，返回ModelAndView</li>
<li>DispatcherServlet调用试图解析器解析视图，视图渲染，得到最后的页面</li>
<li>返回。</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Spring-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式7-策略模式</title>
      <link>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</link>
      <guid>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</guid>
      <pubDate>Tue, 11 Jul 2017 16:00:03 GMT</pubDate>
      <description>
      
        策略模式，策略模式在Spring中的使用
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="策略模式在Spring中的使用"><a href="#策略模式在Spring中的使用" class="headerlink" title="策略模式在Spring中的使用"></a>策略模式在Spring中的使用</h1><ul>
<li>Resource与ResourceLoader配合使用,来访问资源，读取配置文件信息等。</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程7-Future与Callable,FutureTask</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B7-Future%E4%B8%8ECallable-FutureTask.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B7-Future%E4%B8%8ECallable-FutureTask.html</guid>
      <pubDate>Mon, 03 Jul 2017 13:07:08 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/ghsau/article/details/7451464&quot; tar
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.csdn.net/ghsau/article/details/7451464" target="_blank" rel="external">Java线程(七)：Callable和Future|csdn博客</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B7-Future%E4%B8%8ECallable-FutureTask.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程7-线程池</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B9-%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B9-%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</guid>
      <pubDate>Mon, 03 Jul 2017 12:44:25 GMT</pubDate>
      <description>
      
        线程池原理，线程池框架源码分析
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p><img src="../images/threadpool.png" alt=""></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><ul>
<li>线程池核心代码<br><img src="../images/线程池源码.png" alt=""></li>
</ul>
<ul>
<li>工作线程<ul>
<li>工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，<strong>还会循环获取工作队列里的任务来执行</strong><br><img src="../images/多线程worker.png" alt=""></li>
</ul>
</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B9-%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程8-信号量</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8-%E4%BF%A1%E5%8F%B7%E9%87%8F.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8-%E4%BF%A1%E5%8F%B7%E9%87%8F.html</guid>
      <pubDate>Mon, 03 Jul 2017 12:43:22 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8-%E4%BF%A1%E5%8F%B7%E9%87%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程6-阻塞队列</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html</guid>
      <pubDate>Mon, 03 Jul 2017 11:59:22 GMT</pubDate>
      <description>
      
        阻塞队列，非阻塞队列，待详细总结
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.importnew.com/6695.html" target="_blank" rel="external">阻塞队列实现生产者消费者模式</a></li>
<li><a href="http://www.cnblogs.com/yzlpersonal/p/5231649.html" target="_blank" rel="external">生产者-消费者 用非阻塞队列、Object.wait()、Object.notify()实现</a></li>
<li><a href="http://www.chongchonggou.com/g_645129056.html" target="_blank" rel="external">高并发:阻塞队列 实现生产者-消费者模式</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程5-设计线程安全的类</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B5-%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B5-%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB.html</guid>
      <pubDate>Sat, 01 Jul 2017 12:55:04 GMT</pubDate>
      <description>
      
        介绍如何设计线程安全的类
      
      </description>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B5-%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程4-ThreadLocal</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-ThreadLocal.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-ThreadLocal.html</guid>
      <pubDate>Sat, 01 Jul 2017 09:47:42 GMT</pubDate>
      <description>
      
        ThreadLocal
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h1><ol>
<li>线程局部变量</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="http://blog.zhangjikai.com/2017/03/29/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-ThreadLocal/" target="_blank" rel="external">ThreadLocal详解</a></p>
</li>
<li><p>ThreadLocal(线程变量副本)</p>
<ul>
<li>Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。</li>
<li>采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。</li>
<li>ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。</li>
<li>ThreadLocal在spring中发挥着巨大的作用，在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影。</li>
<li>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-ThreadLocal.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程1-线程安全概述</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.html</guid>
      <pubDate>Thu, 29 Jun 2017 15:09:02 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;什么是线程安全性&quot;&gt;&lt;a href=&quot;#什么是线程安全性&quot; class=&quot;headerlink&quot; title=&quot;什么是线程安全性&quot;&gt;&lt;/a&gt;什么是线程安全性&lt;/h1&gt;&lt;h2 id=&quot;线程安全类：&quot;&gt;&lt;a href=&quot;#线程安全类：&quot; class=&quot;headerli
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h1><h2 id="线程安全类："><a href="#线程安全类：" class="headerlink" title="线程安全类："></a>线程安全类：</h2><ul>
<li>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么久称这个类是线程安全的</li>
<li>在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程3-Java内存模型</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</guid>
      <pubDate>Wed, 28 Jun 2017 15:17:34 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Java内存模型参考&quot;&gt;&lt;a href=&quot;#Java内存模型参考&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型参考&quot;&gt;&lt;/a&gt;Java内存模型参考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://ifeve.com/java
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Java内存模型参考"><a href="#Java内存模型参考" class="headerlink" title="Java内存模型参考"></a>Java内存模型参考</h1><ol>
<li><a href="http://ifeve.com/java-memory-model-6/" target="_blank" rel="external">Java内存模型|讲的非常详细</a></li>
</ol>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="两个关键方面"><a href="#两个关键方面" class="headerlink" title="两个关键方面"></a>两个关键方面</h2><ol>
<li>可见性 Memory Visibility</li>
<li>竞态条件（Race Condition）</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ol>
<li>可见性： assign store </li>
<li>防止指令重排</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人计划至8.5</title>
      <link>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B37%E6%9C%88%E5%BA%95.html</link>
      <guid>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B37%E6%9C%88%E5%BA%95.html</guid>
      <pubDate>Wed, 28 Jun 2017 11:11:57 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;总体：Spring-JVM，多线程&quot;&gt;&lt;a href=&quot;#总体：Spring-JVM，多线程&quot; class=&quot;headerlink&quot; title=&quot;总体：Spring,JVM，多线程&quot;&gt;&lt;/a&gt;总体：Spring,JVM，多线程&lt;/h1&gt;&lt;h2 id=&quot;书&quot;&gt;&lt;a
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="总体：Spring-JVM，多线程"><a href="#总体：Spring-JVM，多线程" class="headerlink" title="总体：Spring,JVM，多线程"></a>总体：Spring,JVM，多线程</h1><h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><ol>
<li>《深入理解Java虚拟机》</li>
<li>《Java并发编程实战》</li>
<li>《精通Spring4.x 企业应用开发实战》</li>
<li>《Java多线程编程核心技术》</li>
</ol>
<h2 id="核心提升"><a href="#核心提升" class="headerlink" title="核心提升"></a>核心提升</h2><ol>
<li>Java并发编程学习 </li>
<li>Quartz</li>
<li>消息中间件知识，KafKa复习</li>
</ol>
<h1 id="每日计划"><a href="#每日计划" class="headerlink" title="每日计划"></a>每日计划</h1><pre><code>- 阶段1到阶段6（8.3号），每日一个编程真题（公司笔试真题）
- 阶段7开始，每日刷公司真题和编程题，自由复习阶段，查漏补缺
</code></pre><h2 id="阶段一：Spring复习巩固，完成小项目一个7天"><a href="#阶段一：Spring复习巩固，完成小项目一个7天" class="headerlink" title="阶段一：Spring复习巩固，完成小项目一个7天"></a>阶段一：Spring复习巩固，完成小项目一个7天</h2><ol>
<li><p>7.14看书</p>
<ul>
<li>《Spring4.x》7.8.9三章看完（Spring aop内容），结合18论坛项目的代码</li>
</ul>
</li>
<li><p>7.15总结</p>
<ul>
<li>总结Spirng ioc、aop、事物</li>
<li>自己实现简单ioc与aop，研究ioc与aop的源码(结合深入解析那本书)</li>
</ul>
</li>
<li><p>7.16看书</p>
<ul>
<li>《Spring4.x》10.11.12.13.14 Spring数据篇</li>
</ul>
</li>
<li><p>7.17看书</p>
<ul>
<li>《Spring4.x》15 Spring缓存，memchched与redis复习</li>
</ul>
</li>
<li><p>7.18总结</p>
<ul>
<li>总结Spirng数据库操作，Hibernate与Mybatis相关，缓存相关，数据库常见问题</li>
</ul>
</li>
<li><p>7.19看书</p>
<ul>
<li>《Spring4.x》17 SpringMvc复习总结完毕，结合18论坛代码，写完跑通</li>
</ul>
</li>
<li><p>7.20总结</p>
<ul>
<li>Spring mvc总结</li>
<li><strong>Spring面经总结，项目中的Spring遇到的问题及解决方法：包括Spirng ioc,aop,事物，数据库，spring mvc,spring boot</strong></li>
</ul>
</li>
</ol>
<h2 id="阶段二：多线程复习巩固5天"><a href="#阶段二：多线程复习巩固5天" class="headerlink" title="阶段二：多线程复习巩固5天"></a>阶段二：多线程复习巩固5天</h2><ol>
<li><p>7.21看书</p>
<ul>
<li>《Java多线程编程核心技术》1-3章</li>
</ul>
</li>
<li><p>7.22看书</p>
<ul>
<li>《Java多线程编程核心技术》4-6章</li>
</ul>
</li>
<li><p>7.23看书</p>
<ul>
<li>《Spring4.x》16 Spirng任务调度，exectue框架  Quatrz复习</li>
</ul>
</li>
<li><p>7.24看书</p>
<ul>
<li>Quatrz学习总结</li>
</ul>
</li>
<li><p>7.25 </p>
<ul>
<li><strong>多线程面试总结</strong></li>
<li><strong>整理项目中遇到的多线程问题，及解决方法</strong></li>
</ul>
</li>
</ol>
<h2 id="阶段三-消息中间件突击复习，kafka学习4天"><a href="#阶段三-消息中间件突击复习，kafka学习4天" class="headerlink" title="阶段三: 消息中间件突击复习，kafka学习4天"></a>阶段三: 消息中间件突击复习，kafka学习4天</h2><ol>
<li>7.26</li>
<li>7.27</li>
<li>7.28</li>
<li>7.29</li>
</ol>
<h2 id="阶段四：JVM复习总结3天"><a href="#阶段四：JVM复习总结3天" class="headerlink" title="阶段四：JVM复习总结3天"></a>阶段四：JVM复习总结3天</h2><ol>
<li><p>7.30看书</p>
<ul>
<li>JVM书</li>
</ul>
</li>
<li><p>7.31看书</p>
<ul>
<li>JVM书</li>
</ul>
</li>
<li><p>8.1总结<br>-JVM面经总结</p>
<ul>
<li><strong>项目中遇到的JVM调优问题及解决方法</strong></li>
</ul>
</li>
</ol>
<h2 id="阶段五：-设计模式总结1天"><a href="#阶段五：-设计模式总结1天" class="headerlink" title="阶段五： 设计模式总结1天"></a>阶段五： 设计模式总结1天</h2><ol>
<li>8.2号<ul>
<li><strong>设计模式常见面试问题总结</strong></li>
<li>手写单例模式准备（多线程情况）</li>
</ul>
</li>
</ol>
<h2 id="阶段六：-Sql基础复习1天"><a href="#阶段六：-Sql基础复习1天" class="headerlink" title="阶段六： Sql基础复习1天"></a>阶段六： Sql基础复习1天</h2><ol>
<li>8.3号<ul>
<li>mysql必知必会</li>
<li>刷Sql题目6+</li>
</ul>
</li>
</ol>
<h2 id="阶段七：刷公司真题，剑指offer及查漏补缺复习"><a href="#阶段七：刷公司真题，剑指offer及查漏补缺复习" class="headerlink" title="阶段七：刷公司真题，剑指offer及查漏补缺复习"></a>阶段七：刷公司真题，剑指offer及查漏补缺复习</h2><ol>
<li><p>8.4号</p>
<ul>
<li>排序算法复习巩固（手写排序算法）</li>
<li>排序的选择题巩固</li>
</ul>
</li>
<li><p>8.5号</p>
<ul>
<li>公司真题之阿里</li>
</ul>
</li>
<li><p>8.</p>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B37%E6%9C%88%E5%BA%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java并发编程2-Java多线程基础</title>
      <link>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</link>
      <guid>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</guid>
      <pubDate>Wed, 28 Jun 2017 09:16:17 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;多线程与并发参考资料&quot;&gt;&lt;a href=&quot;#多线程与并发参考资料&quot; class=&quot;headerlink&quot; title=&quot;多线程与并发参考资料&quot;&gt;&lt;/a&gt;多线程与并发参考资料&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://ifeve.com/java-c
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="多线程与并发参考资料"><a href="#多线程与并发参考资料" class="headerlink" title="多线程与并发参考资料"></a>多线程与并发参考资料</h1><ol>
<li><a href="http://ifeve.com/java-concurrency-thread-directory/" target="_blank" rel="external">Java并发性和多线程</a></li>
</ol>
<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="管理线程的几种方法"><a href="#管理线程的几种方法" class="headerlink" title="管理线程的几种方法"></a>管理线程的几种方法</h2><p><img src="../images/管理线程的几种方法.png" alt=""></p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ol>
<li>实现Runnable接口</li>
<li>继承Thread类</li>
<li>都通过start方法，启动线程。优先runnable接口，可实现多个接口</li>
</ol>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ol>
<li>每一个对象都隐含着一个锁对象，这个锁对象就是用来解决并发问题的互斥量（mutex）。要调用一个对象的synchronized方法的线程，必须持有这个对象的锁对象，在执行完毕之后，必须释放这个锁对象，以让别的线程得到这个锁对象。</li>
<li><a href="http://ifeve.com/synchronized-blocks/" target="_blank" rel="external">同步</a></li>
</ol>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ul>
<li>以下三个方法，仅在synchronized方法中可以调用</li>
<li>wait,告知被调用的线程，放弃锁，直到其他线程进入并调用notify唤醒</li>
<li>notify</li>
<li>notifyAll</li>
<li><a href="http://ifeve.com/thread-signaling/#wait_notify" target="_blank" rel="external">notify|wait详解</a></li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM-程序编译与代码优化</title>
      <link>http://liuhang.net.cn/JVM-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html</link>
      <guid>http://liuhang.net.cn/JVM-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html</guid>
      <pubDate>Wed, 28 Jun 2017 08:06:04 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Java语法糖&quot;&gt;&lt;a href=&quot;#Java语法糖&quot; class=&quot;headerlink&quot; title=&quot;Java语法糖&quot;&gt;&lt;/a&gt;Java语法糖&lt;/h1&gt;&lt;h2 id=&quot;泛型与类型擦除&quot;&gt;&lt;a href=&quot;#泛型与类型擦除&quot; class=&quot;headerlink
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h1><h2 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h2><h2 id="自动拆箱与装箱"><a href="#自动拆箱与装箱" class="headerlink" title="自动拆箱与装箱"></a>自动拆箱与装箱</h2>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/JVM-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM-Java内存区域与内存溢出异常</title>
      <link>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html</link>
      <guid>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html</guid>
      <pubDate>Wed, 28 Jun 2017 08:01:39 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;内存空间（运行时数据区）&quot;&gt;&lt;a href=&quot;#内存空间（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;内存空间（运行时数据区）&quot;&gt;&lt;/a&gt;内存空间（运行时数据区）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../images/jvmneicun.
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="内存空间（运行时数据区）"><a href="#内存空间（运行时数据区）" class="headerlink" title="内存空间（运行时数据区）"></a>内存空间（运行时数据区）</h1><p><img src="../images/jvmneicun.png" alt=""> </p>
<ol>
<li>程序计数器： 线程私有；看作当前线程所执行的字节码的行号指示器</li>
<li>虚拟机栈： 线程私有；（即常说的堆内存和栈内存中的栈），栈帧结构，存储局部变量表，操作数等</li>
<li>本地方法栈： 虚拟机使用到的native方法</li>
<li>Java堆，<strong>线程共享</strong>，所有的对象实例和数组在堆上分配内存。垃圾回收的主要区域。</li>
<li>方法区： 各<strong>线程共享</strong>，存储已经被虚拟机加载的类信息、常量、静态变量等。运行时常量池是方法区的一部分。</li>
</ol>
<h1 id="虚拟机参数"><a href="#虚拟机参数" class="headerlink" title="虚拟机参数"></a>虚拟机参数</h1><ol>
<li>JVM启动参数分为三类：<ul>
<li>标准参数(-):所有的JVM实现都必须实现这些参数的功能，而且向后兼容; 命令行 java -? 查看参数</li>
<li>非标准参数(-X):默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容；命令行 java -X 查看参数</li>
<li>非稳定参数(-XX):此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用；</li>
</ul>
</li>
<li>常用参数设置<ul>
<li>最大堆和初始堆<code>-Xms</code>初始堆内存大小，<code>-Xmx</code>最大堆内存大小</li>
<li>新生代配置<code>-Xmn</code>新生代内存大小，<code>-XX:SurvivorRatio</code>设置新生代eden空间和from/to空间比例；<code>-XX:NewRatio</code>老年代和新生代比例</li>
<li>系统参数查看：<code>-XX:+PrintVMOptions</code>打印虚拟机接收到的显示参数</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM-线程安全与锁优化</title>
      <link>http://liuhang.net.cn/JVM-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html</link>
      <guid>http://liuhang.net.cn/JVM-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html</guid>
      <pubDate>Wed, 28 Jun 2017 07:59:27 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JVM-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM-Java内存模型与线程</title>
      <link>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</link>
      <guid>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</guid>
      <pubDate>Wed, 28 Jun 2017 07:58:05 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JVM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaWeb基础-Session与Cookie</title>
      <link>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-Session%E4%B8%8ECookie.html</link>
      <guid>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-Session%E4%B8%8ECookie.html</guid>
      <pubDate>Wed, 28 Jun 2017 02:21:42 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-Session%E4%B8%8ECookie.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaWeb基础-JDBC</title>
      <link>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-JDBC.html</link>
      <guid>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-JDBC.html</guid>
      <pubDate>Wed, 28 Jun 2017 02:18:41 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-JDBC.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaWeb基础-servlet</title>
      <link>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-servlet.html</link>
      <guid>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-servlet.html</guid>
      <pubDate>Wed, 28 Jun 2017 02:16:56 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://liuhang.net.cn/JavaWeb%E5%9F%BA%E7%A1%80-servlet.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java基础增强-Lambda 表达式</title>
      <link>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</link>
      <guid>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</guid>
      <pubDate>Tue, 27 Jun 2017 07:29:06 GMT</pubDate>
      <description>
      
        Java8 Lambda 表达式，函数式编程
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="external">深入浅出 Java 8 Lambda 表达式</a></li>
</ol>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="语法糖的概念"><a href="#语法糖的概念" class="headerlink" title="语法糖的概念"></a>语法糖的概念</h2><ul>
<li>指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础算法-迪杰斯特拉算法</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html</guid>
      <pubDate>Wed, 21 Jun 2017 12:27:15 GMT</pubDate>
      <description>
      
        Dijkstra算法，Dijkstra算法堆优化（队列）,未详细总结，给出参考的博文。
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Dijkstra算法详细介绍"><a href="#Dijkstra算法详细介绍" class="headerlink" title="Dijkstra算法详细介绍"></a>Dijkstra算法详细介绍</h1><ol>
<li>参考：<a href="http://www.it165.net/pro/html/201407/16957.html" target="_blank" rel="external">图算法单源最短路径Dijkstra算法</a></li>
</ol>
<h1 id="Dijkstra算法优化"><a href="#Dijkstra算法优化" class="headerlink" title="Dijkstra算法优化"></a>Dijkstra算法优化</h1><ol>
<li>参考：<a href="http://blog.leanote.com/post/coolboy/duiyouhu" target="_blank" rel="external">带堆优化的Dijkstra</a></li>
</ol>
<h1 id="Dijkstra实现（java）"><a href="#Dijkstra实现（java）" class="headerlink" title="Dijkstra实现（java）"></a>Dijkstra实现（java）</h1><ol>
<li><a href="https://github.com/husthang/zte2017/blob/master/tsp/code/src/main/java/route/Dijkstra.java" target="_blank" rel="external">我的实现|java|邻接表</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>2017中兴捧月杯-初赛总结</title>
      <link>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%88%9D%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%88%9D%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Mon, 19 Jun 2017 08:56:24 GMT</pubDate>
      <description>
      
        2017中兴捧月杯,初赛总结，迪杰斯特拉派
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="赛题描述"><a href="#赛题描述" class="headerlink" title="赛题描述"></a>赛题描述</h1><ol>
<li>赛题链接：<a href="http://challenge.zte.net/index.php" target="_blank" rel="external">迪杰斯特拉派赛题</a></li>
<li>赛题抽象，给定一个无向图G，已知起点s、终点e、必经点集R、必经边集B、禁忌边集F和访问节点数限制k，要求寻找一条从起点s到终点e的最短路径，同时满足以下几个限制条件：（1）不能经过禁忌边集F中的任意边（2）必须经过必经点R集中的所有顶点（3）必须经过必经边集B中的所有边（4）路径访问的节点数量不超过k。</li>
<li>赛题说明文档</li>
</ol>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><a href="http://liuhang.net.cn/paper.pdf">paper|版权归中兴公司所有</a></li>
<li><a href="https://github.com/husthang/zte2017" target="_blank" rel="external">代码|版权归中兴公司所有</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%88%9D%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>2017中兴捧月杯-决赛总结</title>
      <link>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%86%B3%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%86%B3%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Mon, 19 Jun 2017 08:55:53 GMT</pubDate>
      <description>
      
        vector bin packing,向量装箱问题,二维向量装箱问题分支定界法,2017中兴捧月杯决赛，网络优化问题，线性规划
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="向量装箱问题"><a href="#向量装箱问题" class="headerlink" title="向量装箱问题"></a>向量装箱问题</h1><h2 id="装箱问题介绍"><a href="#装箱问题介绍" class="headerlink" title="装箱问题介绍"></a>装箱问题介绍</h2><ol>
<li><a href="https://people.math.gatech.edu/~tetali/PUBLIS/CKPT.pdf" target="_blank" rel="external">对装箱问题的详细介绍|Multidimensional Bin Packing and Other Related Problems: A Survey ∗</a></li>
<li><a href="http://www.or.deis.unibo.it/knapsack.html" target="_blank" rel="external">背包问题及装箱问题|各种算法及详细介绍</a></li>
<li><a href="http://vpsolver.dcc.fc.up.pt/" target="_blank" rel="external">向量装箱问题求解器</a>，这个是针对多维向量装箱问题的求解器，功能非常强大。</li>
</ol>
<h2 id="二维向量装箱问题"><a href="#二维向量装箱问题" class="headerlink" title="二维向量装箱问题"></a>二维向量装箱问题</h2><ol>
<li>参考一：A BRANCH-AND-BOUND ALGORITHM FOR THE TWO-DIMENSIONAL VECTOR PACKING PROBLEM</li>
<li>参考二：<a href="http://www.or.deis.unibo.it/kp/Chapter8.pdf" target="_blank" rel="external">Knapsack Problems|Chapter8,bin packing problems</a></li>
<li><a href="https://github.com/husthang/zte2017" target="_blank" rel="external">二维向量装箱问题代码|包含基本的FFD|包含分支定界精确求解方法</a></li>
</ol>
<h1 id="网络优化问题"><a href="#网络优化问题" class="headerlink" title="网络优化问题"></a>网络优化问题</h1>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/2017%E4%B8%AD%E5%85%B4%E6%8D%A7%E6%9C%88%E6%9D%AF-%E5%86%B3%E8%B5%9B%E8%B5%9B%E9%A2%98%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础算法-贪心法</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E6%B3%95.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E6%B3%95.html</guid>
      <pubDate>Mon, 05 Jun 2017 02:10:30 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;贪心思想概念&quot;&gt;&lt;a href=&quot;#贪心思想概念&quot; class=&quot;headerlink&quot; title=&quot;贪心思想概念&quot;&gt;&lt;/a&gt;贪心思想概念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="贪心思想概念"><a href="#贪心思想概念" class="headerlink" title="贪心思想概念"></a>贪心思想概念</h1><ol>
<li>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</li>
</ol>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="../images/贪心法.png" alt=""></p>
<ol>
<li>落单的数<ul>
<li><a href="http://www.lintcode.com/zh-cn/problem/single-number/" target="_blank" rel="external">落单的数</a></li>
<li>思路：按位或运算</li>
</ul>
</li>
<li>主元素</li>
<li><p>加油站</p>
<ul>
<li><a href="http://www.lintcode.com/zh-cn/problem/gas-station/#" target="_blank" rel="external">加油站</a></li>
<li>思路： 只要汽油量大于等于总的消耗，那么肯定有解。排除汽油量小于消耗量的点即可。</li>
</ul>
</li>
<li><p>下一个排列（难）</p>
<ul>
<li><a href="http://www.lintcode.com/zh-cn/problem/next-permutation/#" target="_blank" rel="external">下一个排列|lintcode</a></li>
<li><p>思路： 从后往前，先找到按字典排序，将要交换位置的点；再找该位置下一个排列应该是什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextPermutation(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> len = nums.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;<span class="number">0</span>; i--)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>])&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len-<span class="number">1</span>; j&gt;=i;j--)&#123;</div><div class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i-<span class="number">1</span>])&#123;</div><div class="line">                    <span class="keyword">int</span> temp = nums[j];</div><div class="line">                    nums[j] = nums[i-<span class="number">1</span>];</div><div class="line">                    nums[i-<span class="number">1</span>]=temp;</div><div class="line">                    Arrays.sort(nums,i,len);</div><div class="line">                    <span class="keyword">return</span> nums;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">     Arrays.sort(nums);</div><div class="line">     <span class="keyword">return</span> nums;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E6%B3%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础算法-数学和位操作</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E5%92%8C%E4%BD%8D%E6%93%8D%E4%BD%9C.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E5%92%8C%E4%BD%8D%E6%93%8D%E4%BD%9C.html</guid>
      <pubDate>Wed, 31 May 2017 08:18:45 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;最大公约数-最小公倍数&quot;&gt;&lt;a href=&quot;#最大公约数-最小公倍数&quot; class=&quot;headerlink&quot; title=&quot;最大公约数/最小公倍数&quot;&gt;&lt;/a&gt;最大公约数/最小公倍数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最大公约数:greatest common diviso
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="最大公约数-最小公倍数"><a href="#最大公约数-最小公倍数" class="headerlink" title="最大公约数/最小公倍数"></a>最大公约数/最小公倍数</h2><ul>
<li>最大公约数:greatest common divisor</li>
<li>欧几里得法(辗转相除法):设<code>a&gt;b</code>,<code>a=b*p+q</code>,b与q的最大公约也就是a与b的最大公约数,直到q为0,直接返回;</li>
<li>最小公倍数:lowest common multiple; <code>lcm(a,b)*gcd(a,b)=a*b</code>;</li>
<li>求两个数或n个数的最小公倍数或最大公约数:<br><img src="../images/gcd.png" alt=""></li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><ul>
<li>素数: 只有1和本身两个约数;判断是否为素数,只需要对前根号n个数进行判断<br><img src="../images/prime.png" alt=""></li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位操作有按位与、或、非、左移n位和右移n位等操作。</p>
<ol>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1): 可以把最右边的一个1变成0;</li>
<li>常见位操作：获取，设置，清除及更新位操作<br><img src="../images/位-获取.png" alt=""><br><img src="../images/位-更新.png" alt=""><br><img src="../images/位-清零.png" alt=""></li>
</ol>
<h3 id="二进制中的1的个数"><a href="#二进制中的1的个数" class="headerlink" title="二进制中的1的个数"></a>二进制中的1的个数</h3><ul>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1)</li>
</ul>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><ul>
<li>卡特兰数递推关系:<img src="../images/卡特兰.png" alt=""></li>
<li>卡特兰数通项式:<img src="../images/catalan.png" alt=""><img src="../images/catalan1.png" alt=""></li>
<li>前几项为1，1，2，5，14，42…</li>
<li>应用:<ul>
<li>栈的出栈序列:1到n的序列,依次进栈,有多少种不同的出栈序列；根据乘法原理和加法原理，设最后一个出栈的元素为k，则该情况为f(k-1)f(n-k)，所以递推关系满足；<code>f(n) = f(n-1)f(0) + f(n-2)f(1) + f(n-3)f(2) + ... + f(1)f(n-2) + f(0)f(n-1)</code></li>
<li>不同的二叉查找树： <a href="http://www.lintcode.com/zh-cn/problem/unique-binary-search-trees/" target="_blank" rel="external">lintcode|不同二叉查找树</a>；<code>f(n) = f(n-1)f(0) + f(n-2)f(1) + f(n-3)f(2) + ... + f(1)f(n-2) + f(0)f(n-1)</code></li>
</ul>
</li>
</ul>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><h2 id="全排列和全组合"><a href="#全排列和全组合" class="headerlink" title="全排列和全组合"></a>全排列和全组合</h2><ul>
<li>思路: 从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理；</li>
<li>参考:<a href="https://segmentfault.com/a/1190000002710424" target="_blank" rel="external">全排列/全组合</a></li>
</ul>
<h2 id="lintCode阶梯训练"><a href="#lintCode阶梯训练" class="headerlink" title="lintCode阶梯训练"></a>lintCode阶梯训练</h2><ul>
<li><a href="http://www.lintcode.com/zh-cn/ladder/" target="_blank" rel="external">lintcode阶梯训练|数学与二进制运算</a></li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E5%92%8C%E4%BD%8D%E6%93%8D%E4%BD%9C.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>操作系统总结</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Wed, 24 May 2017 08:38:07 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;操作系统概念&quot;&gt;&lt;a href=&quot;#操作系统概念&quot; class=&quot;headerlink&quot; title=&quot;操作系统概念&quot;&gt;&lt;/a&gt;操作系统概念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;基本概念：管理计算机硬件和软件资源，方便用户使用计算机的程序集合；&lt;/li&gt;
&lt;li&gt;操作系统提
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><ol>
<li>基本概念：管理计算机硬件和软件资源，方便用户使用计算机的程序集合；</li>
<li>操作系统提供的服务和功能：<ul>
<li>提供用户的<ul>
<li>用户界面</li>
<li>程序执行</li>
<li>I/O操作</li>
<li>文件系统操作</li>
<li>通信</li>
<li>错误检测</li>
</ul>
</li>
</ul>
</li>
<li>计算机系统<br><img src="../images/计算机要素.png" alt=""></li>
</ol>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><ol>
<li>进程的概念： 进程是具有一定独立功能的程序关于某个数据集合的一次运行活动。进程是程序的执行，动态概念，一次运行过程，有生命过程。</li>
<li>进程控制块（process control block, PCB）:记录进程的属性信息，进程标识信息，处理器状态信息，进程控制信息</li>
<li>进程间通信的两种基本模式： 1）共享内存， 2）消息传递<br><img src="../images/进程通信模型.png" alt="进程通信模型"></li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ol>
<li>多处理器系统带来的物理并行称为<strong>并行性</strong>，用编程技术达到的虚拟并行性，称为并发性</li>
<li>线程是CPU调度的基本单元，由线程ID,程序计数器，寄存器集合，栈组成。</li>
</ol>
<h1 id="互斥和同步"><a href="#互斥和同步" class="headerlink" title="互斥和同步"></a>互斥和同步</h1><ol>
<li>互斥（对资源的独用），同步（进程/线程之间的通信）</li>
<li>生产者和消费者问题：有限缓冲问题，用于多线程同步；多生产者消费者算法：用二元信号量保证互斥<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">semaphore mutex = 1;//二元信号量</div><div class="line">semaphore fillCount = 0;// 满缓存信号量</div><div class="line">semaphore emptyCount = BUFFER_SIZE;//空缓存信号量</div><div class="line"></div><div class="line"></div><div class="line">procedure producer() &#123;</div><div class="line">    while (true) &#123;</div><div class="line">        item = produceItem();//生产者生产数据</div><div class="line">        down(emptyCount);</div><div class="line">            down(mutex);//互斥，申请使用权</div><div class="line">                putItemIntoBuffer(item);//将数据放入缓存区</div><div class="line">            up(mutex);//释放使用权</div><div class="line">        up(fillCount);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">procedure consumer() &#123;</div><div class="line">    while (true) &#123;</div><div class="line">        down(fillCount);</div><div class="line">            down(mutex);</div><div class="line">                item = removeItemFromBuffer();//从缓存区中读取数据</div><div class="line">            up(mutex);</div><div class="line">        up(emptyCount);</div><div class="line">        consumeItem(item);//消费者使用数据</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="external">参考</a></li>
</ul>
<h1 id="进程调用"><a href="#进程调用" class="headerlink" title="进程调用"></a>进程调用</h1><h1 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h1><ol>
<li>先进先出调度算法（不可抢占）：按进入顺序执行</li>
<li>最短进程优先调度（事先知道要运行的时间）<ul>
<li>非抢占式</li>
<li>抢占式（最短剩余时间优先调度）</li>
</ul>
</li>
<li>时间片轮转法：每个进程轮流使用一段时间</li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul>
<li>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进</li>
</ul>
<ol>
<li><p>产生死锁的原因 </p>
<ul>
<li><strong>竞争资源引起死锁</strong><ul>
<li>在多道程序系统，多个进程共享系统的资源。系统资源分为二类:<br>一类是不可抢占的资源，如打印机、磁带机等。当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自动释放。<br>另一类是可抢占的资源，如CPU、内存等。由于系统拥有的不可抢占的资源有限，多个进程共享竞争不可抢占的资源就可能引起死锁。</li>
</ul>
</li>
<li><strong>进程推进顺序不当引起死锁</strong><ul>
<li>在多道程序系统中，并发执行的进程推进序列不可予测，有些推进顺序，进程可以顺利完成，这些推进顺序是合法的；而有的推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成了死锁。</li>
</ul>
</li>
</ul>
</li>
<li><p>产生死锁的必要条件</p>
<ul>
<li>互斥（ Mutual exclusion ）条件：一个资源一次只能被一个进程所使用，即是排它性使用。</li>
<li>不可抢占（ No preemption ）条件：一个资源仅能被占有它的进程所释放，而不能被别的进程强占。</li>
<li>请求和保持（ Hold-and-wait ）条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放。</li>
<li>环路等待（ Circular wait ）条件：当每类资源只有一个时，在发生死锁时，必然存在一个进程-资源的环形链。如一系统状态的资源分配图所示，P1正在等待一个P2 占用的资源R2，P2正在等待一个P1占用的资源R1。</li>
</ul>
</li>
<li><p>死锁的预防</p>
<ul>
<li><strong>预防死锁的方法是破坏四个产生死锁的必要条件之一</strong>。</li>
</ul>
<ol>
<li>破坏互斥条件: 互斥使用是资源本身特征所决定的。使用硬软件结合可改变资源本身特性，例如采用SPOOLing技术可将“独享” 打印机改变为“共享”的打印机。</li>
<li>破坏不可抢占条件:如果一个进程的申请没有实现，它要释放所有占有的资源</li>
<li>破坏请求和保持条件（也叫部分分配条件）: 采用<strong>资源预先静态分配法</strong>，运行前，一次性分配所需要的全部资源</li>
<li>破坏循环等待条件： <strong>有序资源使用法</strong>，对资源编号，进程只能按照编号递增的顺序申请资源。</li>
</ol>
</li>
<li><p>死锁的避免</p>
<ol>
<li>概念： 死锁的预防是严格破坏四个必要条件之一，死锁避免是方法允许进程动态地申请资源，系统在进行资源分配之前，先计算资源分配的安全性。若安全，则分配。避免死锁：确保系统永远不会进入死锁状态</li>
<li><strong>银行家算法</strong>避免死锁，不足：进程难以预先知道它的最大资源需求</li>
</ol>
</li>
<li><p>死锁的检测和恢复</p>
</li>
</ol>
<h1 id="主存储器管理"><a href="#主存储器管理" class="headerlink" title="主存储器管理"></a>主存储器管理</h1><ol>
<li>页式存储管理</li>
<li>段式存储管理</li>
<li>页的置换算法<ul>
<li>最佳置换算法</li>
<li>最佳未使用置换算法(NUR)</li>
<li>先进先出</li>
<li>最近最少使用置换算法（LRU）</li>
</ul>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://jpkc.scezju.com/czxtyl/redir.php?catalog_id=109249" target="_blank" rel="external">操作系统ppt</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算机网络总结</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Wed, 24 May 2017 07:32:11 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;h2 id=&quot;OSI七层模型与TCP-IP四层模型&quot;&gt;&lt;a href=&quot;#OSI七层模型与TCP-IP四层模型&quot; cla
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层模型与TCP-IP四层模型"><a href="#OSI七层模型与TCP-IP四层模型" class="headerlink" title="OSI七层模型与TCP/IP四层模型"></a>OSI七层模型与TCP/IP四层模型</h2><p><img src="../images/osi七层模型.gif" alt=""></p>
<ul>
<li>实际应用的tcp/ip四层: 连接层,网络层,传输层,应用层</li>
<li>各层的作用<ol>
<li>物理层：通过媒介传输比特,确定机械及电气规范</li>
<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ol>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="../images/ip.png" alt=""><br><img src="../images/ip1.png" alt=""></p>
<ul>
<li>A类地址,<ul>
<li>可指派的网络号126个(2^7-2),见2的原因是: 网络号全0为保留地址,表示本网络;网络号127(0111 1111)保留为回环测试(如127.0.0.1)</li>
<li>可指派的主机号: 2^24-2; 减去全0的主机号,减去全1主机号</li>
</ul>
</li>
<li>B类地址<ul>
<li>可指派网络号2^14-1:128.0不指派,最小可指派的网络号是128.1</li>
<li>主机号减2,2^16-2;</li>
</ul>
</li>
<li>C类地址<ul>
<li>可指派网络号2^21-1:192.0.0不指派,最小可指派的网络号192.0.1</li>
<li>主机号减2: 2^8-2;</li>
</ul>
</li>
</ul>
<h2 id="TCP-UDP协议"><a href="#TCP-UDP协议" class="headerlink" title="TCP/UDP协议"></a>TCP/UDP协议</h2><ul>
<li>运输层协议和网络层协议的主要区别<br><img src="../images/运输层网络层.png" alt=""></li>
<li><p>运输层的协议端口号</p>
<ul>
<li>协议端口号(protocol port number),简称端口;使不同的操作系统中的进程可以相互通信,用统一的方法对TCP/IP体系中的应用进程进行标识;16位的端口号(65535个)</li>
<li>通信的终点是应用进程,但我们只需把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成</li>
</ul>
</li>
<li><p>tcp字段含义<br><img src="../images/tcp字段.png" alt=""></p>
</li>
<li><p>传输层定义两种传输协议：TCP（传输控制协议）和 UDP（或用户数据报协议）<br><img src="../images/tcp-udp.png" alt=""></p>
</li>
<li>TCP协议和UDP协议特性区别总结：<ol>
<li>TCP协议在传送数据段的时候要给段标号；UDP协议不</li>
<li>TCP协议可靠；UDP协议不可靠</li>
<li>TCP协议是面向连接；UDP协议采用无连接</li>
<li>TCP协议负载较高，采用虚电路；UDP采用无连接</li>
<li>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</li>
<li>TCP协议采用窗口技术和流控制</li>
</ol>
</li>
</ul>
<h2 id="TCP三次握手与四次分手"><a href="#TCP三次握手与四次分手" class="headerlink" title="TCP三次握手与四次分手"></a>TCP三次握手与四次分手</h2><p><img src="../images/tcp.jpg" alt=""></p>
<ol>
<li>三次握手和四次分手的过程</li>
<li>为什么要三次握手和四次分手</li>
<li>参考:<a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>http状态码<br><img src="../images/http状态码.png" alt=""><ul>
<li>404  未找到，服务器找不到所请求的网页。</li>
<li>302  临时移动，服务器从不同位置的网页响应请求，请求者应继续使用原有位置进行以后的请求。</li>
<li>500  （服务器内部错误），服务器遇到错误，无法完成请求。</li>
<li>403  （禁止）服务器拒绝请求</li>
</ul>
</li>
<li>http与https区别<ul>
<li>http协议</li>
<li>简单理解: https是安全版的http,</li>
<li>HTTP的端口号是80，https的端口号是443</li>
</ul>
</li>
</ul>
<h2 id="SNMP简单网络管理协议"><a href="#SNMP简单网络管理协议" class="headerlink" title="SNMP简单网络管理协议"></a>SNMP简单网络管理协议</h2><ul>
<li>simple network management protocol 简单网络管理协议</li>
<li>是一个网络管理员用来管理的工具相当于  一个app 所以是<strong>应用层</strong></li>
</ul>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul>
<li>Internet Control Message Protocol 互联网控制消息协议</li>
<li>网络层协议</li>
<li>用ping命令,检查一台主机的网络层是否连通;</li>
</ul>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ul>
<li>IEEE 802.3—CSMA/CD网络，定义CSMA/CD总线网的MAC子层和物理层的规范,人们习惯将<strong>IEEE 802.3称为”以太网</strong>;</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础数据结构-字符串和数组</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84.html</guid>
      <pubDate>Tue, 23 May 2017 14:12:47 GMT</pubDate>
      <description>
      
        字符串总结，字符串相关面试题总结
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>重难点是: <strong>模式匹配(kmp算法)</strong>和<strong>正则表达式匹配</strong>; 在选择题中,可能会出现问next数组的题目</p>
<h2 id="Java字符串API"><a href="#Java字符串API" class="headerlink" title="Java字符串API"></a>Java字符串API</h2><ul>
<li>toCharArray();</li>
<li><strong>StringBuilder</strong>常用,线程不安全,效率高; StringBuffer  线程安全,效率低;</li>
<li>matches()字符串是否匹配给定的正则表达式。</li>
<li>indexOf()返回指定子字符串在此字符串中第一次出现处的索引。(模式匹配api)</li>
<li>trim()返回字符串的副本，忽略前导空白和尾部空白。</li>
<li>valueOf()返回…字符串形式</li>
<li>split()按给定的正则表达式拆分字符串</li>
<li>replace/replaceAll/replaceFirst 替换字符串</li>
<li>reverse() 逆序</li>
</ul>
<h2 id="String对象经典问题"><a href="#String对象经典问题" class="headerlink" title="String对象经典问题"></a>String对象经典问题</h2><ul>
<li><a href="http://sarin.iteye.com/blog/603684" target="_blank" rel="external">参考</a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"abc"</span>;</div><div class="line">String str1 = <span class="string">"abc"</span>;</div><div class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</div><div class="line">System.out.println(str == str1);<span class="comment">//true</span></div><div class="line">System.out.println(str1 == <span class="string">"abc"</span>);<span class="comment">//true</span></div><div class="line">System.out.println(str2 == <span class="string">"abc"</span>);<span class="comment">//false</span></div><div class="line">System.out.println(str1 == str2);<span class="comment">//fasle</span></div><div class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></div><div class="line">System.out.println(str1 == str2.intern());<span class="comment">//true</span></div><div class="line">System.out.println(str2 == str2.intern());<span class="comment">//false</span></div><div class="line">System.out.println(str1.hashCode() == str2.hashCode());<span class="comment">//true equals相同,hashcode必然相同</span></div><div class="line">System.out.println(str + <span class="string">"d"</span> == str1 + <span class="string">"d"</span>);<span class="comment">//false 用+连接是在堆内存上进行, 得到两个新对象</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul>
<li>定义:s和t为给定的两个字符串,在主串s中查找子串t的过程称为模式匹配,返回t在s中第一次出现的位置</li>
<li>OJ题目:<a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">LeetCode|字符串匹配,子串第一次出现的位置</a></li>
<li>三种方法:<ol>
<li>java api: indexOf;</li>
<li>暴力搜</li>
<li>KMP算法</li>
</ol>
</li>
<li>kmp算法选择题:next数组<ul>
<li><a href="https://www.nowcoder.com/questionTerminal/57bdf294407c4477969fc7b4d56c7be7" target="_blank" rel="external">next数组</a></li>
</ul>
</li>
<li>求next数组的方法（递归法）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String source, String pattern)</span></span>&#123;</div><div class="line">       <span class="keyword">char</span>[] src = source.toCharArray();</div><div class="line">       <span class="keyword">char</span>[] pat = pattern.toCharArray();</div><div class="line">       <span class="keyword">int</span>[] next = getNext(pat);</div><div class="line">       <span class="keyword">int</span> sLen = src.length;</div><div class="line">       <span class="keyword">int</span> pLen = pat.length;</div><div class="line">       <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</div><div class="line">           <span class="keyword">if</span>(j== -<span class="number">1</span> || src[i] == pat[j])&#123;</div><div class="line">               i++;</div><div class="line">               j++;</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               j = next[j];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span>(j == pLen)&#123;</div><div class="line">           <span class="keyword">return</span> i - pLen;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] p)&#123;</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 求next数组的方法</div><div class="line">        * 已知next[j]=k,求next[j+1];</div><div class="line">        * 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1;</div><div class="line">        * 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1,</div><div class="line">        *    如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止</div><div class="line">        */</div><div class="line">       <span class="keyword">int</span> pLen = p.length;</div><div class="line">       <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</div><div class="line">       next[<span class="number">0</span>] = -<span class="number">1</span>;</div><div class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> k = -<span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span>(j &lt; pLen-<span class="number">1</span>)&#123;</div><div class="line">           <span class="keyword">if</span>(k == -<span class="number">1</span> || p[k] == p[j])&#123;</div><div class="line">               j++;</div><div class="line">               k++;</div><div class="line">               next[j] = k;</div><div class="line">           &#125;<span class="keyword">else</span> &#123;</div><div class="line">               k = next[k];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><ul>
<li>OJ题目:剑指offer第52题,Solution52;</li>
<li><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer|正则表达式匹配</a> ;<a href="https://leetcode.com/problems/regular-expression-matching/#/description" target="_blank" rel="external">LeetCode|正则表达式匹配</a></li>
<li>解题思路<ul>
<li>字符串 正则表达式匹配<ol>
<li>模式中,当前字符的下一个字符不是<code>*</code><ul>
<li>如果当前字符匹配,则字符串和模式串都下移一位</li>
<li>如果当前字符不匹配,则直接返回false</li>
</ul>
</li>
<li>模式中,当前字符的下一个字符是<code>*</code><ul>
<li>如果当前字符不匹配,则<code>*</code>匹配0个前位字符,模式串后移两位(前位字符,<code>*</code>前面的那个字符)</li>
<li>如果当前字符匹配,分两组<ul>
<li><code>*</code>匹配0个前位字符,模式串后移两位</li>
<li><code>*</code>匹配一个或者多个前位字符,字符串后移以为,模式串不变</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="字符串平移-String-shift"><a href="#字符串平移-String-shift" class="headerlink" title="字符串平移(String shift)"></a>字符串平移(String shift)</h2><ul>
<li>题目描述<ul>
<li>我们规定对一个字符串的shift操作如下： shift(“ABCD”, 0) = “ABCD” shift(“ABCD”, 1) = “BCDA” shift(“ABCD”, 2) = “CDAB” 换言之, 我们把最左侧的N个字符剪切下来, 按序附加到了右侧。给定一个长度为n的字符串，我们规定最多可以进行n次向左的循环shift操作。如果shift(string, x) = string (0＜= x ＜n), 我们称其为一次匹配(match)。求在shift过程中出现匹配的次数。</li>
</ul>
</li>
<li>解决： 字符串必为周期字符串，计算出最短周期（用kmp算法中的next数组计算）</li>
</ul>
<h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-substring/" target="_blank" rel="external">最长公共子串</a></li>
<li>思路: 暴力法和<strong>动态规划法</strong>.</li>
</ol>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-subsequence/" target="_blank" rel="external">最长公共子序列</a></li>
<li><p>解决： 用动态规划的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lenA+<span class="number">1</span>][lenB+<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++)&#123;</div><div class="line">                dp[i][j] = (A.charAt(i-<span class="number">1</span>) == B.charAt(j-<span class="number">1</span>))?dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>:Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[lenA][lenB];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>应用（变形），求一个字符串删除几个字符可以变成最长的回文字符串，求原字符串与逆串的最长公共子序列。</p>
</li>
</ol>
<h2 id="字符串与整数-数组的互相转换"><a href="#字符串与整数-数组的互相转换" class="headerlink" title="字符串与整数,数组的互相转换"></a>字符串与整数,数组的互相转换</h2><p>1.</p>
<h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><ul>
<li>StringBuilder.reverse方法;</li>
<li><a href="https://leetcode.com/problems/reverse-words-in-a-string/#/description" target="_blank" rel="external">leetcode|字符串反转</a></li>
</ul>
<h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/adc291e7e79f452c8b59243a5ce68d3a?orderByHotValue=1&amp;page=1&amp;onlyReference=false" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/adc291e7e79f452c8b59243a5ce68d3a?orderByHotValue=1&amp;page=1&amp;onlyReference=false</a><br>来源：牛客网</p>
<p>n = int(raw_input())<br>nums = map(int, raw_input().split())<br>index = sorted(range(len(nums)), key = lambda i: nums[i])<br>count = 1<br>for i in range(1, len(index)):<br>    if index[i] &gt; index[i-1]:<br>        count += 1<br>    else:<br>        break<br>print len(index) - count</p>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础数据结构-字典树</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91.html</guid>
      <pubDate>Wed, 17 May 2017 13:16:50 GMT</pubDate>
      <description>
      
        tire,前缀树，字典树
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="external">trie|字典树</a></li>
</ol>
<h1 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h1><ol>
<li>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。（来自今日头条笔试题）</li>
<li>解答<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by liuhang on 2017/5/17.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> n = in.nextInt();</div><div class="line">        <span class="keyword">int</span> m = in.nextInt();</div><div class="line">        TrieNode root = <span class="keyword">new</span> TrieNode(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            array[i] = in.nextInt();</div><div class="line">            insert(root, array[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</div><div class="line">            result += query(root, i, m);</div><div class="line">        &#125;</div><div class="line">        System.out.println(result / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据二进制位，构建字典数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode trieNode, <span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">        TrieNode pre = trieNode;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> digit = (number &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (pre.next[digit] == <span class="keyword">null</span>) &#123;</div><div class="line">                pre.next[digit] = <span class="keyword">new</span> TrieNode(digit);</div><div class="line">            &#125;</div><div class="line">            pre = pre.next[digit];</div><div class="line">            pre.count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(TrieNode root, <span class="keyword">int</span> a, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        TrieNode pre = root;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (mDigit == <span class="number">1</span>) &#123;</div><div class="line">                pre = pre.next[aDigit ^ <span class="number">1</span>];<span class="comment">//此处技巧！ 与aDigit不同 aDigit ^ 1;</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (pre.next[aDigit ^ <span class="number">1</span>] != <span class="keyword">null</span>) &#123;</div><div class="line">                    result += pre.next[aDigit ^ <span class="number">1</span>].count;</div><div class="line">                &#125;</div><div class="line">                pre = pre.next[aDigit];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span>) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    TrieNode[] next = <span class="keyword">new</span> TrieNode[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.digit = digit;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>参考<a href="http://youjq.cn/2017/04/09/2017jin-ri-tou-tiao-bi-shi-ti-yi-huo/" target="_blank" rel="external">2017今日头条笔试题：异或</a></li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL/数据库总结</title>
      <link>http://liuhang.net.cn/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Wed, 17 May 2017 07:42:17 GMT</pubDate>
      <description>
      
        mysql必知必会一书
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="MySQL必知必会笔记"><a href="#MySQL必知必会笔记" class="headerlink" title="MySQL必知必会笔记"></a>MySQL必知必会笔记</h1><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><ul>
<li>理解笛卡尔乘积</li>
</ul>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul>
<li>提供对select语句的一层封装</li>
</ul>
<h1 id="经典题目练习"><a href="#经典题目练习" class="headerlink" title="经典题目练习"></a>经典题目练习</h1><h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h2><ol>
<li><a href="https://leetcode.com/problems/duplicate-emails/#/description" target="_blank" rel="external">找出重复的记录|leetcode|重点</a></li>
<li><a href="https://leetcode.com/problems/combine-two-tables/#/description" target="_blank" rel="external">两个表联结查询|leetcode</a></li>
<li><a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/#/description" target="_blank" rel="external">表自联结|leetcode</a></li>
<li><a href="https://leetcode.com/problems/customers-who-never-order/#/description" target="_blank" rel="external">leetcode练习1</a></li>
<li><a href="https://leetcode.com/problems/rising-temperature/#/description" target="_blank" rel="external">leetcode练习2</a></li>
<li><a href="https://leetcode.com/problems/delete-duplicate-emails/#/description" target="_blank" rel="external">删除重复记录，只保留一个）|leetcode|重点</a></li>
<li><a href="https://leetcode.com/problems/second-highest-salary/#/description" target="_blank" rel="external">选择排名第二大的|limit使用|leetcode|重点</a></li>
<li><a href="https://leetcode.com/problems/big-countries/#/description" target="_blank" rel="external">单间检索数据|leetcode</a></li>
</ol>
<h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><ol>
<li><a href="https://leetcode.com/problems/rank-scores/#/description" target="_blank" rel="external">对分数进行排名，并显示名次|leetcode|难</a></li>
<li><a href="https://leetcode.com/problems/consecutive-numbers/#/description" target="_blank" rel="external">选址连续出现的|leetcode</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基础算法-日历计算</title>
      <link>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%97%A5%E5%8E%86%E8%AE%A1%E7%AE%97.html</link>
      <guid>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%97%A5%E5%8E%86%E8%AE%A1%E7%AE%97.html</guid>
      <pubDate>Wed, 17 May 2017 04:38:02 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;公历计算&quot;&gt;&lt;a href=&quot;#公历计算&quot; class=&quot;headerlink&quot; title=&quot;公历计算&quot;&gt;&lt;/a&gt;公历计算&lt;/h1&gt;&lt;h2 id=&quot;使用java类库GregorianCalendar&quot;&gt;&lt;a href=&quot;#使用java类库GregorianCal
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="公历计算"><a href="#公历计算" class="headerlink" title="公历计算"></a>公历计算</h1><h2 id="使用java类库GregorianCalendar"><a href="#使用java类库GregorianCalendar" class="headerlink" title="使用java类库GregorianCalendar"></a>使用java类库GregorianCalendar</h2><h2 id="不使用java类库"><a href="#不使用java类库" class="headerlink" title="不使用java类库"></a>不使用java类库</h2><ol>
<li>参考:<a href="https://github.com/hotoo/nong/wiki/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%81%E4%B8%83%EF%BC%9A%E6%97%A5%E5%8E%86%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95-%E4%B8%AD%E5%9B%BD%E5%85%AC%E5%8E%86%EF%BC%88%E6%A0%BC%E9%87%8C%E5%8E%86%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89" target="_blank" rel="external">日历生成算法</a></li>
<li>公元元年（1年）1.1号星期一，据此计算y年<ul>
<li><code>w=(L*366+N*365+D)%7</code>,前y-1年闰年和平年的年数,D为y年的第几天</li>
<li><code>w=(365(y-1)+L+D)%7</code>,<code>L=(y-1)/4-(y-1)/100+(y-1)/400</code></li>
<li>计算星期几的公式：<code>w=((y-1)+(y-1)/4-(y-1)/100+(y-1)/400+D)%7</code></li>
</ul>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.DateFormatSymbols;</div><div class="line"><span class="keyword">import</span> java.util.Calendar;</div><div class="line"><span class="keyword">import</span> java.util.Locale;</div><div class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 打印指定月份的日历</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//        printCalendar(2017, 5);</span></div><div class="line">        printCalendar1(<span class="number">2017</span>, <span class="number">6</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//使用java类库</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCalendar</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month)</span> </span>&#123;</div><div class="line">        GregorianCalendar d = <span class="keyword">new</span> GregorianCalendar();</div><div class="line">        Locale.setDefault(Locale.US);</div><div class="line">        <span class="keyword">int</span> today = d.get(Calendar.DAY_OF_MONTH);</div><div class="line">        d.set(Calendar.YEAR, year);</div><div class="line">        d.set(Calendar.MONTH, month - <span class="number">1</span>);</div><div class="line">        d.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">int</span> weekday = d.get(Calendar.DAY_OF_WEEK);</div><div class="line">        <span class="keyword">int</span> firstDayOfWeek = d.getFirstDayOfWeek();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> indent = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (weekday != firstDayOfWeek) &#123;</div><div class="line">            indent++;</div><div class="line">            d.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</div><div class="line">            weekday = d.get(Calendar.DAY_OF_WEEK);</div><div class="line">        &#125;</div><div class="line">        String[] weekdaysName = <span class="keyword">new</span> DateFormatSymbols().getShortWeekdays();</div><div class="line">        do &#123;</div><div class="line">            System.out.printf(<span class="string">"%4s"</span>, weekdaysName[weekday]);</div><div class="line">            d.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">            weekday = d.get(Calendar.DAY_OF_WEEK);</div><div class="line">        &#125; <span class="keyword">while</span> (weekday != firstDayOfWeek);</div><div class="line">        System.out.println();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indent; i++) &#123;</div><div class="line">            System.out.print(<span class="string">"    "</span>);</div><div class="line">        &#125;</div><div class="line">        d.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">        <span class="keyword">while</span> (d.get(Calendar.MONTH) == month - <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> day = d.get(Calendar.DAY_OF_MONTH);</div><div class="line">            System.out.printf(<span class="string">"%3d"</span>, day);</div><div class="line">            <span class="keyword">if</span> (day == today) &#123;</div><div class="line">                System.out.print(<span class="string">"*"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.print(<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            d.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (d.get(Calendar.DAY_OF_WEEK) == firstDayOfWeek) &#123;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//不适用java类库</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCalendar1</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">" Sun Mon Tue Wed Thu Fri Sat "</span>);</div><div class="line">        <span class="keyword">int</span> today = <span class="number">16</span>;</div><div class="line">        <span class="keyword">int</span> weekday = day(year, month, <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weekday; i++) &#123;</div><div class="line">            System.out.print(<span class="string">"    "</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= month(year, month); i++) &#123;</div><div class="line">            System.out.printf(<span class="string">"%3d"</span>, i);</div><div class="line">            <span class="keyword">if</span> (i == today) &#123;</div><div class="line">                System.out.print(<span class="string">"*"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.print(<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (day(year, month, i) == <span class="number">6</span>) &#123;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//判断闰年</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">year</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> y % <span class="number">400</span> == <span class="number">0</span> || (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>);<span class="comment">//闰年规则，4的倍数，如果年份整百，必须为400的倍数</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//计算y年 m月有多少天</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">month</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (m == <span class="number">1</span> || m == <span class="number">3</span> || m == <span class="number">5</span> || m == <span class="number">7</span> || m == <span class="number">8</span> || m == <span class="number">10</span> || m == <span class="number">12</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">31</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">4</span> || m == <span class="number">6</span> || m == <span class="number">9</span> || m == <span class="number">11</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">30</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (year(y)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">29</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">28</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据公式，计算y年，m月 ，d日星期w  w = ([Y-1] + [(Y-1)/4] - [(Y-1)/100] + [(Y-1)/400] + D)mod 7</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">day</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</div><div class="line">            count = count + month(y, i);</div><div class="line">        &#125;</div><div class="line">        count = count + d;<span class="comment">//count 表示是y年的第几天</span></div><div class="line">        <span class="keyword">int</span> w = ((y - <span class="number">1</span>) + (y - <span class="number">1</span>) / <span class="number">4</span> - (y - <span class="number">1</span>) / <span class="number">100</span> + (y - <span class="number">1</span>) / <span class="number">400</span> + count) % <span class="number">7</span>;<span class="comment">//计算公式，公元元年1.1号星期1</span></div><div class="line">        <span class="keyword">return</span> w;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%97%A5%E5%8E%86%E8%AE%A1%E7%AE%97.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人计划至6月底</title>
      <link>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B36%E6%9C%88%E5%BA%95.html</link>
      <guid>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B36%E6%9C%88%E5%BA%95.html</guid>
      <pubDate>Mon, 15 May 2017 13:29:21 GMT</pubDate>
      <description>
      
        复习基础，巩固基础
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="本月总体"><a href="#本月总体" class="headerlink" title="本月总体"></a>本月总体</h1><ol>
<li>看书:mysql/shell两本书看完，python简明教程看完,shell书看完前四章<strong>基本完成</strong></li>
<li>看书:java高并发一书，java虚拟机一书看完（附带看完操作系统）</li>
<li>操作系统，计算机网络，数据库，linux shell复习完</li>
<li>编程练习，每日1-2题（只有周六除外）,《程序员面试经典》84个题刷(java和python，熟悉，练习语法)</li>
<li>每早8：30-9：30看一小时书</li>
<li>网络编程小项目： 聊天室/文件共享 python/java实现，练手（java做成网页版）</li>
<li>每周日一整天编程真题</li>
</ol>
<h2 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h2><ol>
<li>计算机网络</li>
<li>操作系统</li>
<li>mysql必知必会</li>
<li>linux shell脚本攻略</li>
<li>python简明教程</li>
<li>程序员面试金典</li>
<li>分布式Java应用-基础与实践/大型网站系统与Java中间件实践</li>
<li>Java高并发编程实战/深入理解Java虚拟机</li>
</ol>
<ul>
<li><strong><em>注意：1和2必须完成，并完成总结；7.8结合看，总结一波，巩固其中的基础</em></strong></li>
</ul>
<h1 id="完成python基础学习"><a href="#完成python基础学习" class="headerlink" title="完成python基础学习"></a>完成python基础学习</h1><ol>
<li>任务一：用python编写一个批量测试脚本（测试zte代码）</li>
<li>任务二：学习完简明python教程一书<strong>完成</strong></li>
<li>时间： 一周完成（5.15号-5.20号）</li>
</ol>
<h1 id="完成linux-shell学习"><a href="#完成linux-shell学习" class="headerlink" title="完成linux shell学习"></a>完成linux shell学习</h1><ol>
<li>任务一： 学习完linux shell 脚本攻略一书</li>
<li>任务二： 完成leetcode 上shell题目</li>
<li>时间：两周完成（5.21号-6.1号）</li>
</ol>
<h1 id="完成数据库学习"><a href="#完成数据库学习" class="headerlink" title="完成数据库学习"></a>完成数据库学习</h1><ol>
<li>任务一：学习完mysql必知必会一书<strong>mysql必知必会1-22章基本看完</strong></li>
<li>任务二：完成leetcode 上database题目,总计13题，并总结<strong>已总结10题</strong></li>
<li>时间： 一周完成（5.21-5.26号）</li>
<li>任务三：牛客网上mysql习题 50%完成(<strong>取消</strong>)</li>
</ol>
<h1 id="完成Java并发编程学习"><a href="#完成Java并发编程学习" class="headerlink" title="完成Java并发编程学习"></a>完成Java并发编程学习</h1><ol>
<li>任务一： 学习完java并发编程实战一书</li>
<li>任务二：深入理解java虚拟机一书</li>
</ol>
<h1 id="完成操作系统复习"><a href="#完成操作系统复习" class="headerlink" title="完成操作系统复习"></a>完成操作系统复习</h1><ol>
<li>操作系统概念，第七版一书</li>
</ol>
<h1 id="完成计算机网络复习"><a href="#完成计算机网络复习" class="headerlink" title="完成计算机网络复习"></a>完成计算机网络复习</h1><ol>
<li>计算机网络（谢版），一书 </li>
</ol>
<h1 id="日程记录"><a href="#日程记录" class="headerlink" title="日程记录"></a>日程记录</h1><h2 id="5-15-5-24（10天任务）"><a href="#5-15-5-24（10天任务）" class="headerlink" title="5.15-5.24（10天任务）"></a>5.15-5.24（10天任务）</h2><ul>
<li>总结<ol>
<li>完成数据库（mysql）基础学习</li>
<li>完成linux shell基础xuex</li>
<li>完成python基础学习</li>
<li>今日头条2017四个编程题完成</li>
</ol>
</li>
</ul>
<h3 id="5-15"><a href="#5-15" class="headerlink" title="5.15"></a>5.15</h3><ol>
<li>学习了python基础</li>
</ol>
<h3 id="5-16"><a href="#5-16" class="headerlink" title="5.16"></a>5.16</h3><ol>
<li>学习完python基础-<strong>完成</strong></li>
<li>完成批量测试代码-<strong>完成</strong></li>
<li>编程练习： 显示日历；<strong>完成</strong></li>
</ol>
<h3 id="5-17"><a href="#5-17" class="headerlink" title="5.17"></a>5.17</h3><ol>
<li>编程练习：2题;<strong>完成,今日头条真题2个</strong></li>
<li>简明python教程一书例题做完- 未完成</li>
<li>完善zte测试代码 - 未完成</li>
<li>看mysql必知必会1-8章<strong>完成,见mysql总结</strong>，刷了2个leetcode数据库题目</li>
</ol>
<h3 id="5-18"><a href="#5-18" class="headerlink" title="5.18"></a>5.18</h3><ol>
<li>实验室804项目报告<strong>完成</strong></li>
<li>编程练习：1题<strong>完成</strong></li>
<li>看书：mysql必知必会9-16章-未完成</li>
</ol>
<h3 id="5-19"><a href="#5-19" class="headerlink" title="5.19"></a>5.19</h3><ol>
<li>String kmp算法总结完毕，编程练习刷题1 未完成</li>
<li>看书：mysql必知必会9-16章<strong>完成,刷数据库题目3个</strong></li>
<li>看书：python简明教程看完；（刷题2）未完成</li>
</ol>
<h3 id="5-20"><a href="#5-20" class="headerlink" title="5.20"></a>5.20</h3><ol>
<li>看书： linux私房菜看完bash和shell script两章<strong>完成</strong></li>
<li>编程练习： 1题 <strong>字典序，重点看</strong></li>
</ol>
<h3 id="5-21"><a href="#5-21" class="headerlink" title="5.21"></a>5.21</h3><ol>
<li>看书: python简明教程后面内容看完<strong>延后</strong></li>
<li>编程练习：1题，今日头条的四题总结完，kmp算法总结完成<strong>未完成</strong></li>
<li>python编程练习，剑指offer题目练习（3）</li>
</ol>
<h3 id="5-22"><a href="#5-22" class="headerlink" title="5.22"></a>5.22</h3><ol>
<li>python简明教程后面看完<strong>完成</strong></li>
</ol>
<h3 id="5-23"><a href="#5-23" class="headerlink" title="5.23"></a>5.23</h3><ol>
<li>早上看书：mysql必知必会17-22章看完<strong>完成,并刷了三个leetcode数据库题目</strong></li>
<li>下午编码：编程题练习，2题<strong>修改，完成KMP算法总结</strong></li>
<li>晚上看书：看linxu shell脚本攻略<strong>完成，看完第一章，并编写一测试脚本</strong></li>
</ol>
<h3 id="5-24"><a href="#5-24" class="headerlink" title="5.24"></a>5.24</h3><ol>
<li>早上看书：linux shell脚本攻略第二章过完<strong>完成</strong></li>
<li>下午编码： 编程练习，2题，总结完字符串与整数部分（面试经典）</li>
<li>晚上看书：操作系统第一章过一遍<strong>完成</strong></li>
</ol>
<h2 id="5-25-6-04（10天任务）"><a href="#5-25-6-04（10天任务）" class="headerlink" title="5.25-6.04（10天任务）"></a>5.25-6.04（10天任务）</h2><ul>
<li>计划<ol>
<li>复习完操作系统，总结完成（操作系统概念一书）</li>
<li>复习完计算机网络，总结完成（计算机网络-谢仁希一书）</li>
<li>编程真题8道<a href="https://www.nowcoder.com/contestRoom?orderByHotValue=1&amp;filter=0&amp;mutiTagIds=672_139_138" target="_blank" rel="external">链接</a>；总共需要三小时做完；三小时总结；</li>
<li>每日一小题/周日4个真题 code!</li>
</ol>
</li>
<li>总结<ol>
<li>操作系统部分看完</li>
<li>编程练习完成</li>
<li>计算机网络总结未完成</li>
</ol>
</li>
</ul>
<h3 id="5-25"><a href="#5-25" class="headerlink" title="5.25"></a>5.25</h3><ol>
<li>早上看书：复习完操作系统（未完成）</li>
<li>当日1编程题,总结完字符串和数组（未完成）</li>
</ol>
<p>##￥ 5.29</p>
<ol>
<li>刷编程题，见计划链接（一整天做完，总结完），用java和Python两种搞完，熟悉Python语法。<strong>基本完成</strong></li>
</ol>
<h3 id="5-30"><a href="#5-30" class="headerlink" title="5.30"></a>5.30</h3><ol>
<li>空</li>
</ol>
<h3 id="6-1号"><a href="#6-1号" class="headerlink" title="6.1号"></a>6.1号</h3><ol>
<li>看书：《大型网站系统与Java中间件实践》</li>
</ol>
<h3 id="6-2号"><a href="#6-2号" class="headerlink" title="6.2号"></a>6.2号</h3><ol>
<li>复习操作系统<strong>看完cpu调度和死锁</strong></li>
</ol>
<h3 id="6-3号"><a href="#6-3号" class="headerlink" title="6.3号"></a>6.3号</h3><ol>
<li>复习计算机网络，完成总结（延后）</li>
<li>复习操作系统，看内存管理<strong>未完成</strong></li>
</ol>
<h2 id="6-5号-6-10号"><a href="#6-5号-6-10号" class="headerlink" title="6.5号-6.10号"></a>6.5号-6.10号</h2><h3 id="6-5号"><a href="#6-5号" class="headerlink" title="6.5号"></a>6.5号</h3><ol>
<li>早上：刷阶梯训练，看程序员面试金典（<strong>总结完数学及位运算</strong>）</li>
<li>下午：认真看书，总结。操作系统/内存管理章节</li>
<li>晚上：单车锻炼； 看Java深入部分与总结（分布式，中间件）</li>
</ol>
<h3 id="6-7-6-9号"><a href="#6-7-6-9号" class="headerlink" title="6.7-6.9号"></a>6.7-6.9号</h3><ol>
<li>学习装箱问题相关算法，并总结</li>
</ol>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B36%E6%9C%88%E5%BA%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java基础-java知识体系</title>
      <link>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html</link>
      <guid>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html</guid>
      <pubDate>Mon, 17 Apr 2017 13:22:18 GMT</pubDate>
      <description>
      
        java技能图谱,java知识体系
      
      </description>
      
      <content:encoded><![CDATA[<p>java技能图谱(来自牛客网)<br><img src="../images/Java技能图谱.png" alt=""></p>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试笔试编程题总结(数据结构和算法总结)</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Sun, 16 Apr 2017 13:25:41 GMT</pubDate>
      <description>
      
        剑指offer,LeetCode,牛客网等OJ刷题总结,各种基础数据结构和常见算法总结.
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><ol>
<li><a href="https://algorithm.yuanbin.me/zh-hans/index.html" target="_blank" rel="external">参考/数据结构与算法/leetcode/lintcode题解||:总结超详细,推荐!!</a></li>
<li>提交不通过时思考方向： 是否整型溢出！（int,long）</li>
</ol>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>重难点是: <strong>模式匹配(kmp算法)</strong>和<strong>正则表达式匹配</strong>; 在选择题中,可能会出现问next数组的题目</p>
<h2 id="Java字符串API"><a href="#Java字符串API" class="headerlink" title="Java字符串API"></a>Java字符串API</h2><ul>
<li><strong>StringBuilder</strong>常用,线程不安全,效率高; StringBuffer  线程安全,效率低;</li>
<li>matches()字符串是否匹配给定的正则表达式。</li>
<li>indexOf()返回指定子字符串在此字符串中第一次出现处的索引。(模式匹配api)</li>
<li>trim()返回字符串的副本，忽略前导空白和尾部空白。</li>
<li>valueOf()返回…字符串形式</li>
<li>split()按给定的正则表达式拆分字符串</li>
<li>replace/replaceAll/replaceFirst 替换字符串</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul>
<li>定义:s和t为给定的两个字符串,在主串s中查找子串t的过程称为模式匹配,返回t在s中第一次出现的位置</li>
<li>OJ题目:<a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">LeetCode|字符串匹配,子串第一次出现的位置</a></li>
<li>三种方法:<ol>
<li>java api: indexOf;</li>
<li>暴力搜</li>
<li>KMP算法</li>
</ol>
</li>
<li>kmp算法选择题:next数组<ul>
<li><a href="https://www.nowcoder.com/questionTerminal/57bdf294407c4477969fc7b4d56c7be7" target="_blank" rel="external">next数组</a></li>
</ul>
</li>
<li>求next数组的方法（递归法）</li>
</ul>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><ul>
<li>OJ题目:剑指offer第52题,Solution52;</li>
<li><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer|正则表达式匹配</a> ;<a href="https://leetcode.com/problems/regular-expression-matching/#/description" target="_blank" rel="external">LeetCode|正则表达式匹配</a></li>
<li>解题思路<ul>
<li>字符串 正则表达式匹配<ol>
<li>模式中,当前字符的下一个字符不是<code>*</code><ul>
<li>如果当前字符匹配,则字符串和模式串都下移一位</li>
<li>如果当前字符不匹配,则直接返回false</li>
</ul>
</li>
<li>模式中,当前字符的下一个字符是<code>*</code><ul>
<li>如果当前字符不匹配,则<code>*</code>匹配0个前位字符,模式串后移两位(前位字符,<code>*</code>前面的那个字符)</li>
<li>如果当前字符匹配,分两组<ul>
<li><code>*</code>匹配0个前位字符,模式串后移两位</li>
<li><code>*</code>匹配一个或者多个前位字符,字符串后移以为,模式串不变</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><h2 id="字符串平移-String-shift"><a href="#字符串平移-String-shift" class="headerlink" title="字符串平移(String shift)"></a>字符串平移(String shift)</h2><ul>
<li>题目描述<ul>
<li>我们规定对一个字符串的shift操作如下： shift(“ABCD”, 0) = “ABCD” shift(“ABCD”, 1) = “BCDA” shift(“ABCD”, 2) = “CDAB” 换言之, 我们把最左侧的N个字符剪切下来, 按序附加到了右侧。给定一个长度为n的字符串，我们规定最多可以进行n次向左的循环shift操作。如果shift(string, x) = string (0＜= x ＜n), 我们称其为一次匹配(match)。求在shift过程中出现匹配的次数。</li>
</ul>
</li>
<li>解决： 字符串必为周期字符串，计算出最短周期（用kmp算法中的next数组计算）</li>
</ul>
<h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-substring/" target="_blank" rel="external">最长公共子串</a></li>
<li>思路: 暴力法和<strong>动态规划法</strong>.</li>
</ol>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><ol>
<li><a href="http://www.lintcode.com/zh-cn/problem/longest-common-subsequence/" target="_blank" rel="external">最长公共子序列</a></li>
</ol>
<h2 id="字符串与整数-数组的互相转换"><a href="#字符串与整数-数组的互相转换" class="headerlink" title="字符串与整数,数组的互相转换"></a>字符串与整数,数组的互相转换</h2><p>1.</p>
<h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><h2 id="字符串反转-1"><a href="#字符串反转-1" class="headerlink" title="字符串反转"></a>字符串反转</h2><ul>
<li>StringBuilder.reverse方法;</li>
<li><a href="https://leetcode.com/problems/reverse-words-in-a-string/#/description" target="_blank" rel="external">leetcode|字符串反转</a></li>
</ul>
<h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><h1 id="数组-Integer"><a href="#数组-Integer" class="headerlink" title="数组/Integer"></a>数组/Integer</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的性质"><a href="#链表的性质" class="headerlink" title="链表的性质"></a>链表的性质</h2><p><img src="../images/链表题目总结.png" alt=""></p>
<ol>
<li>技巧: 快慢指针和假头结点</li>
</ol>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><ol>
<li><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第3题-从尾到头打印链表</a></li>
</ol>
<h2 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h2><ol>
<li><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第14题-链表中倒数第k个结点</a></li>
</ol>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><ol>
<li><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第15题-反转链表</a></li>
</ol>
<h2 id="合并两个排序链表-合并排序数组"><a href="#合并两个排序链表-合并排序数组" class="headerlink" title="合并两个排序链表/合并排序数组"></a>合并两个排序链表/合并排序数组</h2><ol>
<li><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第16题-合并两个排序链表</a></li>
<li>合并排序数组,不用辅助空间的方法</li>
</ol>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><ol>
<li><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第25题-复杂链表的复制</a></li>
</ol>
<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><ol>
<li><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第36题-两个链表的第一个公共结点</a></li>
</ol>
<h2 id="删除链表的重复结点"><a href="#删除链表的重复结点" class="headerlink" title="删除链表的重复结点"></a>删除链表的重复结点</h2><ol>
<li><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第56题-删除链表的重复结点</a></li>
</ol>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的定义与性质"><a href="#二叉树的定义与性质" class="headerlink" title="二叉树的定义与性质"></a>二叉树的定义与性质</h2><p><img src="../images/二叉树知识点.png" alt=""></p>
<ol>
<li>二叉树的第i层至多有 2^(i−1) 个结点;</li>
<li>深度为k的二叉树至多有 2^k − 1 个结点;</li>
<li><strong>对任何一棵二叉树T，如果其终端结点数为 n0, 度为2的结点数为 n2, 则 n0 = n2 + 1。</strong></li>
<li>一棵深度为 k, 且有 2^k − 1 个节点称之为<strong>满二叉树</strong>;</li>
<li>深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为<strong>完全二叉树</strong>。完全二叉树中重在节点标号对应,即完全二叉树的叶子结点只能出现在最下层和次下层,最下层的全在树的左部.</li>
<li>具有n个结点的完全二叉树的深度k为<code>(log2n)向下取整+1</code></li>
<li>对于具有n个结点的完全二叉树,从1开始编号(上下左右):<ul>
<li>i&gt;1,则序号为i的结点的父结点序号为<code>i/2</code>(整除);</li>
<li>若2i&lt;=n,则序号为i的结点的左子结点序号为2i; 若2i&gt;n,则结点i无左子结点;</li>
<li>若2i+1&lt;=n,则序号为i的结点的右子节点为2i+1; 若2i+1&gt;n,则无右子节点</li>
<li>若从0开始编号,则i的父节点为(i-1)/2,左子节点为2i+1,右2i+2;</li>
</ul>
</li>
</ol>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ol>
<li>深度优先遍历(DFS)<ul>
<li>前序中序后序三种遍历方式的递归实现</li>
<li>前序中序后序三种遍历方式的非递归实现</li>
<li><a href="http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91.html">三种遍历方法详解总结</a></li>
</ul>
</li>
<li>广度优先遍历(BFS)<ul>
<li>层序遍历</li>
<li>之字形遍历</li>
<li>镜像</li>
</ul>
</li>
<li>OJ链接<ul>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/#/description" target="_blank" rel="external">LeetCode:前序遍历</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/#/description" target="_blank" rel="external">LeetCode:中序遍历</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/#/description" target="_blank" rel="external">LeetCode:后序遍历</a></li>
</ul>
</li>
</ol>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ul>
<li>一颗二叉查找树(BST)是一颗二叉树，其中每个节点都含有一个可进行比较的键及相应的值，且每个节点的<br>键都大于等于左子树中的任意节点的键，而小于右子树中的任意节点的键。</li>
</ul>
<h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h3><ol>
<li><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第23题-二叉搜索树的后序遍历序列</a></li>
</ol>
<h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><ol>
<li><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第26题-二叉搜索树与双向链表</a></li>
</ol>
<h3 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h3><ol>
<li><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第62题-二叉搜索树的第k个结点</a></li>
<li>思路: 用栈对二叉搜索树进行<strong>中序遍历</strong>,搜到第k个结点时跳出</li>
</ol>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><ul>
<li>定义: 如果某二叉树中任意结点的左右子树的深度相差不超过1,那么它就是一颗平衡二叉树</li>
<li>AVL树,自平衡二叉树;<br><img src="../images/AVL.png" alt=""></li>
</ul>
<h3 id="平衡二叉树的判定"><a href="#平衡二叉树的判定" class="headerlink" title="平衡二叉树的判定"></a>平衡二叉树的判定</h3><ol>
<li><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第39题-平衡二叉树</a></li>
<li>思路: 每个结点只遍历一次的解法</li>
</ol>
<h2 id="哈夫曼树-最优二叉树"><a href="#哈夫曼树-最优二叉树" class="headerlink" title="哈夫曼树(最优二叉树)"></a>哈夫曼树(最优二叉树)</h2><h3 id="哈夫曼二叉树的定义及性质"><a href="#哈夫曼二叉树的定义及性质" class="headerlink" title="哈夫曼二叉树的定义及性质"></a>哈夫曼二叉树的定义及性质</h3><ol>
<li>最优二叉树,也称为哈夫曼树:对一组带有权值的叶子结点,构造具有最小带权路径长度的二叉树. 选取权值最小和次小的结点构造.</li>
<li>具有n个叶子节点的哈夫曼树总共有2n-1个结点;</li>
</ol>
<h2 id="其他典型题目"><a href="#其他典型题目" class="headerlink" title="其他典型题目"></a>其他典型题目</h2><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第4题-重建二叉树</a></li>
<li>描述: 由先序和中序遍历序列,重建二叉树</li>
<li>思路:</li>
</ol>
<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><ol>
<li><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第17题-树的子结构</a></li>
<li>思路:</li>
</ol>
<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><ol>
<li><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第18题-二叉树的镜像</a></li>
<li>思路: 对二叉树进行前序遍历,对遍历到的节点,交换其左右子节点(可用递归实现)</li>
</ol>
<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><ol>
<li><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第24题-二叉树中和为某一值的路径</a></li>
<li>思路: 本题重难点!</li>
</ol>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><ol>
<li><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第38题-二叉树的深度</a></li>
<li>思路: 递归;  <strong>思考非递归的方法</strong></li>
</ol>
<h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第58题-对称的二叉树</a></li>
<li>思路: 比较二叉树的前序遍历序列(根左右)和对称前序遍历序列(根右左),用<strong>递归</strong>的方式进行遍历</li>
</ol>
<h3 id="按之字顺序打印二叉树"><a href="#按之字顺序打印二叉树" class="headerlink" title="按之字顺序打印二叉树"></a>按之字顺序打印二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第59题-按之字形顺序打印二叉树</a></li>
<li>思路: 用两个栈存;</li>
</ol>
<h3 id="把二叉树打印成多行-二叉树层序遍历"><a href="#把二叉树打印成多行-二叉树层序遍历" class="headerlink" title="把二叉树打印成多行(二叉树层序遍历)"></a>把二叉树打印成多行(二叉树层序遍历)</h3><ol>
<li><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第60题-把二叉树打印成多行</a></li>
</ol>
<h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><ol>
<li><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第61题-序列化二叉树</a></li>
<li>思路: 前序遍历的递归实现; 注意反序列化如何递归</li>
</ol>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><ol>
<li><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第5题-用两个栈实现队列</a></li>
<li>思路: 队列先进先出,进队时,直接压入stack1;出队列时,如果stack2为空,则将stack1的元素全部压入stack2,再取stack2栈顶,如果stack2不为空,直接去stack2栈顶.</li>
</ol>
<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><ol>
<li><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第20题-包含min函数的栈</a></li>
<li>思路: 使用一个辅助栈,元素进栈时,辅助栈记录当前元素为栈顶时的最小值;元素出栈时,辅助栈也将对应的最小值出栈;</li>
</ol>
<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><ol>
<li><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-剑指offer第64题-滑动窗口的最大值</a></li>
<li>思路: 利用<strong>双端队列</strong><ul>
<li>用一个双端队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次<ol>
<li>判断当前最大值是否过期</li>
<li>新增加的值从队尾开始比较，把所有比他小的值丢掉</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><img src="../images/排序.png" alt=""></p>
<ul>
<li>参考:<a href="http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F.html">见本人排序总结</a></li>
</ul>
<h2 id="经典题目记录"><a href="#经典题目记录" class="headerlink" title="经典题目记录"></a>经典题目记录</h2><h2 id="长度10000的数组-假设数组中的元素平均分成了100段-每一段内的元素有序-求整个数组最大的前20个数"><a href="#长度10000的数组-假设数组中的元素平均分成了100段-每一段内的元素有序-求整个数组最大的前20个数" class="headerlink" title="长度10000的数组,假设数组中的元素平均分成了100段,每一段内的元素有序,求整个数组最大的前20个数"></a>长度10000的数组,假设数组中的元素平均分成了100段,每一段内的元素有序,求整个数组最大的前20个数</h2><ul>
<li>使用堆排序<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><ol>
<li><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="external">牛客网-剑指offer第29题-最小的k个数</a></li>
<li>思路: O(nlogk)算法,堆排序</li>
</ol>
</li>
</ul>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h2 id="哈希表查找"><a href="#哈希表查找" class="headerlink" title="哈希表查找"></a>哈希表查找</h2><ul>
<li>处理冲突的方法<ol>
<li><strong>开放地址法</strong>: 由关键码得到哈希地址,如果该地址已经存放了元素,就按照一个探测序列去寻找下一个空的哈希地址</li>
<li><strong>拉链法</strong>:将地址相同的拉成一个链表,将各个链表放在相应的数组中</li>
</ol>
</li>
</ul>
<h1 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h1><h2 id="最大公约数-最小公倍数"><a href="#最大公约数-最小公倍数" class="headerlink" title="最大公约数/最小公倍数"></a>最大公约数/最小公倍数</h2><ul>
<li>最大公约数:greatest common divisor</li>
<li>欧几里得法(辗转相除法):设<code>a&gt;b</code>,<code>a=b*p+q</code>,b与q的最大公约也就是a与b的最大公约数,直到q为0,直接返回;</li>
<li>最小公倍数:lowest common multiple; <code>lcm(a,b)*gcd(a,b)=a*b</code>;</li>
<li>求两个数或n个数的最小公倍数或最大公约数:<br><img src="../images/gcd.png" alt=""></li>
</ul>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><ul>
<li>素数: 只有1和本身两个约数;判断是否为素数,只需要对前根号n个数进行判断<br><img src="../images/prime.png" alt=""></li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位操作有按位与、或、非、左移n位和右移n位等操作。</p>
<ol>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1): 可以把最右边的一个1变成0;<br>2.</li>
</ol>
<h3 id="二进制中的1的个数"><a href="#二进制中的1的个数" class="headerlink" title="二进制中的1的个数"></a>二进制中的1的个数</h3><ul>
<li>将n的二进制表示的右边第一个1变成0:n&amp;(n-1)</li>
</ul>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><ul>
<li>卡特兰数递推关系:<img src="../images/卡特兰.png" alt=""></li>
<li>卡特兰数通项式:<img src="../images/catalan.png" alt=""><img src="../images/catalan1.png" alt=""></li>
<li>栈的出栈序列:1到n的序列,依次进栈,有多少种不同的出栈序列</li>
</ul>
<h2 id="全排列和全组合"><a href="#全排列和全组合" class="headerlink" title="全排列和全组合"></a>全排列和全组合</h2><ul>
<li>思路: 从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理；</li>
<li>参考:<a href="https://segmentfault.com/a/1190000002710424" target="_blank" rel="external">全排列/全组合</a></li>
</ul>
<h1 id="其他经典算法"><a href="#其他经典算法" class="headerlink" title="其他经典算法"></a>其他经典算法</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h1 id="其他经典题目"><a href="#其他经典题目" class="headerlink" title="其他经典题目"></a>其他经典题目</h1><h2 id="打印日历"><a href="#打印日历" class="headerlink" title="打印日历"></a>打印日历</h2><ul>
<li><a href="http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%97%A5%E5%8E%86%E8%AE%A1%E7%AE%97.html">日历计算</a></li>
</ul>
<h1 id="校招真题练习"><a href="#校招真题练习" class="headerlink" title="校招真题练习"></a>校招真题练习</h1><h2 id="今日头条"><a href="#今日头条" class="headerlink" title="今日头条"></a>今日头条</h2><ol>
<li><a href="http://liuhang.net.cn/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91.html">异或|字典树应用</a>   <strong>本题重点，不可暴力枚举,应用字典树</strong></li>
</ol>
<h2 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h2>]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java基础-Object类通用方法</title>
      <link>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-Object%E7%B1%BB%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html</link>
      <guid>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-Object%E7%B1%BB%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html</guid>
      <pubDate>Sun, 16 Apr 2017 05:57:37 GMT</pubDate>
      <description>
      
        effective java 第三章,对于所有对象都通用的方法.
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Object类概览"><a href="#Object类概览" class="headerlink" title="Object类概览"></a>Object类概览</h1><p><img src="../images/object.png" alt=""></p>
<ul>
<li>Object类,主要是用来扩展,它的所有非final方法(如上图,hashCode, equals, clone, toString, finalize)都有明确的通用约定,它们被设计成要被覆盖的(override),任何一个类,覆盖这些方法时,都要遵守这些约定.</li>
</ul>
<h1 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h1><ul>
<li>设计目的: 用于检测一个对象是否等于另外一个对象.Object类中,这个方法默认将判断两个对象是否具有相同的引用.<br><img src="../images/equals方法.png" alt=""></li>
<li>equals方法满足特性<ul>
<li>自反性 x.equals(x)返回true</li>
<li>对称性</li>
<li>传递性</li>
<li>一致性</li>
<li>非空性 x.equals(null) 返回false</li>
</ul>
</li>
<li><strong>覆盖equals方法时,遵守约定</strong></li>
</ul>
<h1 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h1><ul>
<li>设计目的:由对象导出的一个整型值,java用hash算法的原理,来查找比较元素,提高查找效率(例如java集合中)</li>
<li><strong>覆盖equals时,总要覆盖hashCode</strong></li>
<li>规范<ul>
<li>如果x.equals(y)为true, x.hashCode()与y.hashCode()具有相同的值,<strong>相等的对象必须具有相等的散列码</strong></li>
<li>如果两个对象,equals方法比较不相等,则hashCode方法不一定产生不同的整数结果</li>
</ul>
</li>
<li>hashMap底层原理<ul>
<li><a href="http://kakajw.iteye.com/blog/935226" target="_blank" rel="external">深入解析Java对象的hashCode和hashCode在HashMap的底层数据结构的应用</a></li>
</ul>
</li>
</ul>
<h1 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h1><ul>
<li>设计目的: 返回表示对象值得字符;通用约定:被返回的字符串应该是一个”简洁的,但信息丰富,且易于阅读的形式”</li>
<li>java.lang.Object默认返回类的名称+”@”符号+散列码的无符号16进制表示<br><img src="../images/toString方法.png" alt=""></li>
<li>当对象被传递给println, printf, 字符串联操作符(+)以及assert或者被调试器打印出来时,toString方法会被自动调用. <strong>建议所有子类覆盖toStirng方法</strong></li>
</ul>
<h1 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h1><ul>
<li>默认的clone操作是浅copy,它并没有克隆包含爱对象中的内部对象</li>
<li><p>所有的数组类型均包含一个public的clone方法,可以利用这个方法创建一个包含所有数组元素拷贝的一个新数组.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] luckNums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</div><div class="line"><span class="keyword">int</span>[] cloned = luckNums.clone();</div><div class="line">cloned[<span class="number">5</span>]=<span class="number">12</span>;<span class="comment">//doesn't change luckNums[5];</span></div></pre></td></tr></table></figure>
</li>
<li><p>要进行clone处理,</p>
<ul>
<li>则要实现标记接口Cloneable,</li>
<li>用public修饰符重新定义clone方法</li>
</ul>
</li>
<li><strong>谨慎的覆盖clone</strong></li>
</ul>
<h1 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h1><ul>
<li><img src="../images/finalize.png" alt=""></li>
<li><strong>工作原理</strong>: 一旦垃圾回收器准备好释放对象占用的存储空间,将首先调用其finalize()方法,并且在下一次垃圾回收动作发生时才会真正回收对象占用的内存.</li>
<li><strong>避免使用finalize方法</strong></li>
<li><a href="http://www.cnblogs.com/yantz/p/4610614.html" target="_blank" rel="external">finalize()和System.gc()区别</a></li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-Object%E7%B1%BB%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java基础-面试总结</title>
      <link>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</link>
      <guid>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Sun, 16 Apr 2017 05:31:55 GMT</pubDate>
      <description>
      
        面试常考知识点总结,各种面试题目总结
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h2><ul>
<li>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。“一次编译，到处运行”。在不同平台上安装对应的JVM，jvm与底层硬件交互，由虚拟机负责运行java程序。</li>
</ul>
<h2 id="JDK和JRE的区别"><a href="#JDK和JRE的区别" class="headerlink" title="JDK和JRE的区别"></a>JDK和JRE的区别</h2><ul>
<li>JRE: java runtime environment运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。J</li>
<li>JDK: java development kit完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序</li>
</ul>
<h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><ul>
<li>基本数据类型分类(4类8种)<ul>
<li>整数型<ul>
<li>byte 一个字节,-128~127</li>
<li>short 两个字节,-2^15~2^15-1</li>
<li>int 四个字节,-2^31-2^31-1</li>
<li>long 八个字节,-2^63-2^63-1</li>
</ul>
</li>
<li>浮点型:即小数型<ul>
<li>float 四个字节</li>
<li>double 八个字节</li>
</ul>
</li>
<li>字符型<ul>
<li>char 两个字节 0~65535(2^16-1),没有负数</li>
</ul>
</li>
<li>布尔型<ul>
<li>boolean :只有 true false ; boolean理论上占八分之一字节,但java中boolean类型没有明确指定它的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-面向对象三大特征"><a href="#1-3-面向对象三大特征" class="headerlink" title="1.3    面向对象三大特征"></a>1.3    面向对象三大特征</h2><ul>
<li>封装encapsulation：封装是指隐藏对象的属性和实现细节,仅对外提供公共访问方式</li>
<li>继承inheritance：Java只支持单继承,</li>
<li>多态polymorphism：</li>
</ul>
<h2 id="1-4-override和overload"><a href="#1-4-override和overload" class="headerlink" title="1.4    override和overload"></a>1.4    override和overload</h2><ul>
<li>override:方法重写: 子类中出现和父类中方法声明一模一样的方法</li>
<li><p>方法的重写（override）两同两小一大原则：</p>
<ul>
<li>方法名相同，参数类型相同</li>
<li>子类返回类型小于等于父类方法返回类型，(从而可类型自动转换)</li>
<li>子类抛出异常小于等于父类方法抛出异常，</li>
<li>子类访问权限大于等于父类方法访问权限。</li>
</ul>
</li>
<li><p>overload：方法重载: 本类中出现的方法名一样,参数列表不同的方法,与返回类型值无关</p>
</li>
</ul>
<h2 id="1-5-static和final"><a href="#1-5-static和final" class="headerlink" title="1.5    static和final"></a>1.5    static和final</h2><p>static，final初始化总结：<br>1、被final修饰而没有被static修饰的类的属性变量只能在两种情况下初始化:(必须初始化）<br>   a.在它被声明的时候赋值;b.在构造函数里初始化;c .在非静态块里<br>2、被static修饰而没有被final修饰的类的属性变量只能在两种情况下初始化:(可以不初始化）<br>   a.在它被声明的时候赋值;b.在静态或非静态快里初始化;<br>3、同时被final和static修饰的类的属性变量只能在两种情况下初始化:（必须初始化）<br>   a.在它被定义的时候;b.在类的静态块里初始化</p>
<p>接口里面定义的常量必须初始化；</p>
<h2 id="1-6-代码块执行顺序"><a href="#1-6-代码块执行顺序" class="headerlink" title="1.6    代码块执行顺序"></a>1.6    代码块执行顺序</h2><p><strong>父类静态-子类静态-父类属性初始化,普通代码,块构造函数-子类属性初始 构造块和构造函数(new 则执行)</strong><br>1.父类静态代码块 （  java虚拟机加载类时，就会执行该块代码，故只执行一次）<br>2 .子类静态代码块 （  java虚拟机加载类时，就会执行该块代码，故只执行一次）</p>
<ol>
<li>父类属性对象初始化<br>4.父类普通代码块（每次new,每次执行 ）</li>
<li>父类构造函数（每次new,每次执行）<br>6.子 类 属性对象初始化<br>7.子类普通代码块（每次new,每次执行 ）<br>8.子 类构造函数（每次new,每次执行</li>
</ol>
<p>final<br>final修饰的方法，不允许被子类覆盖。<br>final修饰的类，不能被继承。<br>final修饰的变量，不能改变值。<br>final修饰的引用类型，不能再指向别的东西，但是可以改变其中的内容。</p>
<h2 id="1-7-Java支持多继承么？"><a href="#1-7-Java支持多继承么？" class="headerlink" title="1.7    Java支持多继承么？"></a>1.7    Java支持多继承么？</h2><p>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。<br>但是java中的接口支持多继承，，即一个子接口可以有多个父接口(接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能)。</p>
<h2 id="1-8-方法覆盖-Overriding-和方法重载-Overloading-的区别"><a href="#1-8-方法覆盖-Overriding-和方法重载-Overloading-的区别" class="headerlink" title="1.8    方法覆盖(Overriding)和方法重载(Overloading)的区别"></a>1.8    方法覆盖(Overriding)和方法重载(Overloading)的区别</h2><p>Override 重写(覆盖) 子类中出现和父类中方法声明一模一样的方法,返回类型值一致<br>Overload 重载 本类中出现的方法名一样,参数列表不同的方法,与返回类型值无关</p>
<h2 id="1-9-如何理解多态"><a href="#1-9-如何理解多态" class="headerlink" title="1.9    如何理解多态"></a>1.9    如何理解多态</h2><p>实现多态的技术称为：动态绑定；动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法；<br>Java实现多态有三个必要条件：继承、重写、父类引用指向子类对象。</p>
<h2 id="1-10-Java四种权限修饰符"><a href="#1-10-Java四种权限修饰符" class="headerlink" title="1.10    Java四种权限修饰符"></a>1.10    Java四种权限修饰符</h2><h2 id="1-11-接口和抽象类"><a href="#1-11-接口和抽象类" class="headerlink" title="1.11    接口和抽象类"></a>1.11    接口和抽象类</h2><ol>
<li>接口中的成员方法，属性默认为public（可省略）且只能为public</li>
<li>接口中的成员变量，属性默认为public static final(可省略)</li>
<li>接口，只能声明为 public interface …{}</li>
<li>java中的接口支持多继承，一个接口可以继承(extends)多个父接口<br><img src="../images/interface.png" alt=""></li>
<li>抽象类则可以同时包含抽象和非抽象的方法</li>
<li>类可以不实现抽象类和接口声明的所有方法，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类不能被实例化。</li>
<li>abstract 不能与private、static、final或native并列修饰同一个方法<br><img src="../images/接口和抽象类区别.png" alt=""></li>
</ol>
<h2 id="1-12-进程和线程的区别"><a href="#1-12-进程和线程的区别" class="headerlink" title="1.12    进程和线程的区别"></a>1.12    进程和线程的区别</h2><p>进程是一种静态的概念，；进程是表示资源分配的基本单位，一个进程内可以包含多个线程；进程间切换开销大；<br>线程是进程中执行运算的最小单位，可以理解为程序内部的一条执行路径，顺序控制流；每个线程有独立的有独立的线程栈和程序计数器，线程切换开销小。</p>
<h2 id="线程的几种可用状态"><a href="#线程的几种可用状态" class="headerlink" title="线程的几种可用状态"></a>线程的几种可用状态</h2><ol>
<li>新建( new )：新创建了一个线程对象。</li>
<li>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li>
<li>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</li>
<li>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<br>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。<br>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</li>
<li>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生</li>
</ol>
<h2 id="Java创建线程的三种种方式"><a href="#Java创建线程的三种种方式" class="headerlink" title="Java创建线程的三种种方式"></a>Java创建线程的三种种方式</h2><ol>
<li>继承Thread类；重写其run方法；</li>
<li>实现Runnable接口；</li>
<li>使用ExecutorService、Callable、Future实现<strong>有返回结果</strong>的多线程(JDK5.0以后)</li>
</ol>
<h2 id="1-15-什么是死锁-deadlock-？"><a href="#1-15-什么是死锁-deadlock-？" class="headerlink" title="1.15    什么是死锁(deadlock)？"></a>1.15    什么是死锁(deadlock)？</h2><p>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。</p>
<h2 id="1-16-监视器-Monitor-如何线程同步"><a href="#1-16-监视器-Monitor-如何线程同步" class="headerlink" title="1.16    监视器(Monitor)如何线程同步"></a>1.16    监视器(Monitor)如何线程同步</h2><h2 id="1-17-Java集合框架有哪些接口"><a href="#1-17-Java集合框架有哪些接口" class="headerlink" title="1.17    Java集合框架有哪些接口"></a>1.17    Java集合框架有哪些接口</h2><p><img src="../images/集合体系图.png" alt=""></p>
<ul>
<li>list接口:<ul>
<li>元素可重复,元素有放入顺序;</li>
<li>ArrayList: 非线程安全,效率高;vector 线程安全,效率低</li>
<li>所有list中可以有null元素</li>
</ul>
</li>
<li>set接口:<ul>
<li>元素不可重复,无序</li>
<li>可以有null元素</li>
</ul>
</li>
<li>Queue接口<ul>
<li>一般不允许有null元素(LinkedList除外,它同时继承了List接口)</li>
</ul>
</li>
<li>Map接口<ul>
<li>HashMap非线程安全，高效，支持null；</li>
<li>HashTable线程安全，低效，不支持null </li>
</ul>
</li>
</ul>
<h2 id="1-18-什么是迭代器-Iterator-？"><a href="#1-18-什么是迭代器-Iterator-？" class="headerlink" title="1.18    什么是迭代器(Iterator)？"></a>1.18    什么是迭代器(Iterator)？</h2><h2 id="1-19-Iterator和ListIterator的区别是什么？"><a href="#1-19-Iterator和ListIterator的区别是什么？" class="headerlink" title="1.19    Iterator和ListIterator的区别是什么？"></a>1.19    Iterator和ListIterator的区别是什么？</h2><h2 id="1-20-Map遍历的几种方法"><a href="#1-20-Map遍历的几种方法" class="headerlink" title="1.20    Map遍历的几种方法"></a>1.20    Map遍历的几种方法</h2><p><a href="http://www.trinea.cn/android/hashmap-loop-performance/" target="_blank" rel="external">http://www.trinea.cn/android/hashmap-loop-performance/</a></p>
<h2 id="1-21-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#1-21-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="1.21    快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>1.21    快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h2><h2 id="1-22-为什么集合类没有实现Cloneable和Serializable接口？"><a href="#1-22-为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="1.22    为什么集合类没有实现Cloneable和Serializable接口？"></a>1.22    为什么集合类没有实现Cloneable和Serializable接口？</h2><ul>
<li>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</li>
</ul>
<h2 id="1-23-Java中的HashMap的工作原理是什么？"><a href="#1-23-Java中的HashMap的工作原理是什么？" class="headerlink" title="1.23        Java中的HashMap的工作原理是什么？"></a>1.23        Java中的HashMap的工作原理是什么？</h2><ol>
<li>HashMap底层是一个数组结构,数组的每一个元素是一个链表,而且链表中的每个节点是一个Entry[]键值对的数据结构。</li>
<li>添加元素的原理:put添加键值对,根据key计算hashCode,根据hashcode得到在数组中的下标(<code>int i = hash(key.hashcode)&amp;(len-1);</code>),新加入的放在链表头,最先加入的在链尾;</li>
<li>获取元素的原理: 首先计算hashCode值,找到数组对应的位置,然后根据equals方法,找到在对应位置的链表中找到对应的元素;</li>
</ol>
<h2 id="HashMap和Hashtable-ConcurrentHashMap区别？"><a href="#HashMap和Hashtable-ConcurrentHashMap区别？" class="headerlink" title="HashMap和Hashtable,ConcurrentHashMap区别？"></a>HashMap和Hashtable,ConcurrentHashMap区别？</h2><ul>
<li>HashMap非线程安全，高效，支持null；</li>
<li>HashTable线程安全，低效，不支持null </li>
<li>Hashtable中采用的锁机制是一次锁住整个hash表，从而同一时刻只能由一个线程对其进行操作；所有方法都是同步的</li>
<li>ConcurrentHashMap的设计有点特别，表现在多个线程操作上。它不用做外的同步的情况下默认同时允许16个线程读和写这个Map容器; 将hash表分为16个段,只锁住当前用到的段,并发性能提升;</li>
<li>迭代方法不同</li>
</ul>
<h2 id="hashCode-和equals-方法的重要性体现在什么地方？"><a href="#hashCode-和equals-方法的重要性体现在什么地方？" class="headerlink" title="hashCode()和equals()方法的重要性体现在什么地方？"></a>hashCode()和equals()方法的重要性体现在什么地方？</h2><h2 id="数组-Array-和列表-ArrayList-有什么区别？"><a href="#数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？"></a>数组(Array)和列表(ArrayList)有什么区别？</h2><h2 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h2><ul>
<li>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构.<br>这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。</li>
<li>2.对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。</li>
<li>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li>
</ul>
<h2 id="Comparable和Comparator接口是干什么的？"><a href="#Comparable和Comparator接口是干什么的？" class="headerlink" title="Comparable和Comparator接口是干什么的？"></a>Comparable和Comparator接口是干什么的？</h2><h2 id="什么是Java优先级队列-Priority-Queue-？"><a href="#什么是Java优先级队列-Priority-Queue-？" class="headerlink" title="什么是Java优先级队列(Priority Queue)？"></a>什么是Java优先级队列(Priority Queue)？</h2><h2 id="HashSet和TreeSet有什么区别？"><a href="#HashSet和TreeSet有什么区别？" class="headerlink" title="HashSet和TreeSet有什么区别？"></a>HashSet和TreeSet有什么区别？</h2><ul>
<li>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。</li>
<li>另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</li>
</ul>
<h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><ol>
<li><p>Java 5之后,基本数据类型和对应的包装类型,可以自动互相装换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer i = <span class="number">10</span>;<span class="comment">//装箱</span></div><div class="line"><span class="keyword">int</span> n = i;<span class="comment">//拆箱</span></div></pre></td></tr></table></figure>
</li>
<li><p>装箱和拆箱是如何实现的</p>
<ul>
<li>装箱时,调用的是Integer.valueOf()方法</li>
<li>拆箱时,调用的是Integer.intValue()方法</li>
</ul>
</li>
<li>Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别<ul>
<li>第一种方式不会触发自动装箱的过程；而第二种方式会触发；</li>
<li>在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</li>
</ul>
</li>
<li>Integer.valueOf,数值在[-128,127]之间则直接返回缓存中已经存在的对象</li>
<li><strong>“==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程)</strong></li>
<li>参考:<a href="http://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="external">深入剖析Java中的装箱和拆箱</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nowcoder.com/ta/review-java" target="_blank" rel="external">https://www.nowcoder.com/ta/review-java</a></p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="对Spring的理解"><a href="#对Spring的理解" class="headerlink" title="对Spring的理解"></a>对Spring的理解</h2><ul>
<li>Spring是一个轻量级的JavaEE开发框架; Spring的核心思想是控制反转和面向切面;</li>
<li>控制反转: 借助于“第三方”实现具有依赖关系的对象之间的解耦</li>
<li>面向切面:在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</li>
</ul>
<h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><h2 id="对mvc模式的理解"><a href="#对mvc模式的理解" class="headerlink" title="对mvc模式的理解"></a>对mvc模式的理解</h2><ul>
<li>一般J2EE web开发,是一个分层式的架构,表现层(web层)-业务层(service)层-持久层(dao层),mvc模式是表现层开发的一种设计模式,目的是解除控制逻辑,业务逻辑,视图之间的耦合;mvc模式由模型,视图,控制器三部分组成;控制器是接收客户端所提交的请求,将请求转发给适当的模型进行处理,然后将处理的结构返回给视图;</li>
</ul>
<h2 id="Session和cookie的区别"><a href="#Session和cookie的区别" class="headerlink" title="Session和cookie的区别"></a>Session和cookie的区别</h2><ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上</li>
<li>session能够存储任意的Java对象，cookie只能存储String类型的对象</li>
<li>session会保存在服务器上一段时间,当访问增多,会占用服务器性能,考虑减轻服务器性能的话,应该使用cookie</li>
<li>cookie不是很安全,别人可以分享本地cookie,进行cookie欺骗</li>
</ol>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层模型与TCP-IP四层模型"><a href="#OSI七层模型与TCP-IP四层模型" class="headerlink" title="OSI七层模型与TCP/IP四层模型"></a>OSI七层模型与TCP/IP四层模型</h2><p><img src="../images/osi七层模型.gif" alt=""></p>
<ul>
<li>实际应用的tcp/ip四层: 连接层,网络层,传输层,应用层</li>
<li>各层的作用<ol>
<li>物理层：通过媒介传输比特,确定机械及电气规范</li>
<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ol>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="../images/ip.png" alt=""><br><img src="../images/ip1.png" alt=""></p>
<ul>
<li>A类地址,<ul>
<li>可指派的网络号126个(2^7-2),见2的原因是: 网络号全0为保留地址,表示本网络;网络号127(0111 1111)保留为回环测试(如127.0.0.1)</li>
<li>可指派的主机号: 2^24-2; 减去全0的主机号,减去全1主机号</li>
</ul>
</li>
<li>B类地址<ul>
<li>可指派网络号2^14-1:128.0不指派,最小可指派的网络号是128.1</li>
<li>主机号减2,2^16-2;</li>
</ul>
</li>
<li>C类地址<ul>
<li>可指派网络号2^21-1:192.0.0不指派,最小可指派的网络号192.0.1</li>
<li>主机号减2: 2^8-2;</li>
</ul>
</li>
</ul>
<h2 id="TCP-UDP协议"><a href="#TCP-UDP协议" class="headerlink" title="TCP/UDP协议"></a>TCP/UDP协议</h2><ul>
<li>运输层协议和网络层协议的主要区别<br><img src="../images/运输层网络层.png" alt=""></li>
<li><p>运输层的协议端口号</p>
<ul>
<li>协议端口号(protocol port number),简称端口;使不同的操作系统中的进程可以相互通信,用统一的方法对TCP/IP体系中的应用进程进行标识;16位的端口号(65535个)</li>
<li>通信的终点是应用进程,但我们只需把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成</li>
</ul>
</li>
<li><p>tcp字段含义<br><img src="../images/tcp字段.png" alt=""></p>
</li>
<li><p>传输层定义两种传输协议：TCP（传输控制协议）和 UDP（或用户数据报协议）<br><img src="../images/tcp-udp.png" alt=""></p>
</li>
<li>TCP协议和UDP协议特性区别总结：<ol>
<li>TCP协议在传送数据段的时候要给段标号；UDP协议不</li>
<li>TCP协议可靠；UDP协议不可靠</li>
<li>TCP协议是面向连接；UDP协议采用无连接</li>
<li>TCP协议负载较高，采用虚电路；UDP采用无连接</li>
<li>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</li>
<li>TCP协议采用窗口技术和流控制</li>
</ol>
</li>
</ul>
<h2 id="TCP三次握手与四次分手"><a href="#TCP三次握手与四次分手" class="headerlink" title="TCP三次握手与四次分手"></a>TCP三次握手与四次分手</h2><p><img src="../images/tcp.jpg" alt=""></p>
<ol>
<li>三次握手和四次分手的过程</li>
<li>为什么要三次握手和四次分手</li>
<li>参考:<a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>http状态码<br><img src="../images/http状态码.png" alt=""><ul>
<li>404  未找到，服务器找不到所请求的网页。</li>
<li>302  临时移动，服务器从不同位置的网页响应请求，请求者应继续使用原有位置进行以后的请求。</li>
<li>500  （服务器内部错误），服务器遇到错误，无法完成请求。</li>
<li>403  （禁止）服务器拒绝请求</li>
</ul>
</li>
<li>http与https区别<ul>
<li>http协议</li>
<li>简单理解: https是安全版的http,</li>
<li>HTTP的端口号是80，https的端口号是443</li>
</ul>
</li>
</ul>
<h2 id="SNMP简单网络管理协议"><a href="#SNMP简单网络管理协议" class="headerlink" title="SNMP简单网络管理协议"></a>SNMP简单网络管理协议</h2><ul>
<li>simple network management protocol 简单网络管理协议</li>
<li>是一个网络管理员用来管理的工具相当于  一个app 所以是<strong>应用层</strong></li>
</ul>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul>
<li>Internet Control Message Protocol 互联网控制消息协议</li>
<li>网络层协议</li>
<li>用ping命令,检查一台主机的网络层是否连通;</li>
</ul>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ul>
<li>IEEE 802.3—CSMA/CD网络，定义CSMA/CD总线网的MAC子层和物理层的规范,人们习惯将<strong>IEEE 802.3称为”以太网</strong>;</li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li>描述操作系统的两个主要责任。</li>
<li>定义内存和进程管理。</li>
<li>解释分时操作是如何创建虚拟机假象的。</li>
<li>解释逻辑地址和物理地址之间的关系。</li>
<li>比较内存管理方法。</li>
<li>区别固定分区法和固定分区法。</li>
<li>定义和应用分区选择算法。</li>
<li>解释请求分页是如何创建虚拟机假象的。</li>
<li>解释进程生存周期的各个阶段和过渡。</li>
<li>解释各种 CPU 调度算法的处理。</li>
<li>进程间的通信方式</li>
</ul>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>UNIX中有如下的通信方式：</p>
<ul>
<li>1） 文件和记录锁定。<br>为避免两个进程间同时要求访问同一共享资源而引起访问和操作的混乱，在进程对<br>共享资源进行访问前必须对其进行锁定，该进程访问完后再释放。这是UNIX为共享<br>资源提供的互斥性保障。</li>
<li>2 ）管道。<br>管道一般用于两个不同进程之间的通信。当一个进程创建一个管道，并调用fork创<br>建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样 提供了<br>两个进程之间数据流动的一种方式。</li>
<li>3 ） FIFO 。<br>FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个<br>FIFO都有一个名字，允许不相关的进程访问同一个FIFO。因此也成为命名管。</li>
<li>4）消息队列。<br>UNIX下不同进程之间可实现共享资源的一种机制；UNIX允许不同进程将格式化的数<br>据流以消息形式发送给任意<br>进程。对消息队列具有操作权限的进程都可以使用msget完成对消息队列的操作控制<br>。通过使用消息类型，进程可以按任何顺序读消息，或为消息安排优先级顺序。</li>
<li>5 ）信号灯。<br>作为进程间通讯的一种方法，它不是用于交换大批数据，而用于多进程之间的同步<br>（协调对共享存储段的存取）。</li>
<li>6 ）共享内存。<br>通过信号灯实现存储共享（类似“红灯停、绿灯行”）</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库四大特性"><a href="#数据库四大特性" class="headerlink" title="数据库四大特性"></a>数据库四大特性</h2><ol>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ol>
<h1 id="linux-shell"><a href="#linux-shell" class="headerlink" title="linux/shell"></a>linux/shell</h1><h1 id="面试问题收集"><a href="#面试问题收集" class="headerlink" title="面试问题收集"></a>面试问题收集</h1><ol>
<li>说说所知道的设计模式</li>
<li>多线程下的单例模式</li>
<li>多线程编程，遇到的问题，怎么解决的</li>
<li>大型项目如何分配，管理</li>
</ol>
<h1 id="项目-实习-学习"><a href="#项目-实习-学习" class="headerlink" title="项目/实习/学习"></a>项目/实习/学习</h1><h2 id="说说你所知道的设计模式-及应用"><a href="#说说你所知道的设计模式-及应用" class="headerlink" title="说说你所知道的设计模式,及应用"></a>说说你所知道的设计模式,及应用</h2><h2 id="最近看了什么书-待看的书籍"><a href="#最近看了什么书-待看的书籍" class="headerlink" title="最近看了什么书/待看的书籍"></a>最近看了什么书/待看的书籍</h2><p>**</p>
<ul>
<li>操作系统(教材版) <strong>优先</strong></li>
</ul>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><ul>
<li>您好,我叫刘航,湖北孝感人;来自华中科技大学电信学院,18年6月份研究生毕业;</li>
<li>研究生一年级期间,参加华为软件精英挑战赛,并获得全国亚军; 16年暑假在华为公司武汉研究所实习;</li>
<li>在软件技能方面,熟悉Java基础,了解linux, Spring框架,对设计模式也有一定的了解; 有个人博客站点,总结学习成果;</li>
<li>个人爱好方面,喜欢运动,特别是跑步,大概每周会跑一次8公里;感觉跑步特别锻炼人的意志力;</li>
</ul>
<h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><ul>
<li>比赛规模：    全国八个赛区，赛区32强，赛区4强进决赛</li>
<li>描述：在有向图中求最短路径的问题，约束是：给定了起点和终点，同时给定了一系列必经节点，求经过所有必经节点的最短路径。</li>
<li>解决思路： 指派问题结合分支定界来结局，可以把这个看成一个指派问题，根据有向图信息，得到一个费用矩阵，求一个最小指派，每个节点都要连接另一个节点，这样会形成一系列的环，然后用分支定界来破开环，最后形成一个环  即可。求指派问题： 用匈牙利算法，km算法（效率更高）</li>
</ul>
<h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><ul>
<li><p>名称：统一网元采集器；</p>
</li>
<li><p>项目周期：3个月（2016.06-2016.09）；</p>
</li>
<li><p>团队规模：后端开发3；前端3人；测试2人；</p>
</li>
<li><p>目标用户：内部平台，主要供公司内部的技术服务人员使用。</p>
</li>
<li><p>项目描述：采集网元信息的平台，（网元：一个网络系统中的某个网络单元或者节点, 即能独立完成一种或几种功能的设备，如基站，交换机），主要作用是采集网元设备的信息（比如这个设备的类型，是否正在运行，设备的硬件信息温度等）；  主要功能（模块）包括： 网元信息管理，采集模板管理，采集脚本管理，采集日志管理；</p>
</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java基础-正则表达式</title>
      <link>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</link>
      <guid>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</guid>
      <pubDate>Sat, 15 Apr 2017 16:16:59 GMT</pubDate>
      <description>
      
        正则表达式语法,Java正则表达式使用
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="正则表达式基础语法"><a href="#正则表达式基础语法" class="headerlink" title="正则表达式基础语法"></a>正则表达式基础语法</h1><ul>
<li><p>定义:是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串</p>
</li>
<li><p>常用的元字符</p>
<ul>
<li><code>.</code>    匹配除换行符以外的任意字符</li>
<li><code>\w</code>    匹配字母或数字或下划线或汉字</li>
<li><code>\s</code>    匹配任意的空白符</li>
<li><code>\d</code>    匹配数字</li>
<li>\b    匹配单词的开始或结束</li>
<li>`^``    匹配字符串的开始</li>
<li><code>$</code>    匹配字符串的结束</li>
</ul>
</li>
<li><p>重复</p>
<ul>
<li><code>*</code>    重复零次或更多次</li>
<li><code>+</code> 重复一次或更多次</li>
<li><code>?</code>    重复零次或一次(记忆:问号表示有或者没有)</li>
<li><code>{n}</code>    重复n次</li>
<li><code>{n,}</code>    重复n次或更多次</li>
<li><code>{n,m}</code>    重复n到m次</li>
</ul>
</li>
<li><p>字符类</p>
<ul>
<li>使用方括号<code>[]</code>: 匹配方括号中的任意字符</li>
<li>例如:像<code>[0-9]</code>代表的含意与<code>\d</code>就是完全一致的：一位数字；同理<code>[a-z0-9A-Z_]</code>也完全等同于<code>\w</code>（如果只考虑英文的话）。</li>
</ul>
</li>
<li><p>分支条件</p>
<ul>
<li>使用<code>|</code>,即”或”</li>
<li>例如:<code>0\d{2}-\d{8}|0\d{3}-\d{7}</code>这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)</li>
</ul>
</li>
<li>反义<ul>
<li><code>\W</code>匹配任意不是字母，数字，下划线，汉字的字符</li>
<li><code>\S</code>    匹配任意不是空白符的字符</li>
<li><code>\D</code>    匹配任意非数字的字符</li>
<li><code>\B</code>    匹配不是单词开头或结束的位置</li>
<li><code>[^x]</code>匹配除了x以外的任意字符</li>
<li><code>[^aeiou]</code>    匹配除了aeiou这几个字母以外的任意字符</li>
</ul>
</li>
<li>分组<ul>
<li>使用小括号’()’</li>
<li>例如:<code>(\d{1,3}\.){3}\d{1,3}</code>是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：<code>\d{1,3}</code>匹配1到3位的数字，<code>(\d{1,3}\.){3}</code>匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</li>
</ul>
</li>
</ul>
<h1 id="glob-模式"><a href="#glob-模式" class="headerlink" title="glob 模式"></a>glob 模式</h1><ul>
<li>shell所使用的简化的正则表达式</li>
<li>星号（<code>*</code>）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>*</code>) 表示匹配任意中间目录，比如a/<code>**</code>/z 可以匹配 a/z, a/b/z 或 a/b/c/z等  </li>
</ul>
<h1 id="Java中正则表达式使用"><a href="#Java中正则表达式使用" class="headerlink" title="Java中正则表达式使用"></a>Java中正则表达式使用</h1><ul>
<li>java正则表达式中的转义<code>\</code>与<code>\\</code>:  Java 的正则表达式在匹配点(<code>.</code>)  和斜杠(<code>\</code>)，表达式要分别写作 <code>\\.</code>和 <code>\\\\</code></li>
<li>参考:<a href="https://unmi.cc/understand-java-regex-backslash/" target="_blank" rel="external">理解 Java 正则表达式怪异的 <code>\\</code>和 <code>\\\\</code></a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">强烈推荐教程</a></li>
<li><a href="https://regexper.com/" target="_blank" rel="external">正则表达式可视化理解</a></li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/Java%E5%9F%BA%E7%A1%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人计划至四月底</title>
      <link>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B3%E5%9B%9B%E6%9C%88%E5%BA%95.html</link>
      <guid>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B3%E5%9B%9B%E6%9C%88%E5%BA%95.html</guid>
      <pubDate>Tue, 11 Apr 2017 01:40:15 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;每日日程流程&quot;&gt;&lt;a href=&quot;#每日日程流程&quot; class=&quot;headerlink&quot; title=&quot;每日日程流程&quot;&gt;&lt;/a&gt;每日日程流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;刷面试题5x3;(3)&lt;/li&gt;
&lt;li&gt;刷剑指offer,4题(2.5小时)&lt;/li&gt;
&lt;li
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="每日日程流程"><a href="#每日日程流程" class="headerlink" title="每日日程流程"></a>每日日程流程</h1><ol>
<li>刷面试题5x3;(3)</li>
<li>刷剑指offer,4题(2.5小时)</li>
<li>Java面试知识点总结: 5点(30分钟)</li>
<li>下午看书: effective java/Spring/jvm</li>
<li>晚上总结成文档</li>
</ol>
<h1 id="Spring-IOC-AOP-MVC总结"><a href="#Spring-IOC-AOP-MVC总结" class="headerlink" title="Spring IOC/AOP/MVC总结"></a>Spring IOC/AOP/MVC总结</h1><ol>
<li>Spring AOP深入总结–4.15号之前完成,四天时间</li>
<li>Spring MVC深入总结–4.22号之前完成,一周时间</li>
<li>Spring ICO深入总结–4.29号之前完成,一周时间</li>
<li>总结其中用到的各种设计模式</li>
</ol>
<h1 id="剑指offer总结"><a href="#剑指offer总结" class="headerlink" title="剑指offer总结"></a>剑指offer总结</h1><ol>
<li>每日刷4题–4.22号之前将66个题刷完(基本完成,目前已经完成57题)</li>
<li>剑指offer刷题总结,分类整理总结–4.25号完成,三天时间(基本总结完成)</li>
</ol>
<h1 id="Effective-Java-1-4章-第10章"><a href="#Effective-Java-1-4章-第10章" class="headerlink" title="Effective Java: 1-4章,第10章"></a>Effective Java: 1-4章,第10章</h1><ol>
<li>涉及到的各种设计模式总结<ul>
<li>构建者模式,一天(已完成)</li>
<li>装饰者模式,一天(已完成)</li>
<li>适配器模式,一天(已完成)</li>
<li>FlyWeight模式,一天</li>
<li>桥接模式</li>
<li>观察者模式(书p234),一天</li>
</ul>
</li>
<li>总结Java对象通用方法:equals, hashCode, toString,  ,finalizeclone (已完成)</li>
</ol>
<h1 id="Java并发总结-深入理解jvm第五部分"><a href="#Java并发总结-深入理解jvm第五部分" class="headerlink" title="Java并发总结(深入理解jvm第五部分)"></a>Java并发总结(深入理解jvm第五部分)</h1><ol>
<li>java内存模型</li>
<li>java并发工具<ul>
<li>Executor framework</li>
<li>Concurrent Collection</li>
<li>Synchronizer</li>
</ul>
</li>
</ol>
<h1 id="Java垃圾回收总结"><a href="#Java垃圾回收总结" class="headerlink" title="Java垃圾回收总结"></a>Java垃圾回收总结</h1><ol>
<li>finalize与 System.gc();</li>
<li>Java内存管理机制</li>
<li>垃圾收集器与内存分配策略</li>
</ol>
<h1 id="面试题练习"><a href="#面试题练习" class="headerlink" title="面试题练习"></a>面试题练习</h1><ol>
<li>每天练习15道题目: 5x3;</li>
<li>Java面试常考知识点总结: 每日总结10点</li>
</ol>
<h1 id="每日进展记录"><a href="#每日进展记录" class="headerlink" title="每日进展记录"></a>每日进展记录</h1><h2 id="阶段一-4-12-4-15-剑指offer刷到50题"><a href="#阶段一-4-12-4-15-剑指offer刷到50题" class="headerlink" title="阶段一: 4.12-4.15(剑指offer刷到50题)"></a>阶段一: 4.12-4.15(剑指offer刷到50题)</h2><ul>
<li>4.12 剑指offer刷完40题,还剩26题;刷面试题5*3;</li>
<li>4.13 刷面试题5*3; 面试腾讯</li>
<li>4.14 刷剑指offer</li>
<li>4.15 剑指offer刷至50题!完成</li>
</ul>
<h2 id="阶段二-4-16-4-24-编程题总结一波"><a href="#阶段二-4-16-4-24-编程题总结一波" class="headerlink" title="阶段二: 4.16-4.24(编程题总结一波)"></a>阶段二: 4.16-4.24(编程题总结一波)</h2><ul>
<li>4.16-4.18  编程题归类总结</li>
<li>4.19 编程题基本总结完成</li>
</ul>
]]></content:encoded>
      
      <comments>http://liuhang.net.cn/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E8%87%B3%E5%9B%9B%E6%9C%88%E5%BA%95.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
